[
    {
        "id": "82ec3ee0-0199-1000-73e0-000062fe28a3",
        "name": "test",
        "description": "aa111",
        "version": 1,
        "questions": []
    },
    {
        "id": "82ec3ee0-0199-1000-73e0-000062fe28a3",
        "name": "test1",
        "description": "1aa111",
        "version": 2,
        "questions": []
    },
    {
        "id": "82ec3ee0-0199-1000-73e0-000062fe28a3",
        "name": "test1",
        "description": "1aa111",
        "version": 3,
        "questions": [
            {
                "id": "82f28a6e-0199-1000-d8ef-000048384807",
                "question": "1. What is the result of executing the following code snippet?\n\n41: final int score1 = 8, score2 = 3;\n42: Integer myScore = 7;\n43: var goal = switch (myScore) {\n44:     case score1, score2, 7 -> \"good\";\n45:     case Integer i when i < 10 -> \"better\";\n46:     case Integer i when i >= 10 -> \"best\";\n47:     default -> { yield \"unknown\"; }\n48:     case null -> \"nope\";\n49: };\n50: System.out.print(goal);",
                "answer_options": [
                    "A. good",
                    "B. better",
                    "C. best",
                    "D. unknown",
                    "E. nope",
                    "F. Line 44 does not compile.",
                    "G. Line 45 does not compile.",
                    "H. Line 46 does not compile.",
                    "I. Line 47 does not compile.",
                    "J. Line 48 does not compile."
                ],
                "correct_answer_indexes": [
                    9
                ],
                "correct_answer_explanation": "J. The code does not compile. In pattern matching switch statements,\nthe order matters. In this example, line 47 dominates line 48, leading to\nunreachable code on line 48, and making option J the correct answer."
            },
            {
                "id": "82f28a6e-0199-1000-7343-000029033e46",
                "question": "2. What is the output of the following code snippet?\n\nint moon = 9, star = 2 + 2 * 3;\nfloat sun = star > 10 ? 1 : 3;\ndouble jupiter = (sun + moon) - 1.0f;\nint mars = --moon <= 8 ? 2 : 3;\nSystem.out.println(sun + \", \" + jupiter + \", \" + mars);",
                "answer_options": [
                    "A. 1, 11, 2",
                    "B. 3.0, 11.0, 2",
                    "C. 1.0, 11.0, 3",
                    "D. 3.0, 13.0, 3",
                    "E. 3.0f, 12, 2",
                    "F. The code does not compile because one of the assignments"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "B. Initially, moon is assigned a value of 9, while star is assigned a\nvalue of 8. The multiplication operator (*) has a higher order of\nprecedence than the addition operator (+), so it gets evaluated first.\nSince star is not greater than 10, sun is assigned a value of 3, which is\npromoted to 3.0f as part of the assignment. The value of jupiter is\n(3.0f + 9) - 1.0, which is 11.0f. This value is implicitly promoted\nto double when it is assigned. In the last assignment, moon is\ndecremented from 9 to 8, with the value of the expression returned as\n8. Since 8 less than or equal to 8 is true, mars is set to a value of 2.\nThe final output is 3.0, 11.0, 2, making option B the correct answer.\nNote that while Java outputs the decimal for both float and double\nvalues, it does not output the f for float values."
            },
            {
                "id": "82f28a6f-0199-1000-6f0c-0000912658e8",
                "question": "3. Which APIs exist for creating or working with virtual threads?\n(Choose all that apply.)",
                "answer_options": [
                    "A. Executors.newVirtualThread()",
                    "B. Executors.newVirtualThreadExecutor()",
                    "C. Executors.newVirtualThreadPerTaskExecutor()",
                    "D. new VirtualThread()",
                    "E. Thread.ofVirtual()",
                    "F. Thread.ofVirtualThread()"
                ],
                "correct_answer_indexes": [
                    2,
                    4
                ],
                "correct_answer_explanation": "C, E. The Executors class has one factory method for working with\nvirtual threads. It is newVirtualThreadPerTaskExecutor(), making\noption C correct. There is no constructor for virtual threads. There is a\nfactory method Thread.ofVirtual(), making option E the other\nanswer."
            },
            {
                "id": "82f28a6f-0199-1000-9695-00002eaeb3d3",
                "question": "4. What is the output of this code?\n\n20: Predicate<String> empty = String::isEmpty;\n21: Predicate<String> notEmpty = empty.negate();\n22:\n23: var result = Stream.generate(() -> \"\")\n24:     .filter(notEmpty)\n25:     .collect(Collectors.groupingBy(k -> k))\n26:     .entrySet()\n27:     .stream()\n28:     .map(Entry::getValue)\n29:     .flatMap(Collection::stream)\n30:     .collect(Collectors.partitioningBy(notEmpty));\n31: System.out.println(result);",
                "answer_options": [
                    "A. It outputs {}.",
                    "B. It outputs {false=[], true=[]}.",
                    "C. The code does not compile.",
                    "D. The code does not terminate."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "D. First, this mess of code does compile. However, the source is an\ninfinite stream. The filter operation will check each element in turn to\nsee whether any are not empty. While nothing passes the filter, the\ncode does not terminate. Therefore, option D is correct."
            },
            {
                "id": "82f28a6f-0199-1000-a410-000012bd7074",
                "question": "5. What is the result of the following program?\n\n1: public class MathFunctions {\n2:     public static void addToInt(int x, int amountToAdd) {\n3:         x = x + amountToAdd % -5;\n4:     }\n5:     public static void main(String[] args) {\n6:         var a = 15;\n7:         var b = 10;\n8:         MathFunctions.addToInt(a, b);\n9:         System.out.println(a); } }",
                "answer_options": [
                    "A. 10",
                    "B. 15",
                    "C. 25",
                    "D. Compiler error on line 3",
                    "E. Compiler error on line 8",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "B. The code compiles successfully, so options D and E are incorrect.\nThe value of a cannot be changed by the addToInt() method, no\nmatter what the method does, because only a copy of the variable is\npassed into the parameter x. Therefore, a does not change, and the\noutput on line 9 is 15, which is option B. "
            },
            {
                "id": "82f28a6f-0199-1000-c396-0000a58286bf",
                "question": "6. Suppose that we have the following property files and code. What\nvalues are printed on lines 8 and 9, respectively?\nPenguin.properties\nname=Billy\nage=1\nPenguin_de.properties\nname=Chilly\nage=4\nPenguin_en.properties\nname=Willy\n\n5: Locale fr = Locale.of(\"fr\");\n6: Locale.setDefault(Locale.of(\"en\", \"US\"));\n7: var b = ResourceBundle.getBundle(\"Penguin\", fr);\n8: System.out.println(b.getString(\"name\"));\n9: System.out.println(b.getString(\"age\"));",
                "answer_options": [
                    "A. Billy and 1",
                    "B. Billy and null",
                    "C. Willy and 1",
                    "D. Willy and null",
                    "E. Chilly and null",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "C. Java will use Penguin_en.properties as the matching resource\nbundle on line 7. Since there is no match for French, the default locale\nis used. Line 8 finds a matching key in the Penguin_en.properties\nfile. Line 9 does not find a match in the Penguin_en.properties file;\ntherefore, it has to look higher up in the hierarchy to\nPenguin.properties. This makes option C the answer."
            },
            {
                "id": "82f28a6f-0199-1000-1612-0000533c91c9",
                "question": "7. What is guaranteed to be printed by the following code? (Choose all\nthat apply.)\n\nint[] array = {6, 9, 8};\nSystem.out.println(\"B\" + Arrays.binarySearch(array,9));\nSystem.out.println(\"C\" + Arrays.compare(array,\nnew int[] {6, 9, 8}));\nSystem.out.println(\"M\" + Arrays.mismatch(array,\nnew int[] {6, 9, 8}));",
                "answer_options": [
                    "A. B1",
                    "B. B2",
                    "C. C-1",
                    "D. C0",
                    "E. M-1",
                    "F. M0",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    3,
                    4
                ],
                "correct_answer_explanation": "D, E. The array is allowed to use an anonymous initializer because it is\nin the same line as the declaration. The results of the binary search are\nundefined since the array is not sorted. Since the question asks about\nguaranteed output, options A and B are incorrect. Option D is correct\nbecause the compare() method returns 0 when the arrays are the same\nlength and have the same elements. Option E is correct because the\nmismatch() method returns a -1 when the arrays are equivalent."
            },
            {
                "id": "82f28a70-0199-1000-5ddc-0000db9f8894",
                "question": "8. Which functional interfaces complete the following code, presuming\nvariable r exists? (Choose all that apply.)\n\n6: _____ x = r.negate();\n7: _____ y = () -> System.out.println();\n8: _____ z = (a, b) -> a - b;",
                "answer_options": [
                    "A. BinaryPredicate<Integer, Integer>",
                    "B. Comparable<Integer>",
                    "C. Comparator<Integer>",
                    "D. Consumer<Integer>",
                    "E. Predicate<Integer>",
                    "F. Runnable",
                    "G. Runnable<Integer>"
                ],
                "correct_answer_indexes": [
                    2,
                    4,
                    5
                ],
                "correct_answer_explanation": "C, E, F. First, note that option A is incorrect because the interface\nshould be BiPredicate and not BinaryPredicate. Line 6 requires you\nto know that negate() is a convenience method on Predicate. This\nmakes option E correct. Line 7 takes zero parameters and doesn’t\nreturn anything, making it a Runnable. Remember that Runnable\ndoesn’t use generics. This makes option F correct. Finally, line 8 takes\ntwo parameters and returns an int. Option C is correct. Comparable is\nthere to mislead you since it takes only one parameter in its single\nabstract method."
            },
            {
                "id": "82f28a70-0199-1000-8e7b-0000e54a716f",
                "question": "9. Suppose you have a module named com.vet. Where could you place\nthe following module-info.java file to create a valid module?\n\npublic module com.vet {\n  exports com.vet;\n}",
                "answer_options": [
                    "A. At the same level as the com folder",
                    "B. At the same level as the vet folder",
                    "C. Inside the vet folder",
                    "D. None of the above"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "D. If this were a valid module-info.java file, it would need to be\nplaced at the root directory of the module, which is option A.\nHowever, a module is not allowed to use the public access modifier.\nOption D is correct because the provided file does not compile\nregardless of placement in the project."
            },
            {
                "id": "82f28a70-0199-1000-2007-00009a153648",
                "question": "10. What is the output of the following program? (Choose all that apply.)\n\n15: interface HasTail { default int getTailLength() { return 2; } }\n16: abstract class Puma implements HasTail {\n17:   int getTailLength() { return 4; } }\n18: public class Cougar implements HasTail {\n19:   public static void main(String[] args) {\n20:     int length = 10;\n21:     try {\n22:       var puma = new Puma() {\n23:         public int getTailLength() { return length; }\n24:       };\n25:       System.out.print(puma.getTailLength());\n26:     } catch (Exception e) {\n27:       length++;\n28:     } }\n29:   public int getTailLength(int length) { return 2; }\n30: }",
                "answer_options": [
                    "A. 2",
                    "B. 4",
                    "C. 10",
                    "D. Line 15 does not compile.",
                    "E. Line 16 does not compile.",
                    "F. Line 17 does not compile.",
                    "G. Line 20 does not compile.",
                    "H. Lines 22–24 do not compile.",
                    "I. Line 27 does not compile.",
                    "J. None of the above."
                ],
                "correct_answer_indexes": [
                    5,
                    7
                ],
                "correct_answer_explanation": "F, H. A method within an abstract class without an access modifier is\nconsidered to have package access. The class inherits the default\nmethod from the interface and is implicitly public, which means line\n17 reduces the visibility of this access modifier. For this reason, line 17\ndoes not compile and option F is correct. Line 23 also does not\ncompile, as a local class can only access a local variable that is final\nor effectively final, making option H correct. If line 27 were removed,\nthen the variable would be effectively final and lines 22–24 would\ncompile."
            },
            {
                "id": "82f28a70-0199-1000-fabf-00007ec6f6c6",
                "question": "11. Which lines in Tadpole.java give a compiler error? (Choose all that\napply.)\n\n// Frog.java\n1: package animal;\n2: public class Frog {\n3:  protected void ribbit() { }\n4:  void jump() { }\n5:  }\n// Tadpole.java\n1: package other;\n2: import animal.*;\n3: public class Tadpole extends Frog {\n4:  public static void main(String[] args) {\n5:  Tadpole t = new Tadpole();\n6:  t.ribbit();\n7:  t.jump();\n8:  Frog f = new Tadpole();\n9:  f.ribbit();\n10: f.jump();\n11: } }",
                "answer_options": [
                    "A. Line 5.",
                    "B. Line 6.",
                    "C. Line 7.",
                    "D. Line 8.",
                    "E. Line 9.",
                    "F. Line 10.",
                    "G. All of the lines compile."
                ],
                "correct_answer_indexes": [
                    2,
                    4,
                    5
                ],
                "correct_answer_explanation": "C, E, F. The jump() method has package access, which means it can be\naccessed only from the same package. Tadpole is not in the same\npackage as Frog, causing lines 7 and 10 to trigger compiler errors and\ngiving us options C and F. The ribbit() method has protected\naccess, which means it can only be accessed from a subclass reference\nor in the same package. Line 6 is fine because Tadpole is a subclass.\nLine 9 does not compile, and our final answer is option E because the\nvariable reference is to a Frog, which doesn’t grant access to the\nprotected method."
            },
            {
                "id": "82f28a70-0199-1000-5b13-000014fc286e",
                "question": "12. Which of the following statements can fill in the blank to make the\ncode compile successfully? (Choose all that apply.)\n\nSet<? extends RuntimeException> mySet = new\n_______________ ();",
                "answer_options": [
                    "A. HashSet<? extends RuntimeException>",
                    "B. HashSet<Exception>",
                    "C. TreeSet<RuntimeException>",
                    "D. TreeSet<NullPointerException>",
                    "E. LinkedHashSet<>",
                    "F. LinkedHashSet<?>",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    2,
                    3,
                    4
                ],
                "correct_answer_explanation": "C, D, E. The mySet declaration defines an upper bound of type\nRuntimeException. This means that classes may specify\nRuntimeException or any subclass of RuntimeException as the type\nparameter. Option B is incorrect because Exception is a superclass,\nnot a subclass, of RuntimeException. Options A and F are incorrect\nbecause the wildcard cannot occur on the right side of the assignment.\nOptions C, D, and E compile and are the answers."
            },
            {
                "id": "82f28a71-0199-1000-b77c-000048a6fe01",
                "question": "13. Assume that birds.ser exists, is accessible, and contains data for a\nBird object. What is the result of executing the following code?\n(Choose all that apply.)\n\n1: import java.io.*;\n2: public class Bird {\n3: private String name;\n4: private transient Integer age;\n5:\n6: // Getters/setters omitted\n7:\n8: public static void main(String[] args) {\n9: try(var is = new ObjectInputStream(\n10: new BufferedInputStream(\n11: new FileInputStream(\"birds.ser\")))) {\n12: Bird b = is.readObject();\n13: System.out.println(b.age);\n14: } } }",
                "answer_options": [
                    "A. It compiles and prints 0 at runtime.",
                    "B. It compiles and prints null at runtime.",
                    "C. It compiles and prints a number at runtime.",
                    "D. The code will not compile because of lines 9–11.",
                    "E. The code will not compile because of line 12.",
                    "F. It compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    3,
                    4
                ],
                "correct_answer_explanation": "D, E. The declaration on lines 9–11 includes an unhandled checked\nIOException, making option D correct. Line 12 does not compile\nbecause is.readObject() must be cast to a Bird object to be assigned\nto b. It also does not compile because it includes two unhandled\nchecked exceptions, IOException and ClassNotFoundException,\nmaking option E correct. If a cast operation were added on line 12 and\nthe main() method were updated on line 8 to declare the various\nchecked exceptions, the code would compile but throw an exception at\nruntime since Bird does not implement Serializable. Finally, if the\nclass did implement Serializable, the program would print null at\nruntime, as that is the default value for the transient field age."
            },
            {
                "id": "82f28a71-0199-1000-f32b-0000cd264630",
                "question": "14. How many of the following declarations (lines 14–19) are valid\ninstance members of a class?\n\n13: public class Zoo {\n14:   var var = 3;\n15:   Var case = new Var();\n16:   void var() {}\n17:   int Var() { var _ = 7; return _;}\n18:   String new = \"var\";\n19:   var var() { return null; }\n20: }",
                "answer_options": [
                    "A. 0",
                    "B. 1",
                    "C. 2",
                    "D. 3",
                    "E. 4",
                    "F. 5"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "B. Line 14 does not compile because var is only allowed as a type for\nlocal variables, not instance members. Lines 15 and 18 do not compile\nbecause new and case are reserved words and cannot be used as\nidentifiers. Line 16 compiles, as var can be used as a method name.\nLine 17 does not compile because a single underscore (_) cannot be\nused as an identifier. Line 19 does not compile because var cannot be\nspecified as the return type of a method. Since only one line compiles,\noption B is the answer."
            },
            {
                "id": "82f28a71-0199-1000-41c5-0000ef5c1888",
                "question": "15. Which is true if the contents of path1 start with the text Howdy?\n(Choose two.)\n\nSystem.out.println(Files.mismatch(path1,path2));",
                "answer_options": [
                    "A. If path2 doesn’t exist, the code prints -1.",
                    "B. If path2 doesn’t exist, the code prints 0.",
                    "C. If path2 doesn’t exist, the code throws an exception.",
                    "D. If the contents of path2 start with Hello, the code prints -1.",
                    "E. If the contents of path2 start with Hello, the code prints 0.",
                    "F. If the contents of path2 start with Hello, the code prints 1."
                ],
                "correct_answer_indexes": [
                    2,
                    5
                ],
                "correct_answer_explanation": "C, F. Option C is correct as mismatch() throws an exception if the files\ndo not exist unless they both refer to the same file. Additionally, option\nF is correct because the first index that differs is returned, which is the\nsecond character. Since Java uses zero-based indexes, this is 1."
            },
            {
                "id": "82f28a71-0199-1000-99e3-0000af469504",
                "question": "16. Which of the following is the best type to insert into the blank to allow\nthe program to compile successfully?\n\n1: import java.util.*;\n2: final class Amphibian {}\n3: abstract class Tadpole extends Amphibian {}\n4: public class FindAllTadpoles {\n5: public static void main(String… args) {\n6: var tadpoles = new ArrayList<Tadpole>();\n7: for (var amphibian : tadpoles) {\n8: ______________ tadpole = amphibian;\n9: } } }",
                "answer_options": [
                    "A. List<Tadpole>",
                    "B. Boolean",
                    "C. Amphibian",
                    "D. Tadpole",
                    "E. Object",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "F. The Amphibian class is marked final, which means line 3 triggers a\ncompiler error and option F is correct."
            },
            {
                "id": "82f28a71-0199-1000-4a13-0000a77e99c5",
                "question": "17. What is the result of compiling and executing the following program?\n\n1: public class FeedingSchedule {\n2:   public static void main(String[] args) {\n3:     var x = 5;\n4:     var j = 0;\n5:     OUTER: for (var i = 0; i < 3;)\n6:       INNER: do {\n7:         i++;\n8:         x++;\n9:         if (x> 10) break INNER;\n10:        x += 4;\n11:        j++;\n12:      } while (j <= 2);\n13:       System.out.println(x);\n14:       } }",
                "answer_options": [
                    "A. 10",
                    "B. 11",
                    "C. 12",
                    "D. 17",
                    "E. The code will not compile because of line 5.",
                    "F. The code will not compile because of line 6."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "C. The code compiles and runs without issue; therefore, options E and\nF are incorrect. This type of problem is best examined one loop\niteration at a time:\n  On the first iteration of the outer loop, i is 0, so the loop\n  continues.\n  On the first iteration of the inner loop, i is updated to 1 and x to 6.\n  The if statement branch is not executed, and x is increased to 10\n  and j to 1.\n  On the second iteration of the inner loop (since j = 1 and 1 <= 2),\n  i is updated to 2 and x to 11. At this point, the if branch will\n  evaluate to true for the remainder of the program run, which\n  causes the flow to break out of the inner loop each time it is\n  reached.\n  On the second iteration of the outer loop (since i = 2), i is\n  updated to 3 and x to 12. As before, the inner loop is broken since\n  x is still greater than 10.\n  On the third iteration of the outer loop, the outer loop is broken,\n  as i is already not less than 3. The most recent value of x, 12, is\n  output, so the answer is option C."
            },
            {
                "id": "82f28a71-0199-1000-5d04-0000ca92ee77",
                "question": "18. When printed, which String gives the same value as this text block?\n\nvar pooh = \"\"\"\n\"Oh, bother.\" -Pooh\n\"\"\".indent(1);\nSystem.out.print(pooh);",
                "answer_options": [
                    "A. \"\\n\\\"Oh, bother.\\\" -Pooh\\n\"",
                    "B. \"\\n \\\"Oh, bother.\\\" -Pooh\\n\"",
                    "C. \" \\\"Oh, bother.\\\" -Pooh\\n\"",
                    "D. \"\\n\\\"Oh, bother.\\\" -Pooh\"",
                    "E. \"\\n \\\"Oh, bother.\\\" -Pooh\"",
                    "F. \" \\\"Oh, bother.\\\" -Pooh\"",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "C. First, note that the text block has the closing \"\"\" on a separate line,\nwhich means there is a new line at the end and rules out options D, E,\nand F. Additionally, text blocks don’t start with a new line, ruling out\noptions A and B. Therefore, option C is correct."
            },
            {
                "id": "82f28a72-0199-1000-516f-000039f0bb53",
                "question": "19. A(n) _________________ module always contains a module-\ninfo.java file, while a(n) _____________ module always exports all\nits packages to other modules.",
                "answer_options": [
                    "A. automatic, named",
                    "B. automatic, unnamed",
                    "C. named, automatic",
                    "D. named, unnamed",
                    "E. unnamed, automatic",
                    "F. unnamed, named",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "C. Only named modules are required to have a module-info.java file,\nruling out options A, B, E, and F. Unnamed modules are not readable\nby any other types of modules, ruling out option D. Automatic\nmodules always export all packages to other modules, making the\nanswer option C."
            },
            {
                "id": "82f28a72-0199-1000-2195-000013e0f7e5",
                "question": "20. What is the result of the following code?\n\n22: SequencedMap<Character,Integer> t = new TreeMap<>();\n23: t.put('k', 1);\n24: t.put('m', 2);\n25: var u = Collections.unmodifiableMap(t);\n26: t.put('m', 3);\n27: t.putFirst('m', 4);\n28: t.putLast('x', 5);\n29: t.replaceAll((k, v) -> v + v);\n30: u.entrySet()\n31:   .stream()\n32:   .map(e -> e.getValue())\n33:   .forEach(System.out::print);",
                "answer_options": [
                    "A. 145",
                    "B. 125",
                    "C. 135",
                    "D. 2468",
                    "E. 2810",
                    "F. 2410",
                    "G. The code does not compile.",
                    "H. The code compiles but line 26 throws an exception at runtime.",
                    "I. None of the above."
                ],
                "correct_answer_indexes": [
                    8
                ],
                "correct_answer_explanation": "I. The code compiles, so option G is incorrect. Line 26 does not throw\nan exception, as we are modifying the underlying collection, not the\nunmodifiable map, so option H is incorrect. Lines 27 and 28 each\nthrow an UnsupportedOperationException (when run independently).\nTreeMap is a SequencedMap, so while it does inherit these methods, it\ndoes not support them. Doing so could break the ordering for the\nComparator."
            },
            {
                "id": "82f28a72-0199-1000-a4b8-00002cccc90e",
                "question": "21. Which of the following lines can fill in the blank to print true?\n(Choose all that apply.)\n\n10: public static void main(String[] args) {\n11: System.out.println(test(__________________________________) );\n12: }\n13: private static boolean test(Function<Integer, Boolean> b) {\n14: return b.apply(5);\n15: }",
                "answer_options": [
                    "A. i::equals(5)",
                    "B. i -> {i == 5;}",
                    "C. (i) -> i == 5",
                    "D. (int i) -> i == 5",
                    "E. (int i) -> {return i == 5;}",
                    "F. (i) -> {return i == 5;}"
                ],
                "correct_answer_indexes": [
                    2,
                    5
                ],
                "correct_answer_explanation": "C, F. Option A looks like a method reference. However, it doesn’t call\na valid method, nor can method references take parameters. The\nPredicate interface takes a single parameter and returns a boolean.\nLambda expressions with one parameter are allowed, but not required,\nto omit the parentheses around the parameter list, making option C\ncorrect. The return statement is optional when a single statement is in\nthe body, making option F correct. Option B is incorrect because a\nreturn statement must be used if braces are included around the body.\nOptions D and E are incorrect because the type is Integer in the\npredicate and int in the lambda. Autoboxing works for collections, not\ninferring predicates. If these two were changed to Integer, they would\nbe correct"
            },
            {
                "id": "82f28a72-0199-1000-807b-0000b74d2f4f",
                "question": "22. How many times is the word true printed?\n\nvar s1 = \"Java\";\nvar s2 = \"Java\";\nvar s3 = s1.indent(1).strip();\nvar s4 = s3.intern();\nvar sb1 = new StringBuilder();\nsb1.append(\"Ja\").append(\"va\");\nSystem.out.println(s1 == s2);\nSystem.out.println(s1.equals(s2));\nSystem.out.println(s1 == s3);\nSystem.out.println(s1 == s4);\nSystem.out.println(sb1.toString() == s1);\nSystem.out.println(sb1.toString().equals(s1));",
                "answer_options": [
                    "A. Once.",
                    "B. Twice.",
                    "C. Three times.",
                    "D. Four times.",
                    "E. Five times.",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "D. String literals are used from the string pool. This means that s1 and\ns2 refer to the same object and are equal. Therefore, the first two print\nstatements print true. While the indent() and strip() methods\ncreate new String objects and the third statement prints false, the\nintern() method reverts the String to the one from the string pool.\nTherefore, the fourth print statement prints true. The fifth print\nstatement prints false because toString() uses a method to compute\nthe value, and it is not from the string pool. The final print statement\nagain prints true because equals() looks at the values of String\nobjects. Since four are true, option D is the answer."
            },
            {
                "id": "82f28a72-0199-1000-59eb-0000392b92e3",
                "question": "23. What is the output of the following program?\n\n1: class Deer {\n2: public Deer() {System.out.print(\"Deer\");}\n3: public Deer(int age) {System.out.print(\"DeerAge\");}\n4: protected boolean hasHorns() { return false; }\n5: }\n6: public class Reindeer extends Deer {\n7: public Reindeer(int age) {System.out.print(\"Reindeer\");}\n8: public boolean hasHorns() { return true; }\n9: public static void main(String[] args) {\n10: Deer deer = new Reindeer(5);\n11: System.out.println(\",\" + deer.hasHorns());\n12: } }",
                "answer_options": [
                    "A. ReindeerDeer,false",
                    "B. DeerAgeReindeer,true",
                    "C. DeerReindeer,true",
                    "D. DeerReindeer,false",
                    "E. ReindeerDeer,true",
                    "F. DeerAgeReindeer,false",
                    "G. The code will not compile because of line 4.",
                    "H. The code will not compile because of line 11."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "C. The Reindeer object is instantiated using the constructor that takes\nan int value. Since there is no explicit call to the parent constructor,\nthe compiler inserts super() as the first line of the constructor on line\n7. The parent constructor is called, and Deer is printed on line 2. The\nflow returns to the constructor on line 7, with Reindeer being printed.\nNext, the hasHorns() method is called. The reference type is Deer,\nand the underlying object type is Reindeer. Since Reindeer correctly\noverrides the hasHorns() method, the version in Reindeer is called,\nwith line 11 printing ,true. Therefore, option C is correct."
            },
            {
                "id": "82f28a72-0199-1000-af84-0000e06e8f3f",
                "question": "24. Which of the following are true? (Choose all that apply.)\n\nprivate static void magic(Stream<Integer> s) {\nOptional o = s\n.filter(x -> x < 5)\n.limit(3)\n.max((x, y) -> x - y);\nSystem.out.println(o.get());\n}",
                "answer_options": [
                    "A. magic(Stream.empty()); runs infinitely.",
                    "B. magic(Stream.empty()); throws an exception.",
                    "C. magic(Stream.iterate(1, x -> x++)); runs infinitely.",
                    "D. magic(Stream.iterate(1, x -> x++)); throws an exception.",
                    "E. magic(Stream.of(5, 10)); runs infinitely.",
                    "F. magic(Stream.of(5, 10)); throws an exception.",
                    "G. The method does not compile."
                ],
                "correct_answer_indexes": [
                    1,
                    5
                ],
                "correct_answer_explanation": "B, F. Calling get() on an empty Optional causes an exception to be\nthrown, making option B correct. Option F is also correct because\nfilter() makes the Optional empty before it calls get(). Option C is\nincorrect because the infinite stream is made finite by the intermediate\nlimit() operation. Options A and E are incorrect because the source\nstreams are not infinite. Therefore, the call to max() sees only three\nelements and terminates."
            },
            {
                "id": "82f28a72-0199-1000-db79-0000c6de7dfc",
                "question": "25. Assuming the following declarations are top-level types declared in the\nsame file, which successfully compile? (Choose all that apply.)",
                "answer_options": [
                    "A. Music",
                    "B. Song",
                    "C. Dance",
                    "D. March",
                    "E. Ballet",
                    "F. NewDance",
                    "G. None of them compile"
                ],
                "correct_answer_indexes": [
                    2,
                    3
                ],
                "correct_answer_explanation": "C, D. Music does not compile because a record cannot contain instance\nvariables that are not declared as part of the record. Song does not\ncompile because a compact record constructor does not allow\nmodifying an instance variable with a this reference. Dance does\ncompile, making option C correct. A permits clause is optional for a\nsealed class if the associated classes are in the same file. March also\ncompiles, making option D correct. A pattern matching switch can\ninclude elements of the record and use var. Ballet does not compile,\nas it is missing parentheses in the constructor. Remember, only records\nsupport compact constructors. NewDance also does not compile as a\nclass that extends sealed classes must be marked final, sealed, or\nnon-sealed."
            },
            {
                "id": "82f28a72-0199-1000-8295-0000e546ce98",
                "question": "26. Which of the following expressions compile without error? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. int monday = 3 + 2.0;",
                    "B. double tuesday = 5_6L;",
                    "C. boolean wednesday = 1 > 2 ? !true;",
                    "D. short thursday = (short)Integer.MAX_VALUE;",
                    "E. long friday = 8.0L;",
                    "F. var saturday = 2_.0;",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "B, D. Option A does not compile, as the expression 3 + 2.0 is\nevaluated as a double, and a double requires an explicit cast to be\nassigned to an int. Option B compiles without issue, as a long value\ncan be implicitly cast to a double. Option C does not compile because\nthe ternary operator (? :) is missing a colon (:), followed by a second\nexpression. Option D is correct. Even though the int value is larger\nthan a short, it is explicitly cast to a short, which means the value\nwill wrap around to fit in a short. Option E is incorrect, as you cannot\nuse a decimal (.) with the long (L) postfix. Finally, option F is\nincorrect, as an underscore cannot be used next to a decimal point."
            },
            {
                "id": "82f28a72-0199-1000-f4a3-000085010b0d",
                "question": "27. What is the result of executing the following application?\n\nfinal var cb = new CyclicBarrier(3,\n() -> System.out.println(\"Clean!\")); // u1\ntry (var service = Executors.newSingleThreadExecutor()) {\nIntStream.generate(() -> 1)\n.limit(12)\n.parallel()\n.forEach(i -> service.submit(() -> cb.await())); // u2\n}",
                "answer_options": [
                    "A. It outputs Clean! at least once.",
                    "B. It outputs Clean! exactly four times.",
                    "C. The code will not compile because of line u1.",
                    "D. The code will not compile because of line u2.",
                    "E. It compiles but throws an exception at runtime.",
                    "F. It compiles but waits forever at runtime."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "F. The code compiles without issue. The key to understanding this\ncode is to notice that our thread executor contains only one thread, but\nour CyclicBarrier limit is 3. Even though 12 tasks are all successfully\nsubmitted to the service, the first task will block forever on the call to\nawait(). Since the barrier is never reached, nothing is printed, and the\nprogram hangs, making option F correct."
            },
            {
                "id": "82f28a73-0199-1000-5b89-00004bc9a61c",
                "question": "28. Which statement about the following method is true?\n\n5: public static void main(String… unused) {\n6: System.out.print(\"a\");\n7: try (StringBuilder reader = new StringBuilder()) {\n8: System.out.print(\"b\");\n9: throw new IllegalArgumentException();\n10: } catch (Exception e | RuntimeException e) {\n11: System.out.print(\"c\");\n12: throw new FileNotFoundException();\n13: } finally {\n14: System.out.print(\"d\");\n15: } }",
                "answer_options": [
                    "A. It compiles and prints abc.",
                    "B. It compiles and prints abd.",
                    "C. It compiles and prints abcd.",
                    "D. One line contains a compiler error.",
                    "E. Two lines contain a compiler error.",
                    "F. Three lines contain a compiler error.",
                    "G. It compiles but prints an exception at runtime."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "F. Line 5 does not compile as the FileNotFoundException thrown on\nline 12 is not handled or declared by the method. Line 7 does not\ncompile because StringBuilder does not implement AutoCloseable\nand is therefore not compatible with a try-with-resource statement.\nFinally, line 10 does not compile as RuntimeException is a subclass of\nException in the multi-catch block, making it redundant. Since this\nmethod contains three compiler errors, option F is the correct answer."
            },
            {
                "id": "82f28a73-0199-1000-206c-00005029a69e",
                "question": "1. Which of the following are legal entry point methods that can be run from the\ncommand line? (Choose all that apply.)",
                "answer_options": [
                    "A. 1. private static void main(String[] args)",
                    "B. 2. public static final main(String[] args)",
                    "C. 3. public void main(String[] args)",
                    "D. 4. public static final void main(String[] args)",
                    "E. 5. public static void main(String[] args)",
                    "F. 6. public static main(String[] args)"
                ],
                "correct_answer_indexes": [
                    3,
                    4
                ],
                "correct_answer_explanation": "D, E. Option E is the canonical main() method signature. You need to\nmemorize it. Option D is an alternate form with the redundant final.\nOption A is incorrect because the main() method must be public.\nOptions B and F are incorrect because the main() method must have a\nvoid return type. Option C is incorrect because the main() method\nmust be static."
            },
            {
                "id": "82f28a73-0199-1000-f0b0-00001bacf853",
                "question": "2. Which answer options represent the order in which the following statements can\nbe assembled into a program that will compile successfully? (Choose all that\napply.)",
                "answer_options": [
                    "A. 1. X, Y, Z",
                    "B. 2. Y, Z, X",
                    "C. 3. Z, Y, X",
                    "D. 4. Y, X",
                    "E. 5. Z, X",
                    "F. 6. X, Z",
                    "G. 7. None of the above"
                ],
                "correct_answer_indexes": [
                    2,
                    3,
                    4
                ],
                "correct_answer_explanation": "2. C, D, E. The package and import statements are both optional. If both\nare present, the order must be package, then import, and then class.\nOption A is incorrect because class is before package and import.\nOption B is incorrect because import is before package. Option F is\nincorrect because class is before package."
            },
            {
                "id": "82f28a73-0199-1000-de4b-000014484d49",
                "question": "3. Which of the following are true? (Choose all that apply.)\npublic class Bunny {\npublic static void main(String[] x) {\nBunny bun = new Bunny();\n} }",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "A, E. Bunny is a class, which can be seen from the declaration: public\nclass Bunny. The variable bun is a reference to an object. The method\nmain() is the standard entry point to a program. Option G is incorrect\nbecause the parameter type matters, not the parameter name"
            },
            {
                "id": "82f28a73-0199-1000-0820-000054a566f3",
                "question": "4. Which of the following are valid Java identifiers? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "4. B, E, G. Option A is invalid because a single underscore is not\nallowed. Option C is not a valid identifier because true is a Java\nreserved word. Option D is not valid because a period (.) is not\nallowed in identifiers. Option F is not valid because the first character\nis not a letter, dollar sign ($), or underscore (_). Options B, E, and G\nare valid because they contain only valid characters"
            },
            {
                "id": "82f28a73-0199-1000-346a-0000a02c3a28",
                "question": "5. Which statements about the following program are correct? (Choose all that\napply.)\n\n2: public class Bear {\n3: private Bear pandaBear;\n4: private void roar(Bear b) {\n5: System.out.println(\"Roar!\");\n6: pandaBear = b;\n7: }\n8: public static void main(String[] args) {\n9: Bear brownBear = new Bear();\n10: Bear polarBear = new Bear();\n11: brownBear.roar(polarBear);\n12: polarBear = null;\n13: brownBear = null;\n14: System.gc(); } }",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "5. A, D, F. Garbage collection is never guaranteed to run, making option\nF correct and option E incorrect. Next, the class compiles and runs\nwithout issue, so option G is incorrect. The Bear object created on line\n9 is accessible until line 13 via the brownBear reference variable,\nwhich is option A. The Bear object created on line 10 is accessible via\nboth the polarBear reference and the brownBear.pandaBear\nreference. After line 12, the object is still accessible via\nbrownBear.pandaBear. After line 13, though, it is no longer accessible\nsince brownBear is no longer accessible, which makes option D the\nfinal correct answer."
            },
            {
                "id": "82f28a73-0199-1000-e30b-00002dbd9821",
                "question": "6. Assuming the following class compiles, how many variables defined in the class\nor method are in scope on the line marked on line 14?",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "6. F. To solve this problem, you need to trace the braces ({}) and see\nwhen variables go in and out of scope. The variables on lines 2 and 7\nare only in scope for a single line block. The variable on line 12 is only\nin scope for the for loop. None of these is in scope on line 14. By\ncontrast, the three instance variables on lines 3 and 4 are available in\nall instance methods. Additionally, the variables on lines 6, 9, and 10\nare available since the method and while loop are still in scope. This is\na total of 7 variables, which is option F."
            },
            {
                "id": "82f28a73-0199-1000-ed0c-00003b7f6063",
                "question": "7. Which are true about this code? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "C, E. The first thing to recognize is that this is a text block and the\ncode inside the \"\"\" is just text. Options A and B are incorrect because\nthe numForks and numKnives variables are not used. This is convenient\nsince numKnives is not initialized and would not compile if it were\nreferenced. Option C is correct as it is matching text. Option D is\nincorrect because the text block does not have a trailing blank line.\nFinally, option E is also an answer since \" # knives is indented."
            },
            {
                "id": "82f28a73-0199-1000-2ccb-0000c4ebfe84",
                "question": "8. Which of the following code snippets about var compile without issue when\nused in a method? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "8. B, D, E, H. A var cannot be initialized with a null value without a\ntype, but it can be assigned a null value later if the underlying type is\nnot a primitive. For these reasons, option H is correct, but options A\nand C are incorrect. Options B and D are correct as the underlying\ntypes are String and Integer, respectively. Option E is correct as this\nis a valid numeric expression. You might know that dividing by zero\nproduces a runtime exception, but the question was only about whether\nthe code compiled. Finally, options F and G are incorrect as var cannot\nbe used in a multiple-variable assignment."
            },
            {
                "id": "82f28a73-0199-1000-4353-0000e7602e9e",
                "question": "9. Which of the following is correct?",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "9. E. Options C and D are incorrect because local variables don’t have\ndefault values. Option A is incorrect because float should have a\ndecimal point. Option B is incorrect because primitives do not default\nto null. Option E is correct and option F incorrect because reference\ntypes in class variables default to null."
            },
            {
                "id": "82f28a73-0199-1000-122c-000031c975fb",
                "question": "10. Which of the following expressions, when inserted independently into the blank\nline, allow the code to compile? (Choose all that apply.)\n\npublic void printMagicData() {\nvar magic = ;\nSystem.out.println(magic);\n}",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "10. A, E, F. An underscore (_) can be placed in any numeric literal, as long\nas it is not at the beginning, at the end, or next to a decimal point (.).\nUnderscores can even be placed next to each other. For these reasons,\noptions A, E, and F are correct. Options B and D are incorrect as the\nunderscore (_) is next to a decimal point (.). Options C and G are\nincorrect because an underscore (_) cannot be placed at the beginning\nor end of the literal."
            },
            {
                "id": "82f28a74-0199-1000-31a5-00003723be25",
                "question": "11. Given the following two class files, what is the maximum number of imports that\ncan be removed and have the code still compile?",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "11. E. The first two imports can be removed because java.lang is\nautomatically imported. The following two imports can be removed\nbecause Tank and Water are in the same package, making the correct\noption E. If Tank and Water were in different packages, exactly one of\nthese two imports could be removed. In that case, the answer would be\noption D."
            },
            {
                "id": "82f28a74-0199-1000-118a-00006e30a251",
                "question": "12. Which statements about the following class are correct? (Choose all that apply.)\n\n1: public class ClownFish {\n2: int gills = 0, double weight=2;\n3: { int fins = gills; }\n4: void print(int length = 3) {\n5: System.out.println(gills);\n6: System.out.println(weight);\n7: System.out.println(fins);\n8: System.out.println(length);\n9: } }\n\n1. Line 2 generates a compiler error.\n2. Line 3 generates a compiler error.\n3. Line 4 generates a compiler error.\n4. Line 7 generates a compiler error.\n5. The code prints 0.\n6. The code prints 2.0.\n7. The code prints 2.\n8. The code prints 3.",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "12. A, C, D. Line 2 does not compile as only one type should be specified,\nmaking option A correct. Line 3 compiles without issue as it declares a\nlocal variable inside an instance initializer that is never used. Line 4\ndoes not compile because Java does not support setting default method\nparameter values, making option C correct. Finally, line 7 does not\ncompile because fins is in scope and accessible only inside the\ninstance initializer on line 3, making option D correct."
            },
            {
                "id": "82f28a74-0199-1000-ccd9-00003a094691",
                "question": "13. Given the following classes, which of the following snippets can independently\nbe inserted in place of INSERT IMPORTS HERE and have the code compile?\n(Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "A, B, C. Option A is correct because it imports all the classes in the\naquarium package including aquarium.Water. Options B and C are\ncorrect because they import Water by class name. Since importing by\nclass name takes precedence over wildcards, these compile. Option D\nis incorrect because Java doesn’t know which of the two wildcard\nWater classes to use. Option E is incorrect because you cannot specify\nthe same class name in two imports."
            },
            {
                "id": "82f28a74-0199-1000-474f-00008634d29d",
                "question": "14. Which of the following statements about the code snippet are true? (Choose all\nthat apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "14. A, B, D, E. Line 3 does not compile because the L suffix makes the\nliteral value a long, which cannot be stored inside a short directly,\nmaking option A correct. Line 4 does not compile because int is an\nintegral type, but 2.0 is a double literal value, making option B\ncorrect. Line 5 compiles without issue. Lines 6 and 7 do not compile\nbecause numPets and numGrains are both primitives, and you can call\nmethods only on reference types, not primitive values, making options\nD and E correct, respectively. Finally, line 8 compiles because there is\na length() method defined on String."
            },
            {
                "id": "82f28a74-0199-1000-e755-00005bd3877b",
                "question": "15. Which of the following statements about garbage collection are correct? (Choose\nall that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "15. C, E, F. In Java, there are no guarantees about when garbage collection\nwill run. The JVM is free to ignore calls to System.gc(). For this\nreason, options A, B, and D are incorrect. Option C is correct as the\npurpose of garbage collection is to reclaim used memory. Option E is\nalso correct that an object may never be garbage collected, such as if\nthe program ends before garbage collection runs. Option F is correct\nand is the primary means by which garbage collection algorithms\ndetermine whether an object is eligible for garbage collection. Finally,\noption G is incorrect as marking a variable final means it is constant\nwithin its own scope. For example, a local variable marked final will\nbe eligible for garbage collection after the method ends, assuming\nthere are no other references to the object that exist outside the\nmethod."
            },
            {
                "id": "82f28a74-0199-1000-ab3a-00003711eb19",
                "question": "16. Which are true about this code? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "16. A, D. Option A is correct. There are two lines. One starts with\nsquirrel, and the other starts with pigeon. Remember that a\nbackslash means to skip the line break. Option D is also correct as \\s\nmeans to keep whitespace. In a text block, incidental indentation is\nignored, making option F incorrect."
            },
            {
                "id": "82f28a74-0199-1000-60be-000082977425",
                "question": "17. What lines are printed by the following program? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "17. D, F, G. The code compiles and runs without issue, so options A and B\nare incorrect. A boolean field initializes to false, making option D\ncorrect with Empty = false being printed. Object references initialize\nto null, not the empty String, so option F is correct with Brand =\nnull being printed. Finally, the default value of floating-point numbers\nis 0.0. Although float values can be declared with an f suffix, they\nare not printed with an f suffix. For these reasons, option G is correct\nand Code = 0.0 is printed."
            },
            {
                "id": "82f28a74-0199-1000-c66d-0000dc16a7b6",
                "question": "18. Which of the following statements about var are true? (Choose all that apply.)",
                "answer_options": [
                    "A. 1. A var can be used as a constructor parameter.",
                    "B. 2. The type of a var is known at compile time.",
                    "C. 3. A var cannot be used as an instance variable.",
                    "D. 4. A var can be used in a multiple variable assignment statement.",
                    "E. 5. The value of a var cannot change at runtime.",
                    "F. 6. The type of a var cannot change at runtime.",
                    "G. 7. The word var is a reserved word in Java"
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    5
                ],
                "correct_answer_explanation": "18. B, C, F. A var cannot be used for a constructor or method parameter or\nfor an instance or class variable, making option A incorrect and option\nC correct. The type of a var is known at compile time, and the type\ncannot be changed at runtime, although its value can change at\nruntime. For these reasons, options B and F are correct, and option E is\nincorrect. Option D is incorrect, as var is not permitted in multiple-\nvariable declarations. Finally, option G is incorrect, as var is not a\nreserved word in Java."
            },
            {
                "id": "82f28a74-0199-1000-3ed8-00009823d7fd",
                "question": "19. Which are true about the following code? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "19. A, D. The first two lines provide a way to convert a String into a\nnumber. The first is a int primitive, and the second is a Integer\nreference object, making option D one of the answers. Remember that\nB is 11 in base 16. The code is correct, and the maximum is 11, which\nis option A."
            },
            {
                "id": "82f28a75-0199-1000-8b36-00000e781691",
                "question": "20. Which statement about the following class is correct?",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "20. C. The key thing to notice is that line 4 does not define a constructor\nbut instead a method named PoliceBox(), since it has a return type of\nvoid. This method is never executed during the program run, and\ncolor and age are assigned the default values null and 0L,\nrespectively. Lines 11 and 12 change the values for an object\nassociated with p, but then, on line 13, the p variable is changed to\npoint to the object associated with q, which still has the default values.\nFor this reason, the program prints Q1=null, Q2=0, P1=null, and P2=0,\nmaking option C the only correct answer."
            },
            {
                "id": "82f28a75-0199-1000-da1b-0000e413c6ad",
                "question": "21. What is the output of executing the following class?",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "21. D. We start with the main() method, which prints 7- on line 10. Next,\na new Salmon instance is created on line 11. This causes the two\ninstance initializers on lines 3 and 4 to be executed in order. The\ndefault value of an instance variable of type int is 0, so 0- is printed\nnext, and count is assigned a value of 1. Next, the constructor is\ncalled. This assigns a value of 4 to count and prints 2-. Finally, line 12\nprints 4-, since that is the value of count. Putting it all together, we\nhave 7-0-2-4-, making option D the correct answer."
            },
            {
                "id": "82f28a75-0199-1000-5c16-0000d0e955b1",
                "question": "22. Given the following class, which of the following lines of code can\nindependently replace INSERT CODE HERE to make the code compile? (Choose all\nthat apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "22. C, F, G. First, 0b is the prefix for a binary value, and 0x is the prefix\nfor a hexadecimal value. These values can be assigned to many\nprimitive types, including int and double, making options C and F\ncorrect. Option A is incorrect because naming the variable Amount will\ncause the System.out.print(amount) call on the next line to not\ncompile. Option B is incorrect because 9L is a long value. If the type\nwas changed to long amount = 9L, then it would compile. Option D is\nincorrect because 1_2.0 is a double value. If the type was changed to\ndouble amount = 1_2.0, then it would compile. Options E and H are\nincorrect because the underscore (_) appears next to the decimal point\n(.), which is not allowed. Finally, option G is correct, and the\nunderscore and assignment usage is valid."
            },
            {
                "id": "82f28a75-0199-1000-6e19-0000fa8c5148",
                "question": "23. Which statements about the following class are true? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "23. A, D. The first compiler error is on line 3. The variable temp is\ndeclared as a float, but the assigned value is 50.0, which is a double\nwithout the F/f postfix. Since a double doesn’t fit inside a float, line\n3 does not compile. Next, depth is declared inside the for loop and\nhas scope only inside this loop. Therefore, reading the value on line 10\ntriggers a compiler error. For these reasons, options A and D are the\ncorrect answers."
            },
            {
                "id": "82f28a75-0199-1000-9511-0000c5228784",
                "question": "1. Which of the following Java operators can be used with boolean\nvariables? (Choose all that apply.)",
                "answer_options": [
                    "A. ==",
                    "B. +",
                    "C. --",
                    "D. !",
                    "E. %",
                    "F. -",
                    "G. Cast with (boolean)"
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    6
                ],
                "correct_answer_explanation": "1. A, D, G. Option A is the equality operator and can be used on\nprimitives and object references. Options B and C are both arithmetic\noperators and cannot be applied to a boolean value. Option D is the\nlogical complement operator and is used exclusively with boolean\nvalues. Option E is the modulus operator, which can be used only with\nnumeric primitives. Option F is a negation/subtraction operator and\ncan be applied only to numeric values. Finally, option G is correct, as\nyou can cast a boolean variable since boolean is a type."
            },
            {
                "id": "82f28a75-0199-1000-ddac-0000eaf47a7c",
                "question": "2. What data type (or types) will allow the following code snippet to\ncompile? (Choose all that apply.)",
                "answer_options": [
                    "A. int",
                    "B. long",
                    "C. boolean",
                    "D. double",
                    "E. short",
                    "F. byte"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    3
                ],
                "correct_answer_explanation": "2. A, B, D. The expression apples + oranges is automatically promoted\nto int, so int and data types that can be promoted automatically from\nint will work, making options A, B, and D correct. Option C will not\nwork because boolean is not a numeric data type. Options E and F will\nnot work without an explicit cast to a smaller data type."
            },
            {
                "id": "82f28a75-0199-1000-8888-000096b91e4f",
                "question": "3. What change, when applied independently, would allow the following\ncode snippet to compile? (Choose all that apply.)\n\n3: long ear = 10;\n4: int hearing = 2 * ear;",
                "answer_options": [
                    "A. No change; it compiles as is.",
                    "B. Cast ear on line 4 to int.",
                    "C. Change the data type of ear on line 3 to short.",
                    "D. Cast 2 * ear on line 4 to int.",
                    "E. Change the data type of hearing on line 4 to short.",
                    "F. Change the data type of hearing on line 4 to long."
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    3,
                    5
                ],
                "correct_answer_explanation": "3. B, C, D, F. The code will not compile as is, so option A is not correct.\nThe value 2 * ear is automatically promoted to long and cannot be\nautomatically stored in hearing, which is an int value. Options B, C,\nand D solve this problem by reducing the long value to int. Option E\ndoes not solve the problem and actually makes it worse by attempting\nto place the value in a smaller data type. Option F solves the problem\nby increasing the data type of the declaration so that long is allowed."
            },
            {
                "id": "82f28a75-0199-1000-9862-00001e7931c6",
                "question": "4. What is the output of the following code snippet?\n\n3: boolean canine = true, wolf = true;\n4: int teeth = 20;\n5: canine = (teeth != 10) ^ (wolf=false);\n6: System.out.println(canine+\", \"+teeth+\", \"+wolf);",
                "answer_options": [
                    "A. true, 20, true",
                    "B. true, 20, false",
                    "C. false, 10, true",
                    "D. false, 20, false",
                    "E. The code will not compile because of line 5.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "4. B. The code compiles and runs without issue, so option E is not\ncorrect. This example is tricky because of the second assignment\noperator embedded in line 5. The expression (wolf=false) assigns the\nvalue false to wolf and returns false for the entire expression. Since\nteeth does not equal 10, the left side returns true; therefore, the\nexclusive or (^) of the entire expression assigned to canine is true.\nThe output reflects these assignments, with no change to teeth, so\noption B is the only correct answer."
            },
            {
                "id": "82f28a75-0199-1000-0cad-00005235998d",
                "question": "5. Which of the following operators are ranked in increasing or the same\norder of precedence? Assume the + operator is binary addition, not the\nunary form. (Choose all that apply.)",
                "answer_options": [
                    "A. +, *, %, --",
                    "B. ++, (int), *",
                    "C. =, ==, !",
                    "D. (short), =, !, *",
                    "E. *, /, %, +, ==",
                    "F. !, ||, &",
                    "G. ^, +, =, +="
                ],
                "correct_answer_indexes": [
                    0,
                    2
                ],
                "correct_answer_explanation": "5. A, C. Options A and C are correct, as they show operators in\nincreasing or the same order of precedence. Options B and E are in\ndecreasing or the same order of precedence. Options D, F, and G are in\nneither increasing nor decreasing order of precedence. In option D, the\nassignment operator (=) is between two unary operators, with the\nmultiplication operator (*) incorrectly being in place of highest\nprecedence. In option F, the logical complement operator (!) has the\nhighest order of precedence, so it should be last. In option G, the\nassignment operators have the lowest order of precedence, not the\nhighest, so the last two operators should be first."
            },
            {
                "id": "82f28a75-0199-1000-7902-0000eae507f0",
                "question": "6. What is the output of the following program?\n\n1: public class CandyCounter {\n2: static long addCandy(double fruit, float vegetables)\n{\n3: return (int)fruit+vegetables;\n4: }\n5:\n6: public static void main(String[] args) {\n7: System.out.print(addCandy(1.4, 2.4f) + \", \");\n8: System.out.print(addCandy(1.9, (float)4) + \", \");\n9: System.out.print(addCandy((long)(int)(short)2,\n(float)4)); } }",
                "answer_options": [
                    "A. 4, 6, 6.0",
                    "B. 3, 5, 6",
                    "C. 3, 6, 6",
                    "D. 4, 5, 6",
                    "E. The code does not compile because of line 9.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "6. F. The code does not compile because line 3 contains a compilation\nerror. The cast (int) is applied to fruit, not the expression\nfruit+vegetables. Since the cast operator has a higher operator\nprecedence than the addition operator, it is applied to fruit, but the\nexpression is promoted to a float, due to vegetables being float.\nThe result cannot be returned as long in the addCandy() method\nwithout a cast. For this reason, option F is correct. If parentheses were\nadded around fruit+vegetables, then the output would be 3, 5, 6,\nand option B would be correct. Remember that casting floating-point\nnumbers to integral values results in truncation, not rounding."
            },
            {
                "id": "82f28a76-0199-1000-0ffd-00000a67337b",
                "question": "7. What is the output of the following code snippet?",
                "answer_options": [
                    "A. true-true-true",
                    "B. true-true-false",
                    "C. true-false-true",
                    "D. true-false-false",
                    "E. false-true-true",
                    "F. false-true-false",
                    "G. false-false-true",
                    "H. false-false-false"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "7. D. In the first boolean expression, vis is 2 and ph is 7, so this\nexpression evaluates to true & (true || false), which reduces to\ntrue. The second boolean expression uses the conditional operator,\nand since (vis > 2) is false, the right side is not evaluated, leaving\nph at 7. In the last assignment, ph is 7, and the pre-decrement operator\nis applied first, reducing the expression to 7 <= 6 and resulting in an\nassignment of false. For these reasons, option D is the correct answer."
            },
            {
                "id": "82f28a76-0199-1000-5b32-000072d3bbb2",
                "question": "8. What is the output of the following code snippet?",
                "answer_options": [
                    "A. 4 - 1",
                    "B. 4 - 2",
                    "C. 5 - 1",
                    "D. 5 - 2",
                    "E. The code does not compile due to line 7.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "8. A. The code compiles and runs without issue, so option E is incorrect.\nLine 7 does not produce a compilation error since the compound\noperator applies casting automatically. Line 5 increments pig by 1, but\nit returns the original value of 4 since it is using the post-increment\noperator. The pig variable is then assigned this value, and the\nincrement operation is discarded. Line 7 just reduces the value of goat\nby 1, resulting in an output of 4 - 1 and making option A the correct\nanswer."
            },
            {
                "id": "82f28a76-0199-1000-c6bd-0000399d6608",
                "question": "9. What are the unique outputs of the following code snippet? (Choose all\nthat apply.)\n\nint a = 2, b = 4, c = 2;\nSystem.out.println(a> 2 ? --c : b++);\nSystem.out.println(b = (a!=c ? a : b++));\nSystem.out.println(a> b ? b < c ? b : 2 : 1);",
                "answer_options": [
                    "A. 1",
                    "B. 2",
                    "C. 3",
                    "D. 4",
                    "E. 5",
                    "F. 6",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    4
                ],
                "correct_answer_explanation": "9. A, D, E. The code compiles without issue, so option G is incorrect. In\nthe first expression, a > 2 is false, so b is incremented to 5; but since\nthe post-increment operator is used, 4 is printed, making option D\ncorrect. The --c was not applied, because only one of the right-hand\nexpressions was evaluated. In the second expression, a!=c is false\nsince c was never modified. Since b is 5 due to the previous line and\nthe post-increment operator is used, b++ returns 5. The result is then\nassigned to b using the assignment operator, overriding the\nincremented value for b and printing 5, making option E correct. In the\nlast expression, parentheses are not required, but lack of parentheses\ncan make ternary expressions difficult to read. From the previous lines,\na is 2, b is 5, and c is 2. We can rewrite this expression with\nparentheses as (2 > 5 ? (5 < 2 ? 5 : 2) : 1). The second ternary\nexpression is never evaluated since 2 > 5 is false, and the expression\nreturns 1, making option A correct."
            },
            {
                "id": "82f28a76-0199-1000-8518-000025830fa7",
                "question": "10. Which is not an output of the following code snippet?\n\nshort height = 1, weight = 3;\nshort zebra = (byte) weight * (byte) height;\ndouble ox = 1 + height * 2 + weight;\nlong giraffe = 1 + 9 % height + 1;\nSystem.out.println(zebra);\nSystem.out.println(ox);\nSystem.out.println(giraffe);",
                "answer_options": [
                    "A. 2",
                    "B. 3",
                    "C. 6",
                    "D. 6.0",
                    "E. The code does not compile."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "10. E. The code does not compile due to an error on the second line,\nmaking option E correct. Even though both height and weight are cast\nto byte, the multiplication operator automatically promotes them to\nint, resulting in an attempt to store an int in a short variable."
            },
            {
                "id": "82f28a76-0199-1000-f961-0000ad6cb9a3",
                "question": "11. What is the output of the following code?",
                "answer_options": [
                    "A. 0, 0, 5",
                    "B. 1, 2, 10",
                    "C. 2, 1, 5",
                    "D. 2, 0, 5",
                    "E. 3, 1, 10",
                    "F. 3, 2, 6",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "11. D. First, * and % have the same operator precedence, so the expression\nis evaluated from left to right unless parentheses are present. The first\nexpression evaluates to 8 % 3, which leaves a remainder of 2. The\nsecond expression is evaluated left to right since * and % have the same\noperator precedence, and it reduces to 6 % -3, which is 0. The last\nexpression reduces to 5 * 1, which is 5. Therefore, the output on line\n14 is 2, 0, 5, making option D the correct answer."
            },
            {
                "id": "82f28a76-0199-1000-29db-0000360544df",
                "question": "12. The _________ operator increases a value and returns the original\nvalue, while the _______ operator decreases a value and returns the\nnew value.",
                "answer_options": [
                    "A. post-increment, post-increment",
                    "B. pre-decrement, post-decrement",
                    "C. post-increment, post-decrement",
                    "D. post-increment, pre-decrement",
                    "E. pre-increment, pre-decrement",
                    "F. pre-increment, post-decrement"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "12. D. The pre- prefix indicates the operation is applied first, and the new\nvalue is returned, while the post- prefix indicates the original value is\nreturned prior to the operation. Next, increment increases the value,\nwhile decrement decreases the value. For these reasons, option D is the\ncorrect answer."
            },
            {
                "id": "82f28a76-0199-1000-a338-00005af1fd9f",
                "question": "13. What is the output of the following code snippet?\n\nboolean sunny = true, raining = false, sunday = true;\nboolean goingToTheStore = sunny & raining ^ sunday;\nboolean goingToTheZoo = sunday && !raining;\nboolean stayingHome = !(goingToTheStore && goingToTheZoo);\nSystem.out.println(goingToTheStore + \"-\" + goingToTheZoo\n+ \"-\" +stayingHome);",
                "answer_options": [
                    "A. true-false-false",
                    "B. false-true-false",
                    "C. true-true-true",
                    "D. false-true-true",
                    "E. false-false-false",
                    "F. true-true-false",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "13. F. The first expression is evaluated from left to right, letting us reduce\nit to false ^ sunday, which is true, because sunday is true. In the\nsecond expression, we apply the negation operator (!) first, reducing\nthe expression to sunday && true, which evaluates to true. In the last\nexpression, both variables are true, so they reduce to !(true &&\ntrue), which further reduces to !true, aka false. For these reasons,\noption F is the correct answer."
            },
            {
                "id": "82f28a76-0199-1000-306c-000071f3a074",
                "question": "14. Which of the following statements are correct? (Choose all that apply.)",
                "answer_options": [
                    "A. The return value of an assignment operation expression can be",
                    "B. The inequality operator (!=) can be used to compare objects.",
                    "C. The equality operator (==) can be used to compare a boolean",
                    "D. During runtime, the & and | operators may cause only the left side",
                    "E. The return value of an assignment operation expression is the",
                    "F. In Java, 0 and false may be used interchangeably.",
                    "G. The logical complement operator (!) cannot be used to flip"
                ],
                "correct_answer_indexes": [
                    1,
                    4,
                    6
                ],
                "correct_answer_explanation": "14. B, E, G. The return value of an assignment operation in the expression\nis the same as the value of the newly assigned variable. For this reason,\noption A is incorrect, and option E is correct. Option B is correct, as\nthe equality (==) and inequality (!=) operators can both be used with\nobjects. Option C is incorrect, as boolean and numeric types are not\ncomparable. For example, you can’t say true == 3 without a\ncompilation error. Option D is incorrect, as logical operators evaluate\nboth sides of the expression. Option F is incorrect, as Java does not\naccept numbers for boolean values. Finally, option G is correct, as you\nneed to use the negation operator (-) to flip or negate numeric values,\nnot the logical complement operator (!)."
            },
            {
                "id": "82f28a77-0199-1000-a281-0000947f7c3d",
                "question": "15. Which operator takes three operands or values?",
                "answer_options": [
                    "A. =",
                    "B. &&",
                    "C. *=",
                    "D. ? :",
                    "E. &",
                    "F. ++",
                    "G. /"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "15. D. The ternary operator is the only operator that takes three values,\nmaking option D the only correct choice. Options A, B, C, E, and G\nare all binary operators. While they can be strung together in longer\nexpressions, each operation uses only two values at a time. Option F is\na unary operator and takes only one value."
            },
            {
                "id": "82f28a77-0199-1000-5bd7-0000ce4c0a37",
                "question": "16. How many lines of the following code contain compiler errors?\n\nint note = 1 * 2 + (long)3;\nshort melody = (byte)(double)(note *= 2);\ndouble song = melody;\nfloat symphony = (float)((song == 1_000f) ? song * 2L :\nsong);",
                "answer_options": [
                    "A. 0",
                    "B. 1",
                    "C. 2",
                    "D. 3",
                    "E. 4"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "16. B. The first line contains a compilation error. The value 3 is cast to\nlong. The 1 * 2 value is evaluated as int but promoted to long when\nadded to the 3. Trying to store a long value in an int variable triggers\na compiler error. The other lines do not contain any compilation errors,\nas they store smaller values in larger or same-size data types, with\nlines 2 and 4 using casting to do so. Since only one line does not\ncompile, option B is correct."
            },
            {
                "id": "82f28a77-0199-1000-cf4e-0000b9d234a0",
                "question": "17. Given the following code snippet, what are the values of the variables\nafter it is executed? (Choose all that apply.)\n\nint ticketsTaken = 1;\nint ticketsSold = 3;\nticketsSold += 1 + ticketsTaken++;\nticketsTaken *= 2;\nticketsSold += (long)1;",
                "answer_options": [
                    "A. ticketsSold is 8.",
                    "B. ticketsTaken is 2.",
                    "C. ticketsSold is 6.",
                    "D. ticketsTaken is 6.",
                    "E. ticketsSold is 7.",
                    "F. ticketsTaken is 4.",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    2,
                    5
                ],
                "correct_answer_explanation": "17. C, F. The starting values of ticketsTaken and ticketsSold are 1 and\n3, respectively. After the first compound assignment, ticketsTaken is\nincremented to 2. The ticketsSold value is increased from 3 to 5;\nsince the post-increment operator was used, the value of\nticketsTaken++ returns 1. On the next line, ticketsTaken is doubled\nto 4. On the final line, ticketsSold is increased by 1 to 6. The final\nvalues of the variables are 4 and 6, for ticketsTaken and\nticketsSold, respectively, making options C and F the correct\nanswers. Note the last line does not trigger a compilation error as the\ncompound operator automatically casts the right-hand operand."
            },
            {
                "id": "82f28a77-0199-1000-e711-0000e880fe8e",
                "question": "18. Which of the following can be used to change the order of operation in\nan expression?",
                "answer_options": [
                    "A. [ ]",
                    "B. < >",
                    "C. ( )",
                    "D. \\ /",
                    "E. { }",
                    "F. \" \""
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "18. C. Only parentheses, ( ), can be used to change the order of operation\nin an expression, making option C correct. The other operators, such as\n[ ], < >, and { }, cannot be used to change the order of precedence in\nJava."
            },
            {
                "id": "82f28a77-0199-1000-1c89-0000b7478ee9",
                "question": "19. What is the result of executing the following code snippet? (Choose all\nthat apply.)\n\n3: int start = 7;\n4: int end = 4;\n5: end += ++start;\n6: start = (byte)(Byte.MAX_VALUE + 1);",
                "answer_options": [
                    "A. start is 0.",
                    "B. start is -128.",
                    "C. start is 127.",
                    "D. end is 8.",
                    "E. end is 11.",
                    "F. end is 12.",
                    "G. The code does not compile.",
                    "H. The code compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    1,
                    5
                ],
                "correct_answer_explanation": "19. B, F. The code compiles and runs successfully, so options G and H are\nincorrect. On line 5, the pre-increment operator is executed first, so\nstart is incremented to 8, and the new value is returned as the right\nside of the expression. The value of end is computed by adding 8 to the\noriginal value of 4, leaving a new value of 12 for end and making\noption F a correct answer. On line 6, we are incrementing one past the\nmaximum byte value. Due to overflow, this will result in a negative\nnumber, making option B the correct answer. Even if you didn’t know\nthe maximum value of byte, you should have known the code\ncompiles and runs and looked for the answer for start with a negative\nnumber."
            },
            {
                "id": "82f28a77-0199-1000-7768-00007dce6cf5",
                "question": "20. Which of the following statements about unary operators are true?\n(Choose all that apply.)",
                "answer_options": [
                    "A. Unary operators are always executed before any surrounding",
                    "B. The - operator can be used to flip a boolean value.",
                    "C. The pre-increment operator (++) returns the value of the variable",
                    "D. The post-decrement operator (--) returns the value of the variable",
                    "E. The ! operator cannot be used on numeric values.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    4
                ],
                "correct_answer_explanation": "20. A, D, E. Unary operators have the highest order of precedence, making\noption A correct. The negation operator (-) is used only for numeric\nvalues, while the logical complement operator (!) is used exclusively\nfor boolean values. For these reasons, option B is incorrect, and option\nE is correct. Finally, the pre-increment/pre-decrement operators return\nthe new value of the variable, while the post-increment/post-decrement\noperators return the original variable. For these reasons, option C is\nincorrect, and option D is correct."
            },
            {
                "id": "82f28a78-0199-1000-aaa6-00008fa964e6",
                "question": "1. What is the output of the following code snippet?\n\n32: Object skips = 10;\n33: switch (skips) {\n34: case a when a < 10 -> System.out.print(2);\n35: case b when b>= 10 -> System.out.print(4);\n36: case null -> System.out.print(6);\n37: default -> System.out.print(8);\n38: }",
                "answer_options": [
                    "A. 2",
                    "B. 4",
                    "C. 6",
                    "D. 8",
                    "E. Exactly one line does not compile.",
                    "F. Exactly two lines do not compile.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "1. F. Lines 34 and 35 do not compile because they are missing the pattern\nvariable type, making option F correct. If a supported type, such as\nInteger, were added between the case and variable on each line, then\nthe code would compile and print 4."
            },
            {
                "id": "82f28a78-0199-1000-a340-00008e47bf8e",
                "question": "2. Which of the following data types can be used in a switch expression?\n(Choose all that apply.)",
                "answer_options": [
                    "A. enum",
                    "B. int",
                    "C. Byte",
                    "D. long",
                    "E. boolean",
                    "F. double"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    2
                ],
                "correct_answer_explanation": "2. A, B, C. A switch expression supports enum values, making option A\ncorrect. It also supports int and byte primitives, including their\nwrapper classes Integer and Byte, making options B and C correct. It\ndoes not support the other types."
            },
            {
                "id": "82f28a78-0199-1000-25ac-000083472f9d",
                "question": "3. What is the output of the following code snippet?\n\n3: int temperature = 4;\n4: long humidity = -temperature + temperature * 3;\n5: if (temperature>=4)\n6: if (humidity < 6) System.out.println(\"Too Low\");\n7: else System.out.println(\"Just Right\");\n8: else System.out.println(\"Too High\");",
                "answer_options": [
                    "A. Too Low",
                    "B. Just Right",
                    "C. Too High",
                    "D. A NullPointerException is thrown at runtime.",
                    "E. The code will not compile because of line 7.",
                    "F. The code will not compile because of line 8."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "3. B. The code compiles and runs without issue, so options D, E, and F\nare incorrect. Even though two consecutive else statements on lines 7\nand 8 look a little odd, they are associated with separate if statements\non lines 5 and 6, respectively. The value of humidity on line 4 is equal\nto -4 + 12, which is 8. The first if statement evaluates to true on line\n5, so line 6 is executed and evaluates to false. This causes the else\nstatement on line 7 to run, printing Just Right and making option B\nthe correct answer."
            },
            {
                "id": "82f28a78-0199-1000-9f6b-000075f6b9e4",
                "question": "4. Which of the following data types are permitted on the right side of a\nfor-each expression? (Choose all that apply.)",
                "answer_options": [
                    "A. Double[][]",
                    "B. Object",
                    "C. Map",
                    "D. List",
                    "E. String",
                    "F. char[]",
                    "G. Exception"
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    5
                ],
                "correct_answer_explanation": "4. A, D, F. A for-each loop supports arrays, making options A and F\ncorrect. For Double[][], each element of the for-each loop would be a\nDouble[]. A for-each also supports classes that implement\njava.lang.Iterable. Although this includes many of the Collections\nFramework classes, not all of them implement java.lang.Iterable.\nFor this reason, option C is incorrect, and option D is correct. Options\nB, E, and G are incorrect, as they do not implement\njava.lang.Iterable. Although a String is a list of ordered\ncharacters, the class does not implement the required interface for a\nfor-each loop."
            },
            {
                "id": "82f28a78-0199-1000-0149-000097c518e8",
                "question": "5. What is the output of calling printReptile(6)?",
                "answer_options": [
                    "A. Snake",
                    "B. Lizard",
                    "C. Turtle",
                    "D. Alligator",
                    "E. TurtleAlligator",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "5. F. The code does not compile because the switch expression requires\nall possible case values to be handled, making option F correct. If a\nvalid default clause was added, then the code would compile and\nprint Turtle at runtime."
            },
            {
                "id": "82f28a78-0199-1000-99b0-0000022e49ea",
                "question": "6. What is the output of the following code snippet?\n\nList<Integer> myFavoriteNumbers = new ArrayList<>();\nmyFavoriteNumbers.add(10);\nmyFavoriteNumbers.add(14);\nfor (var a : myFavoriteNumbers) {\nSystem.out.print(a + \", \");\nbreak;\n}\nfor (int b : myFavoriteNumbers) {\ncontinue;\nSystem.out.print(b + \", \");\n}\nfor (Object c : myFavoriteNumbers)\nSystem.out.print(c + \", \");",
                "answer_options": [
                    "A. It compiles and runs without issue but does not produce any",
                    "B. 10, 14,",
                    "C. 10, 10, 14,",
                    "D. 10, 10, 14, 10, 14,",
                    "E. Exactly one line of code does not compile.",
                    "F. Exactly two lines of code do not compile.",
                    "G. Three or more lines of code do not compile.",
                    "H. The code contains an infinite loop and does not terminate."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "6. E. The second for-each loop contains a continue followed by a\nprint() statement. Because the continue is not conditional and\nalways included as part of the body of the for-each loop, the print()\nstatement is not reachable. For this reason, the print() statement does\nnot compile. As this is the only compilation error, option E is correct.\nThe other lines of code compile without issue."
            },
            {
                "id": "82f28a78-0199-1000-ec93-000003fc9d74",
                "question": "7. Assuming weather is a well-formed nonempty array, which code\nsnippet, when inserted independently into the blank in the following\ncode, prints all of the elements of weather? (Choose all that apply.)",
                "answer_options": [
                    "A. int i=weather.length; i>0; i--",
                    "B. int i=0; i<=weather.length-1; ++i",
                    "C. var w : weather",
                    "D. int i=weather.length-1; i>=0; i--",
                    "E. int i=0, int j=3; i<weather.length; ++i",
                    "F. int i=0; ++i<10 && i<weather.length;",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "7. B, D. Option A is incorrect because on the first iteration, it attempts to\naccess weather[weather.length] of the nonempty array, which\ncauses an ArrayIndexOutOfBoundsException to be thrown. Option B\nis correct and will print the elements in order. Option C doesn’t\ncompile as i is undefined in weather[i]. For this to work, the body of\nthe for-each loop would have to be updated as well. Option D is also\ncorrect and is a common way to print the elements of an array in\nreverse order. Option E does not compile and is therefore incorrect.\nYou can declare multiple elements in a for loop, but the data type\nmust be listed only once, such as in for (int i=0, j=3; …). Finally,\noption F is incorrect because the first element of the array is skipped.\nSince the conditional expression is checked before the loop is executed\nthe first time, the first value of i used inside the body of the loop will\nbe 1."
            },
            {
                "id": "82f28a78-0199-1000-94be-00006fbfb36e",
                "question": "8. What is the output of calling printType(11)?",
                "answer_options": [
                    "A. int",
                    "B. small int",
                    "C. long",
                    "D. unknown",
                    "E. Nothing is printed.",
                    "F. The code contains one line that does not compile.",
                    "G. The code contains two lines that do not compile.",
                    "H. None of the above."
                ],
                "correct_answer_indexes": [
                    6
                ],
                "correct_answer_explanation": "8. G. The first two pattern matching statements compile without issue.\nThe variable bat is allowed to be used again, provided it is no longer\nin scope. Line 36 does not compile, though. Due to flow scoping, if o\nis not a Long, then bat is not in scope in the expression bat <= 20.\nLine 38 also does not compile as default cannot be used as part of an\nif/else statement. For these two reasons, option G is correct."
            },
            {
                "id": "82f28a78-0199-1000-67e7-0000697e6853",
                "question": "9. Which statements, when inserted independently into the following\nblank, will cause the code to print 2 at runtime? (Choose all that\napply.)\n\nint count = 0;\nBUNNY: for (int row = 1; row <=3; row++)\nRABBIT: for (int col = 0; col <3 ; col++) {\nif ((col + row) % 2 == 0)\n;\ncount++;\n}\nSystem.out.println(count);",
                "answer_options": [
                    "A. break BUNNY",
                    "B. break RABBIT",
                    "C. continue BUNNY",
                    "D. continue RABBIT",
                    "E. break",
                    "F. continue",
                    "G. None of the above, as the code contains a compiler error"
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    4
                ],
                "correct_answer_explanation": "9. B, C, E. The code contains a nested loop and a conditional expression\nthat is executed if the sum of col + row is an even number; otherwise,\ncount is incremented. Note that options E and F are equivalent to\noptions B and D, respectively, since unlabeled statements apply to the\nmost inner loop. Studying the loops, the first time the condition is true\nis in the second iteration of the inner loop, when row is 1 and col is 1.\nOption A is incorrect because this causes the loop to exit immediately\nwith count only being set to 1. Options B, C, and E follow the same\npathway. First, count is incremented to 1 on the first inner loop, and\nthen the inner loop is exited. On the next iteration of the outer loop,\nrow is 2 and col is 0, so execution exits the inner loop immediately. On\nthe third iteration of the outer loop, row is 3 and col is 0, so count is\nincremented to 2. In the next iteration of the inner loop, the sum is\neven, so we exit, and our program is complete, making options B, C,\nand E each correct. Options D and F are both incorrect, as they cause\nthe inner and outer loops to execute multiple times, with count having\na value of 5 when done. You don’t need to trace through all the\niterations; just stop when the value of count exceeds 2."
            },
            {
                "id": "82f28a78-0199-1000-b7c9-000039867984",
                "question": "10. Given the following method, how many lines contain compilation\nerrors?\n\n8: enum DayOfWeek {\n9: SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY,\nFRIDAY, SATURDAY;\n10: private DayOfWeek getWeekDay(int day, final int\nthursday) {\n11: int otherDay = day;\n12: int Sunday = 0;\n13: switch (otherDay) {\n14: default:\n15: case 1: continue;\n16: case thursday: return DayOfWeek.THURSDAY;\n17: case 2,10: break;\n18: case Sunday: return DayOfWeek.SUNDAY;\n19: case DayOfWeek.MONDAY: return\nDayOfWeek.MONDAY;\n20: }\n21: return DayOfWeek.FRIDAY;\n22: } }",
                "answer_options": [
                    "A. None, the code compiles and runs without issue.",
                    "B. 1.",
                    "C. 2.",
                    "D. 3.",
                    "E. 4.",
                    "F. 5.",
                    "G. 6.",
                    "H. The code compiles but may produce an error at runtime."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "10. E. This code contains numerous compilation errors, making options A\nand H incorrect. Line 15 does not compile, as continue cannot be used\ninside a switch statement like this. Line 16 is not a compile-time\nconstant since any int value can be passed as a parameter. Marking it\nfinal does not change this, so it doesn’t compile. Line 18 does not\ncompile because Sunday is not marked as final. Being effectively\nfinal is insufficient. Finally, line 19 does not compile because\nDayOfWeek.MONDAY is not an int value. While switch statements do\nsupport enum values, each case clause must have the same data type\nas the switch variable otherDay, which is int. The rest of the lines do\ncompile. Since exactly four lines do not compile, option E is the\ncorrect answer."
            },
            {
                "id": "82f28a79-0199-1000-b6e9-0000b63dc9e9",
                "question": "11. What is the output of calling printLocation(Animal.MAMMAL)?\n\n10: class Zoo {\n11: enum Animal {BIRD, FISH, MAMMAL}\n12: void printLocation(Animal a) {\n13: long type = switch (a) {\n14: case BIRD -> 1;\n15: case FISH -> 2;\n16: case MAMMAL -> 3;\n17: default -> 4;\n18: };\n19: System.out.print(type);\n20: } }",
                "answer_options": [
                    "A. 3",
                    "B. 4",
                    "C. 34",
                    "D. The code does not compile because of line 13.",
                    "E. The code does not compile because of line 17.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "11. A. The code compiles and runs without issue, printing 3 at runtime and\nmaking option A correct. The default clause on line 17 is optional\nsince all the enum values are accounted for and can be removed\nwithout changing the output."
            },
            {
                "id": "82f28a79-0199-1000-9401-0000c1513c37",
                "question": "12. What is the result of the following code snippet?\n\n3: int sing = 8, squawk = 2, notes = 0;\n4: while (sing> squawk) {\n5: sing--;\n6: squawk += 2;\n7: notes += sing + squawk;\n8: }\n9: System.out.println(notes);",
                "answer_options": [
                    "A. 11",
                    "B. 13",
                    "C. 23",
                    "D. 33",
                    "E. 50",
                    "F. The code will not compile because of line 7."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "12. C. Prior to the first iteration, sing = 8, squawk = 2, and notes = 0.\nAfter the iteration of the first loop, sing is updated to 7, squawk to 4,\nand notes to the sum of the new values for sing + squawk, 7 + 4 =\n11. After the iteration of the second loop, sing is updated to 6, squawk\nto 6, and notes to the sum of itself plus the new values for sing +\nsquawk, 11 + 6 + 6 = 23. On the third iteration of the loop, sing >\nsquawk evaluates to false, as 6 > 6 is false. The loop ends and the\nmost recent value of sing, 23, is output, so the correct answer is option\nC."
            },
            {
                "id": "82f28a79-0199-1000-9492-00005bb9a41f",
                "question": "13. What is the result of calling getHatSize(9f) on the following code\nsnippet?\n\n10: int getHatSize(Number measurement) {\n11: return switch (measurement) {\n12: case Double d -> 1 + d.intValue();\n13: case null -> 11;\n14: case !(Number n) -> 3 + n.intValue();\n15: case Float f when f < 10 -> 4 + f.intValue();\n16: };\n17: }",
                "answer_options": [
                    "A. 10",
                    "B. 11",
                    "C. 12",
                    "D. 13",
                    "E. The code does not compile because it is missing a default",
                    "F. The code does not compile for a different reason."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "13. F. The code does not compile because case clause uses the logical\ncomplement operator (!), which is not permitted with pattern\nmatching. If this was removed, then the code would still not compile,\nas this clause would dominate the case on line 15, leading to\nunreachable code on line 15. For this reason, option F is correct."
            },
            {
                "id": "82f28a79-0199-1000-1c8d-000061c51369",
                "question": "14. What is the output of the following code snippet?\n\n2: boolean keepGoing = true;\n3: int result = 15, meters = 10;\n4: do {\n5: meters--;\n6: if (meters==8) keepGoing = false;\n7: result -= 2;\n8: } while keepGoing;\n9: System.out.println(result);",
                "answer_options": [
                    "A. 7",
                    "B. 9",
                    "C. 10",
                    "D. 11",
                    "E. 15",
                    "F. The code will not compile because of line 6.",
                    "G. The code does not compile for a different reason."
                ],
                "correct_answer_indexes": [
                    6
                ],
                "correct_answer_explanation": "14. G. This example may look complicated, but the code does not compile.\nLine 8 is missing the required parentheses around the boolean\nconditional expression. Since the code does not compile and it is not\nbecause of line 6, option G is the correct answer. If line 8 was\ncorrected with parentheses, then the loop would be executed twice, and\nthe output would be 11."
            },
            {
                "id": "82f28a79-0199-1000-28c5-00008d968684",
                "question": "15. Which statements about the following code snippet are correct?\n(Choose all that apply.)\n\nfor (var penguin : new int[2])\nSystem.out.println(penguin);\nvar ostrich = new Character[3];\nfor (var emu : ostrich)\nSystem.out.println(emu);\nList<Integer> parrots = new ArrayList<Integer>();\nfor (var macaw : parrots)\nSystem.out.println(macaw);",
                "answer_options": [
                    "A. The data type of penguin is Integer.",
                    "B. The data type of penguin is int.",
                    "C. The data type of emu is undefined.",
                    "D. The data type of emu is Character.",
                    "E. The data type of macaw is List.",
                    "F. The data type of macaw is Integer.",
                    "G. None of the above, as the code does not compile."
                ],
                "correct_answer_indexes": [
                    1,
                    3,
                    5
                ],
                "correct_answer_explanation": "15. B, D, F. The code does compile, making option G incorrect. In the first\nfor-each loop, the right side of the for-each loop has a type of int[],\nso each element penguin has a type of int, making option B correct.\nIn the second for-each loop, ostrich has a type of Character[], so\nemu has a data type of Character, making option D correct. In the last\nfor-each loop, parrots has a data type of List<Integer>. Since the\ngeneric type of Integer is used in the List, macaw will have a data\ntype of Integer, making option F correct."
            },
            {
                "id": "82f28a79-0199-1000-f631-0000ddb49140",
                "question": "16. What is the result of the following code snippet?",
                "answer_options": [
                    "A. great",
                    "B. great good",
                    "C. good",
                    "D. not good",
                    "E. The code does not compile because the data type of one or more",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "16. F. The code does not compile, although not for the reason specified in\noption E. The second case clause contains invalid syntax. Each case\nclause must have the keyword case—in other words, you cannot chain\nthem with a colon (:). For this reason, option F is the correct answer.\nThis line could have been fixed to say case ’B’, ’C’ or by adding the\ncase keyword before ’C’; then the rest of the code would have\ncompiled and printed great good at runtime."
            },
            {
                "id": "82f28a79-0199-1000-4ece-00006d669218",
                "question": "17. Given the following array, which code snippets print the elements in\nreverse order from how they are declared? (Choose all that apply.)",
                "answer_options": [
                    "A. int q = wolf.length;",
                    "B. for (int m=wolf.length-1; m>=0; --m)",
                    "C. for (int z=0; z<wolf.length; z++)",
                    "D. int x = wolf.length-1;",
                    "E. final int r = wolf.length;",
                    "F. for (int i=wolf.length; i>0; --i)",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    3
                ],
                "correct_answer_explanation": "17. A, B, D. To print items in the wolf array in reverse order, the code\nneeds to start with wolf[wolf.length-1] and end with wolf[0].\nOption A accomplishes this and is the first correct answer. Option B is\nalso correct and is one of the most common ways a reverse loop is\nwritten. The termination condition is often m>=0 or m>-1, and both are\ncorrect. Options C and F each cause an\nArrayIndexOutOfBoundsException at runtime since both read from\nwolf[wolf.length] first, with an index that is passed the length of the\n0-based array wolf. The form of option C would be successful if the\nvalue was changed to wolf[wolf.length-z-1]. Option D is also\ncorrect, as the j is extraneous and can be ignored in this example.\nFinally, option E is incorrect and produces an infinite loop, as w is\nrepeatedly set to r-1, in this case 4, on every loop iteration. Since the\nupdate statement has no effect after the first iteration, the condition is\nnever met, and the loop never terminates."
            },
            {
                "id": "82f28a79-0199-1000-a812-000026388f00",
                "question": "18. What distinct numbers are printed when the following method is\nexecuted? (Choose all that apply.)\n\nprivate void countAttendees() {\nint participants = 4, animals = 2, performers = -1;\nwhile ((participants = participants + 1) < 10) {}\ndo {} while (animals++ <= 1);\nfor ( ; performers < 2; performers += 2) {}\nSystem.out.println(participants);\nSystem.out.println(animals);\nSystem.out.println(performers);\n}",
                "answer_options": [
                    "A. 6",
                    "B. 3",
                    "C. 4",
                    "D. 5",
                    "E. 10",
                    "F. 9",
                    "G. The code does not compile.",
                    "H. None of the above."
                ],
                "correct_answer_indexes": [
                    1,
                    4
                ],
                "correct_answer_explanation": "18. B, E. The code compiles without issue and prints two distinct numbers\nat runtime, so options G and H are incorrect. The first loop executes a\ntotal of five times, with the loop ending when participants has a\nvalue of 10. For this reason, option E is correct. In the second loop,\nanimals starts out not less than or equal to 1, but since it is a do/while\nloop, it executes at least once. In this manner, animals takes on a value\nof 3 and the loop terminates, making option B correct. Finally, the last\nloop executes a total of two times, with performers starting with -1,\ngoing to 1 at the end of the first loop, and then ending with a value of 3\nafter the second loop, which breaks the loop. This makes option B a\ncorrect answer twice over."
            },
            {
                "id": "82f28a79-0199-1000-389a-00005e048570",
                "question": "19. What is the output of the following code snippet?\n\n2: double iguana = 0;\n3: do {\n4: int snake = 1;\n5: System.out.print(snake++ + \" \");\n6: iguana--;\n7: } while (snake <= 5);\n8: System.out.println(iguana);",
                "answer_options": [
                    "A. 1 2 3 4 -4.0",
                    "B. 1 2 3 4 -5.0",
                    "C. 1 2 3 4 5 -4.0",
                    "D. 0 1 2 3 4 5 -5.0",
                    "E. The code does not compile.",
                    "F. The code compiles but produces an infinite loop at runtime.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "19. E. The variable snake is declared within the body of the do/while\nstatement, so it is out of scope on line 7. For this reason, option E is\nthe correct answer. If snake were declared before line 3 with a value of\n1, then the output would have been 1 2 3 4 5 -5.0, and option G\nwould have been the correct answer."
            },
            {
                "id": "82f28a79-0199-1000-a2f9-00008e7083f9",
                "question": "20. Which statements, when inserted into the following blanks, allow the\ncode to compile and run without entering an infinite loop? (Choose all\nthat apply.)\n\n4: int height = 1;\n5: L1: while (height++ <10) {\n6:   long humidity = 12;\n7:   L2: do {\n8:     if (humidity-- % 12 == 0) ;\n9:     int temperature = 30;\n10:     L3: for ( ; ; ) {\n11:       temperature++;\n12:       if (temperature>50) ;\n13:     }\n14:   } while (humidity> 4);\n15: }",
                "answer_options": [
                    "A. break L2 on line 8; continue L2 on line 12",
                    "B. continue on line 8; continue on line 12",
                    "C. break L3 on line 8; break L1 on line 12",
                    "D. continue L2 on line 8; continue L3 on line 12",
                    "E. continue L2 on line 8; continue L2 on line 12",
                    "F. None of the above, as the code contains a compiler error"
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "20. A, E. The most important thing to notice when reading this code is that\nthe innermost loop is an infinite loop. Therefore, you are looking for\nsolutions that skip the innermost loop entirely or that exit that loop.\nOption A is correct, as break L2 on line 8 causes the second inner\nloop to exit every time it is entered, skipping the innermost loop\nentirely. For option B, the first continue on line 8 causes the execution\nto skip the innermost loop on the first iteration of the second loop but\nnot the second iteration of the second loop. The innermost loop is\nexecuted, and with continue on line 12, it produces an infinite loop at\nruntime, making option B incorrect. Option C is incorrect because it\ncontains a compiler error. The label L3 is not visible outside its loop.\nOption D is incorrect, as it is equivalent to option B since the\nunlabeled break and continue apply to the nearest loop and therefore\nproduce an infinite loop at runtime. Like option A, the continue L2 on\nline 8 allows the innermost loop to be executed the second time the\nsecond loop is called. The continue L2 on line 12 exits the infinite\nloop, though, causing control to return to the second loop. Since the\nfirst and second loops terminate, the code terminates, and option E is a\ncorrect answer."
            },
            {
                "id": "82f28a79-0199-1000-cd2a-0000afa4ec6a",
                "question": "21. A minimum of how many lines need to be corrected before the\nfollowing method will compile?\n\n21: void findZookeeper(Integer id) {\n22: System.out.print(switch (id) {\n23: case 10 -> {\"Jane\";}\n24: case 20 -> {yield \"Lisa\";};\n25: case 30 -> \"Kelly\";\n26: case 30 -> \"Sarah\";\n27: default -> \"Unassigned\";\n28: });\n29: }",
                "answer_options": [
                    "A. Zero",
                    "B. One",
                    "C. Two",
                    "D. Three",
                    "E. Four",
                    "F. Five"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "21. D. Line 23 does not compile because it is missing a yield statement.\nLine 24 does not compile because it contains an extra semicolon at the\nend. Finally, lines 25 and 26 do not compile because they use the same\ncase value. At least one of them would need to be changed for the\ncode to compile. Since three lines need to be corrected, option D is\ncorrect."
            },
            {
                "id": "82f28a79-0199-1000-3542-000032c0c1f4",
                "question": "22. What is the output of the following code snippet?\n\n2: var tailFeathers = 3;\n3: final var one = 1;\n4: switch (tailFeathers) {\n5: case one: System.out.print(3 + \" \");\n6: default: case 3: System.out.print(5 + \" \");\n7: }\n8: while (tailFeathers> 1) {\n9: System.out.print(--tailFeathers + \" \"); }",
                "answer_options": [
                    "A. 3",
                    "B. 5 1",
                    "C. 5 2",
                    "D. 3 5 1",
                    "E. 5 2 1",
                    "F. The code will not compile because of lines 3–5.",
                    "G. The code will not compile because of line 6."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "22. E. The code compiles without issue, making options F and G incorrect.\nRemember, var is supported in both switch and while loops, provided\nthe compiler determines that the type is compatible with these\nstatements. In addition, the variable one is allowed in a case clause\nbecause it is a final local variable, making it a compile-time constant.\nThe value of tailFeathers is 3, which matches the second case\nclause, making 5 the first output. The while loop is executed twice,\nwith the pre-decrement operator (--) modifying the value of\ntailFeathers from 3 to 2 and then to 1 on the second loop. For this\nreason, the final output is 5 2 1, making option E the correct answer."
            },
            {
                "id": "82f28a79-0199-1000-3661-0000edc96195",
                "question": "23. What is the output of the following code snippet?\n\n15: int penguin = 50, turtle = 75;\n16: boolean older = penguin>= turtle;\n17: if (older = true) System.out.println(\"Success\");\n18: else System.out.println(\"Failure\");\n19: else if (penguin != 50) System.out.println(\"Other\");",
                "answer_options": [
                    "A. Success",
                    "B. Failure",
                    "C. Other",
                    "D. The code will not compile because of line 17.",
                    "E. The code compiles but throws an exception at runtime.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "23. F. Line 19 starts with an else statement, but there is no preceding if\nstatement that it matches. For this reason, line 19 does not compile,\nmaking option F the correct answer. If the else keyword was removed\nfrom line 19, then the code snippet would print Success."
            },
            {
                "id": "82f28a7a-0199-1000-c1fa-0000ce647dea",
                "question": "24. What is the output of the following code snippet?\n\n22: String zooStatus = \"Closed\";\n23: int visitors = switch (zooStatus) {\n24: case String s when s.equals(\"Open\") -> 10;\n25: case Object s when s != null && !s.equals(\"\") -> 20;\n26: case null -> {yield 30;}\n27: default -> 40;\n28: };\n29: System.out.print(visitors);",
                "answer_options": [
                    "A. 10",
                    "B. 20",
                    "C. 30",
                    "D. 40",
                    "E. Exactly one line does not compile.",
                    "F. Exactly two lines do not compile.",
                    "G. Three or more lines do not compile."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "24. B. Since this is a pattern matching switch statement, the case\nbranches are evaluated in the order in which they appear. In particular,\neach branch does not dominate the ones after it, so the code compiles\nwithout issue. If either of the when clauses were removed from their\naccompanying case clause, then the code would not compile. The first\nbranch is skipped because Closed does not match Open. The second\none matches, resulting in 20 being printed at runtime and making\noption B correct."
            },
            {
                "id": "82f28a7a-0199-1000-e5b8-000083a76ef3",
                "question": "25. What is the output of the following code snippet?\n\n6: String instrument = \"violin\";\n7: final String CELLO = \"cello\";\n8: String viola = \"viola\";\n9: int p = -1;\n10: switch (instrument) {\n11: case \"bass\" : break;\n12: case CELLO : p++;\n13: default: p++;\n14: case \"VIOLIN\": p++;\n15: case \"viola\" : ++p; break;\n16: }\n17: System.out.print(p);",
                "answer_options": [
                    "A. -1",
                    "B. 0",
                    "C. 1",
                    "D. 2",
                    "E. 3",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "25. D. The code compiles without issue, so option F is incorrect. The\nviola variable created on line 8 is never used and can be ignored. If it\nhad been used as the case value on line 15, it would have caused a\ncompilation error since it is not marked final. Since \"violin\" and\n\"VIOLIN\" are not an exact match, the default branch of the switch\nstatement is executed at runtime. This execution path increments p a\ntotal of three times, bringing the final value of p to 2 and making\noption D the correct answer."
            },
            {
                "id": "82f28a7a-0199-1000-e138-0000d23e9244",
                "question": "26. What is the output of the following code snippet?\n\n9: int w = 0, r = 1;\n10: String name = \"\";\n11: while (w < 2) {\n12: name += \"A\";\n13: do {\n14: name += \"B\";\n15: if (name.length()>0) name += \"C\";\n16: else break;\n17: } while (r <=1);\n18: r++; w++; }\n19: System.out.println(name);",
                "answer_options": [
                    "A. ABC",
                    "B. ABCABC",
                    "C. ABCABCABC",
                    "D. Line 15 contains a compilation error.",
                    "E. Line 18 contains a compilation error.",
                    "F. The code compiles but never terminates at runtime.",
                    "G. The code compiles but throws a NullPointerException at"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "26. F. The code snippet does not contain any compilation errors, so options\nD and E are incorrect. There is a problem with this code snippet,\nthough. While it may seem complicated, the key is to notice that the\nvariable r is updated outside of the do/while loop. This is allowed\nfrom a compilation standpoint, since it is defined before the loop, but it\nmeans the innermost loop never breaks the termination condition r <=\n1. At runtime, this will produce an infinite loop the first time the\ninnermost loop is entered, making option F the correct answer."
            },
            {
                "id": "82f28a7a-0199-1000-33b5-0000afdc5764",
                "question": "27. What is printed by the following code snippet?\n\n23: byte amphibian = 2;\n24: String name = \"Salamander\";\n25: String color = switch (amphibian) {\n26: case 1 -> { yield \"Red\"; }\n27: case 2 -> { if (name.equals(\"Frog\")) yield \"Green\";\n28: yield \"Blue\"; }\n29: case 3 -> { yield \"Purple\"; }\n30: default -> throw new RuntimeException();\n31: };\n32: System.out.print(color);",
                "answer_options": [
                    "A. Red",
                    "B. Green",
                    "C. Purple",
                    "D. Blue",
                    "E. The code does not compile.",
                    "F. An exception is thrown at runtime."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "27. D. The code compiles and runs without issue, as every case block\ncontains a yield statement. The second case block contains two paths\nwhich both end in a yield statement. At runtime, the code prints Blue,\nmaking option D correct."
            },
            {
                "id": "82f28a7a-0199-1000-af9a-00007750ef51",
                "question": "28. What is the output of calling getFish(\"goldie\")?\n\n40: void getFish(Object fish) {\n41: if (!(fish instanceof String guppy))\n42: System.out.print(\"Eat!\");\n43: else if (!(fish instanceof String guppy)) {\n44: throw new RuntimeException();\n45: }\n46: System.out.print(\"Swim!\");\n47: }",
                "answer_options": [
                    "A. Eat!",
                    "B. Swim!",
                    "C. Eat! followed by an exception",
                    "D. Eat!Swim!",
                    "E. An exception is printed",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "28. F. Based on flow scoping, guppy is in scope after lines 41–42 if the\ntype is not a String. In this case, line 43 declares a variable guppy that\nis a duplicate of the previously defined local variable defined on line\n41. For this reason, the code does not compile, and option F is correct.\nIf a different variable name was used on line 43, then the code would\ncompile and print Swim! at runtime with the specified input."
            },
            {
                "id": "82f28a7a-0199-1000-3f74-000026d42ab2",
                "question": "29. What is the result of the following code?\n\n1: public class PrintIntegers {\n2: public static void main(String[] args) {\n3: int y = -2;\n4: do System.out.print(++y + \" \");\n5: while (y <= 5);\n6: } }",
                "answer_options": [
                    "A. -2 -1 0 1 2 3 4 5",
                    "B. -2 -1 0 1 2 3 4",
                    "C. -1 0 1 2 3 4 5 6",
                    "D. -1 0 1 2 3 4 5",
                    "E. The code will not compile because of line 5.",
                    "F. The code contains an infinite loop and does not terminate."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "29. C. Since the pre-increment operator was used, the first value that will\nbe displayed is -1, so options A and B are incorrect. On the second-to-\nlast iteration of the loop, y will be incremented to 5, and the loop will\noutput 5. The loop will continue since 5 <= 5 is true, and on the last\niteration, 6 will be output. At the end of this last iteration, the boolean\nexpression 6 <= 5 will evaluate to false, and the loop will terminate.\nSince 6 was the last value output by the loop, the answer is option C."
            },
            {
                "id": "82f28a7a-0199-1000-0214-00002d062e46",
                "question": "30. What is the minimum number of lines that would need to be changed\nor removed for the following code to compile and return a value when\ncalled with dance(10)?\n\n41: double dance(Object speed) {\n42: return switch (speed) {\n43: case 5 -> {yield 4};\n44: case 10 -> 8;\n45: case 15,20 -> 12;\n46: default -> 20;\n47: case null -> 16;\n48: }\n49: }",
                "answer_options": [
                    "A. Zero, the code compiles and runs without issue",
                    "B. One",
                    "C. Two",
                    "D. Three",
                    "E. Four",
                    "F. Five",
                    "G. Six"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "30. E. On line 43, the semicolon should be after the yield statement, not\noutside the brace. Line 48 is missing a semicolon after the return\nstatement containing the switch expression. For these reasons, at least\ntwo lines must be corrected. Next, lines 43, 44, and 45 do not compile\nbecause the numeric values are not compatible with the reference type\nfor Object. We can fix this by changing line 41 to pass speed as a\ncompatible type, such as Integer. Finally, the default clause on line\n46 dominates the proceeding case null on line 47. Removing line 47\nfixes this issue, as case null is not required. Since we can get the\ncode to compile by changing or removing four lines, option E is the\ncorrect answer."
            },
            {
                "id": "82f28a7a-0199-1000-9fa4-0000f21dcb39",
                "question": "1. What is output by the following code?\n\n1: public class Fish {\n2: public static void main(String[] args) {\n3: int numFish = 4;\n4: String fishType = \"tuna\";\n5: String anotherFish = numFish + 1;\n6: System.out.println(anotherFish + \" \" + fishType);\n7: System.out.println(numFish + \" \" + 1);\n8: } }",
                "answer_options": [
                    "A. 4 1",
                    "B. 5",
                    "C. 5 tuna",
                    "D. 5tuna",
                    "E. 51tuna",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "1. F. Line 5 does not compile. This question is checking to see whether\nyou are paying attention to the types. numFish is an int, and 1 is an\nint. Therefore, we use numeric addition and get 5. The problem is that\nwe can’t store an int in a String variable. Suppose line 5 said String\nanotherFish = numFish + 1 + \"\";. In that case, the answers would\nbe option A and option C. The variable defined on line 5 would be the\nstring \"5\", and both output statements would use concatenation."
            },
            {
                "id": "82f28a7a-0199-1000-086b-0000be06f984",
                "question": "2. Which of these array declarations are not legal? (Choose all that\napply.)",
                "answer_options": [
                    "A. int[][] scores = new int[5][];",
                    "B. Object[][][] cubbies = new Object[3][0][5];",
                    "C. String beans[] = new beans[6];",
                    "D. java.util.Date[] dates[] = new java.util.Date[2][];",
                    "E. int[][] types = new int[];",
                    "F. int[][] java = new int[][];"
                ],
                "correct_answer_indexes": [
                    2,
                    4,
                    5
                ],
                "correct_answer_explanation": "2. C, E, F. Option C uses the variable name as if it were a type, which is\nclearly illegal. Options E and F don’t specify any size. Although it is\nlegal to leave out the size for later dimensions of an array of arrays, the\nfirst one is required. Option A declares a legal 2D array. Option B\ndeclares a legal 3D array. Option D declares a legal 2D array.\nRemember that it is normal to see classes on the exam you might not\nhave learned. You aren’t expected to know anything about them."
            },
            {
                "id": "82f28a7a-0199-1000-431d-000061323fa1",
                "question": "3. Note that March 12, 2028, is the weekend when we spring forward,\nand November 5, 2028, is when we fall back for daylight saving time.\nWhich of the following can fill in the blank without the code throwing\nan exception? (Choose all that apply.)\n\nvar zone = ZoneId.of(\"US/Eastern\");\nvar date = ______________________;\nvar time = LocalTime.of(2, 15);\nvar z = ZonedDateTime.of(date, time, zone);",
                "answer_options": [
                    "A. LocalDate.of(2028, 3, 12)",
                    "B. LocalDate.of(2028, 3, 40)",
                    "C. LocalDate.of(2028, 11, 5)",
                    "D. LocalDate.of(2028, 11, 6)",
                    "E. LocalDate.of(2029, 2, 29)",
                    "F. LocalDate.of(2028, MonthEnum.MARCH, 12);"
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    3
                ],
                "correct_answer_explanation": "3. A, C, D. Option B throws an exception because there is no March 40.\nOption E also throws an exception because 2029 isn’t a leap year and\ntherefore has no February 29. Option F doesn’t compile because the\nenum should be named Month, rather than MonthEnum. Option D is\ncorrect because it is just a regular date and has nothing to do with\ndaylight saving time. Options A and C are correct because Java is\nsmart enough to adjust for daylight saving time."
            },
            {
                "id": "82f28a7a-0199-1000-6b75-00005822b968",
                "question": "4. Which of the following are output by this code? (Choose all that\napply.)\n\n3: var s = \"Hello\";\n4: var t = new String(s);\n5: if (\"Hello\".equals(s)) System.out.println(\"one\");\n6: if (t == s) System.out.println(\"two\");\n7: if (t.intern() == s) System.out.println(\"three\");\n8: if (\"Hello\" == s) System.out.println(\"four\");\n9: if (\"Hello\".intern() == t) System.out.println(\"five\");",
                "answer_options": [
                    "A. one",
                    "B. two",
                    "C. three",
                    "D. four",
                    "E. five",
                    "F. The code does not compile.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    3
                ],
                "correct_answer_explanation": "4. A, C, D. The code compiles fine. Line 3 points to the String in the\nstring pool. Line 4 calls the String constructor explicitly and is\ntherefore a different object than s. Line 5 checks for object equality,\nwhich is true, and so it prints one. Line 6 uses object reference\nequality, which is not true since we have different objects. Line 7 calls\nintern(), which returns the value from the string pool and is therefore\nthe same reference as s. Line 8 also compares references but is true\nsince both references point to the object from the string pool. Finally,\nline 9 is a trick. The string Hello is already in the string pool, so\ncalling intern() does not change anything. The reference t is a\ndifferent object, so the result is still false. Therefore, options A, C,\nand D are correct."
            },
            {
                "id": "82f28a7a-0199-1000-dbb6-000069510e3b",
                "question": "5. What is the result of the following code?",
                "answer_options": [
                    "A. abbaaccc",
                    "B. abbaccca",
                    "C. bbaaaccc",
                    "D. bbaaccca",
                    "E. An empty line.",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "5. B. This example uses method chaining. After the call to append(), sb\ncontains \"aaa\". That result is passed to the first insert() call, which\ninserts at index 1. At this point, sb contains abbaa. That result is\npassed to the final insert(), which inserts at index 4, resulting in\nabbaccca. Therefore, option B is the answer"
            },
            {
                "id": "82f28a7a-0199-1000-2846-00002aab035c",
                "question": "6. How many of these lines contain a compiler error?",
                "answer_options": [
                    "A. 0",
                    "B. 1",
                    "C. 2",
                    "D. 3",
                    "E. 4"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "6. C. Remember to watch return types on math operations. One of the\ntricks is line 24. The round() method returns an int when called with\na float. However, we are calling it with a double, so it returns a long.\nThe other trick is line 25. The random() method returns a double.\nSince two lines have a compiler error, option C is the answer."
            },
            {
                "id": "82f28a7b-0199-1000-a959-0000cc35e9fc",
                "question": "7. Which of these statements is true of the two values? (Choose all that\napply.)\n2025–08–28T05:00 GMT-04:00\n2025–08–28T09:00 GMT-06:00",
                "answer_options": [
                    "A. The first date/time is earlier.",
                    "B. The second date/time is earlier.",
                    "C. Both date/times are the same.",
                    "D. The date/times are two hours apart.",
                    "E. The date/times are six hours apart.",
                    "F. The date/times are 10 hours apart."
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "7. A, E. When dealing with time zones, it is best to convert to GMT first\nby subtracting the time zone. Remember that subtracting a negative is\nlike adding. The first date/time is 9:00 GMT, and the second is 15:00\nGMT. Therefore, the first one is earlier by six hours. Therefore,\noptions A and E are correct."
            },
            {
                "id": "82f28a7b-0199-1000-5348-00002a1bcff9",
                "question": "8. Which of the following return 5 when run independently? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. builder.charAt(4)",
                    "B. builder.replace(2, 4, \"6\").charAt(3)",
                    "C. builder.replace(2, 5, \"6\").charAt(2)",
                    "D. string.charAt(5)",
                    "E. string.length",
                    "F. string.replace(\"123\", \"1\").charAt(2)",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    5
                ],
                "correct_answer_explanation": "8. A, B, F. Remember that indexes are zero-based, which means index 4\ncorresponds to 5, and option A is correct. For option B, the replace()\nmethod starts the replacement at index 2 and ends before index 4. This\nmeans two characters are replaced, and charAt(3) is called on the\nintermediate value of 1265. The character at index 3 is 5, making\noption B correct. Option C is similar, making the intermediate value\n126 and returning 6.\nOption D results in an exception since there is no character at index 5.\nOption E is incorrect. It does not compile because the parentheses for\nthe length() method are missing. Finally, option F’s replace results\nin the intermediate value 145. The character at index 2 is 5, so option F\nis correct."
            },
            {
                "id": "82f28a7b-0199-1000-b30e-00004eeff3a4",
                "question": "9. Which of the following are true about arrays? (Choose all that apply.)",
                "answer_options": [
                    "A. The first element is index 0.",
                    "B. The first element is index 1.",
                    "C. Arrays are fixed size.",
                    "D. Arrays are immutable.",
                    "E. Calling equals() on two different arrays containing the same",
                    "F. Calling equals() on two different arrays containing the same",
                    "G. Calling equals() on two different arrays containing the same"
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    5
                ],
                "correct_answer_explanation": "9. A, C, F. Arrays are zero-indexed, making option A correct and option\nB incorrect. They are not able to change size, which is option C. The\nvalues can be changed, making option D incorrect. An array does not\noverride equals(), so it uses object equality. Since two different\nobjects are not equal, option F is correct, and options E and G are\nincorrect."
            },
            {
                "id": "82f28a7b-0199-1000-ed24-00005c04e99f",
                "question": "10. How many of these lines contain a compiler error?",
                "answer_options": [
                    "A. 0",
                    "B. 1",
                    "C. 2",
                    "D. 3",
                    "E. 4"
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "10. A. All of these lines compile. The min() and floor() methods return\nthe same type passed in: int and double, respectively. The round()\nmethod returns a long when called with a double. Option A is correct\nsince the code compiles."
            },
            {
                "id": "82f28a7b-0199-1000-24d8-000053b9a230",
                "question": "11. What is the output of the following code?\n\nvar date = LocalDate.of(2025, 4, 3);\ndate.plusDays(2);\ndate.plusHours(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth()\n+ \" \" + date.getDayOfMonth());",
                "answer_options": [
                    "A. 2025 MARCH 4",
                    "B. 2025 MARCH 6",
                    "C. 2025 APRIL 3",
                    "D. 2025 APRIL 5",
                    "E. The code does not compile.",
                    "F. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "11. E. A LocalDate does not have a time element. Therefore, there is no\nmethod to add hours, making option E the answer."
            },
            {
                "id": "82f28a7b-0199-1000-64cb-0000bf202cee",
                "question": "12. What is output by the following code ignoring any new lines in the\nouput? (Choose all that apply.)\n\nvar numbers = \"012345678\".indent(1);\nnumbers = numbers.stripLeading();\nSystem.out.println(numbers.substring(1, 3));\nSystem.out.println(numbers.substring(7, 7));\nSystem.out.println(numbers.substring(7));",
                "answer_options": [
                    "A. 12",
                    "B. 123",
                    "C. 7",
                    "D. 78",
                    "E. A blank line.",
                    "F. An exception is thrown."
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    4
                ],
                "correct_answer_explanation": "12. A, D, E. First, notice that the indent() call adds a blank space to the\nbeginning of numbers, and stripLeading() immediately removes it.\nThe substring() method has two forms. The first takes the index to\nstart with and the index to stop immediately before. The second takes\njust the index to start with and goes to the end of the String.\nRemember that indexes are zero-based. The first call starts at index 1\nand ends with index 2 since it needs to stop before index 3. This gives\nus option A. The second call starts at index 7 and ends in the same\nplace, resulting in an empty String, which is option E. This prints out\na blank line. The final call starts at index 7 and goes to the end of the\nString finishing up with option D."
            },
            {
                "id": "82f28a7b-0199-1000-0a6e-0000d6ea4994",
                "question": "13. What is the result of the following code?",
                "answer_options": [
                    "A. roar roar",
                    "B. roar roar!!!",
                    "C. roar!!! Roar",
                    "D. roar!!! Roar!!!",
                    "E. An exception is thrown.",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "13. B. A String is immutable. Calling concat() returns a new String but\ndoes not change the original. A StringBuilder is mutable. Calling\nappend() adds characters to the existing character sequence along with\nreturning a reference to the same object. Therefore, option B is correct."
            },
            {
                "id": "82f28a7b-0199-1000-86e2-0000bce41969",
                "question": "14. Given the following, which can correctly fill in the blank allowing the\ncode to compile? (Choose all that apply.)\n\nvar date = LocalDate.now();\nvar time = LocalTime.now();\nvar dateTime = date.______(time);\nvar zoneId = ZoneId.systemDefault();\nvar zonedDateTime = ZonedDateTime.of(dateTime, zoneId);\nInstant instant = ___________________________;",
                "answer_options": [
                    "A. asTime()",
                    "B. atTime()",
                    "C. withTime()",
                    "D. dateTime.toInstant()",
                    "E. new Instant()",
                    "F. zonedDateTime.toInstant()"
                ],
                "correct_answer_indexes": [
                    1,
                    5
                ],
                "correct_answer_explanation": "14. B, F. Options A and C are incorrect because there is no asTime() or\nwithTime() method defined on LocalDate. Option B correctly creates\na LocalDateTime from a LocalDate and LocalTime. Option E is\nincorrect because Instant, like other date/time classes, does not have\na public constructor and is instantiated via methods. Option F is the\nproper conversion. Option D is incorrect because the source object\ndoes not represent a point in time. Without a time zone, Java doesn’t\nknow what moment in time to use for the Instant."
            },
            {
                "id": "82f28a7b-0199-1000-f4c0-00006a3b37d0",
                "question": "15. What is the output of the following? (Choose all that apply.)",
                "answer_options": [
                    "A. [pig, PIG, 123]",
                    "B. [PIG, pig, 123]",
                    "C. [123, PIG, pig]",
                    "D. [123, pig, PIG]",
                    "E. -3",
                    "F. -2",
                    "G. The results of binarySearch() are undefined in this example."
                ],
                "correct_answer_indexes": [
                    2,
                    4
                ],
                "correct_answer_explanation": "15. C, E. Numbers sort before letters, and uppercase sorts before\nlowercase. This makes option C one of the answers. The\nbinarySearch() method looks at where a value would be inserted,\nwhich is before the second element for Pippa. It then negates it and\nsubtracts one, which is option E."
            },
            {
                "id": "82f28a7b-0199-1000-2e74-0000c8e94c81",
                "question": "16. Which of these statements are true? (Choose all that apply.)",
                "answer_options": [
                    "A. letters.substring(1, 2) returns a single-character String.",
                    "B. letters.substring(2, 2) returns a single-character String.",
                    "C. letters.substring(6, 5) returns a single-character String.",
                    "D. letters.substring(6, 6) returns a single-character String.",
                    "E. letters.substring(1, 2) throws an exception.",
                    "F. letters.substring(2, 2) throws an exception.",
                    "G. letters.substring(6, 5) throws an exception.",
                    "H. letters.substring(6, 6) throws an exception."
                ],
                "correct_answer_indexes": [
                    0,
                    6
                ],
                "correct_answer_explanation": "16. A, G. The substring() method includes the starting index but not the\nending index. When called with 1 and 2, it returns a single-character\nString, making option A correct and option E incorrect. Calling\nsubstring() with 2 as both parameters is legal. It returns an empty\nString, making options B and F incorrect. Java does not allow the\nindexes to be specified in reverse order. Option G is correct because it\nthrows a StringIndexOutOfBoundsException. Finally, option H is\nincorrect because it returns an empty String."
            },
            {
                "id": "82f28a7b-0199-1000-0364-0000fd317a00",
                "question": "17. What is the result of the following code? (Choose all that apply.)",
                "answer_options": [
                    "A. 2",
                    "B. 4",
                    "C. 7",
                    "D. 10",
                    "E. ==",
                    "F. equals",
                    "G. An exception is thrown.",
                    "H. The code does not compile."
                ],
                "correct_answer_indexes": [
                    2,
                    5
                ],
                "correct_answer_explanation": "17. C, F. This question is tricky because it has several parts. First, you\nhave to know that the text block on lines 13 and 14 is equivalent to a\nregular String. Since there is no line break at the end, this is four\ncharacters. Then, you have to know that String objects are immutable,\nwhich means the results of lines 17–19 are ignored. Finally, on line 20,\nsomething happens. We concatenate three new characters to s1 and\nnow have a String of length 7, making option C correct.\nNext, s2 += 2 expands to s2 = s2 + 2. A String concatenated with\nany other type gives a String. Lines 22, 23, and 24 all append to s2,\ngiving a result of \"2cfalse\". The if statement on line 27 returns true\nbecause the values of the two String objects are the same using object\nequality. For this reason, option F is correct. The if statement on line\n26 returns false because the two String objects are not the same in\nmemory. One comes directly from the string pool, and the other comes\nfrom building using String operations."
            },
            {
                "id": "82f28a7c-0199-1000-c60f-0000d78d4544",
                "question": "18. Which of the following fill in the blank to print a positive integer?\n(Choose all that apply.)\n\nString[] s1 = { \"Camel\", \"Peacock\", \"Llama\"};\nString[] s2 = { \"Camel\", \"Llama\", \"Peacock\"};\nString[] s3 = { \"Camel\"};\nString[] s4 = { \"Camel\", null};\nSystem.out.println(Arrays.)____________________________;",
                "answer_options": [
                    "A. compare(s1, s2)",
                    "B. mismatch(s1, s2)",
                    "C. compare(s3, s4)",
                    "D. mismatch (s3, s4)",
                    "E. compare(s4, s4)",
                    "F. mismatch (s4, s4)"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    3
                ],
                "correct_answer_explanation": "18. A, B, D. The compare() method returns a positive integer when the\narrays are different and the first is larger. This is the case for option A\nsince the s2 element at index 1 comes first alphabetically. It is not the\ncase for option C because the s4 is longer or for option E because the\narrays are the same.\nThe mismatch() method returns a positive integer when the arrays are\ndifferent in a position index 1 or greater. This is the case for options B\nand D since the difference is at index 1. It is not the case for option F\nbecause there is no difference."
            },
            {
                "id": "82f28a7c-0199-1000-019f-0000358c6ca0",
                "question": "19. Note that March 12, 2028 is the weekend that clocks spring ahead for\ndaylight saving time. What is the output of the following? (Choose all\nthat apply.)\n\nvar date = LocalDate.of(2028, Month.MARCH, 12);\nvar time = LocalTime.of(1, 30);\nvar zone = ZoneId.of(\"US/Eastern\");\nvar dateTime1 = ZonedDateTime.of(date, time, zone);\nvar dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);\nlong diff = ChronoUnit.HOURS.between(dateTime1, dateTime2);\nint hour = dateTime2.getHour();\nboolean offset = dateTime1.getOffset()\n== dateTime2.getOffset();\nSystem.out.println(\"diff = \" + diff);\nSystem.out.println(\"hour = \" + hour);\nSystem.out.println(\"offset = \" + offset);",
                "answer_options": [
                    "A. diff = 1",
                    "B. diff = 2",
                    "C. hour = 2",
                    "D. hour = 3",
                    "E. offset = true",
                    "F. The code does not compile.",
                    "G. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    0,
                    3
                ],
                "correct_answer_explanation": "19. A, D. The dateTime1 object has a time of 1:30 per initialization. The\ndateTime2 object is an hour later. However, there is no 2:30 when\nspringing ahead, setting the time to 3:30. Option A is correct because it\nis an hour later. Option D is also correct because the hour of the new\ntime is 3. Option E is not correct because we have changed the time\nzone offset due to daylight saving time."
            },
            {
                "id": "82f28a7c-0199-1000-5311-000029bd2f9a",
                "question": "20. Which of the following can fill in the blank to print avaJ? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. reverse()",
                    "B. append(\"vaJ$\").substring(0, 4)",
                    "C. append(\"vaJ$\").delete(0,",
                    "D. append(\"vaJ$\").delete(0,",
                    "E. None of the above"
                ],
                "correct_answer_indexes": [
                    0,
                    2
                ],
                "correct_answer_explanation": "20. A, C. The reverse() method is the easiest way of reversing the\ncharacters in a StringBuilder; therefore, option A is correct. In option\nB, substring() returns a String, which is not stored anywhere.\nOption C uses method chaining. First, it creates the value \"JavavaJ$\".\nThen, it removes the first three characters, resulting in \"avaJ$\".\nFinally, it removes the last character, resulting in \"avaJ\". Option D\nthrows an exception because you cannot delete the character after the\nlast index. Remember that deleteCharAt() uses indexes that are zero-\nbased, and length() counts the number of characters rather than the\nindex."
            },
            {
                "id": "82f28a7c-0199-1000-c4e1-0000ef3e4b27",
                "question": "21. What is the output of the following code?\n\nvar date = LocalDate.of(2025, Month.APRIL, 30);\ndate.plusDays(2);\ndate.plusYears(3);\nSystem.out.println(date.getYear() + \" \" + date.getMonth()\n+ \" \" + date.getDayOfMonth());",
                "answer_options": [
                    "A. 2025 APRIL 30",
                    "B. 2025 MAY 2",
                    "C. 2028 APRIL 2",
                    "D. 2028 APRIL 30",
                    "E. 2028 MAY 2",
                    "F. The code does not compile.",
                    "G. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "21. A. The date starts out as April 30, 2025. Since dates are immutable and\nthe plus methods’ return values are ignored, the result is unchanged.\nTherefore, option A is correct."
            },
            {
                "id": "82f28a7c-0199-1000-d265-0000f443f1bb",
                "question": "22. What is the output of the following?",
                "answer_options": [
                    "A. 2025-06-30T13:04",
                    "B. 2026-04-304",
                    "C. 2026-04-30T13:04",
                    "D. 2026-06-30T",
                    "E. 2026-06-30T13:04",
                    "F. The code does not compile.",
                    "G. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "22. E. The code first creates a date of 2025-10-31. The chaining in the\noutput is valid resulting in interim states of 2026-10-31, followed by\n2026-05-31, then 2026-06-30, then 2026-06-30, and finally the result\nof 2026-06-30T13:04."
            },
            {
                "id": "82f28a7c-0199-1000-2c40-00001f6907eb",
                "question": "1. Which statements about the final modifier are correct? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. Instance and static variables can be marked final.",
                    "B. A variable is effectively final only if it is marked final.",
                    "C. An object that is marked final cannot be modified.",
                    "D. Local variables cannot be declared with type var and the final",
                    "E. A primitive that is marked final cannot be modified."
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "1. A, E. Instance and static variables can be marked final, making\noption A correct. Effectively final means a local variable is not marked\nfinal but whose value does not change after it is set, making option B\nincorrect. Option C is incorrect, as final refers only to the reference to\nan object, not its contents. Option D is incorrect, as var and final can\nbe used together. Finally, option E is correct: once a primitive is\nmarked final, it cannot be modified."
            },
            {
                "id": "82f28a7c-0199-1000-1dc1-0000d6e809ea",
                "question": "2. Which of the following can fill in the blank in this code to make it\ncompile? (Choose all that apply.)\n\npublic class Ant {\n_________ void method() {}\n}",
                "answer_options": [
                    "A. default",
                    "B. final",
                    "C. private",
                    "D. Public",
                    "E. String",
                    "F. zzz:"
                ],
                "correct_answer_indexes": [
                    1,
                    2
                ],
                "correct_answer_explanation": "2. B, C. The keyword void is a return type. Only the access modifier or\noptional specifiers are allowed before the return type. Option C is\ncorrect, creating a method with private access. Option B is also\ncorrect, creating a method with package access and the optional\nspecifier final. Since package access does not use a modifier, we get\nto jump right to final. Option A is incorrect because package access\nomits the access modifier rather than specifying default. Option D is\nincorrect because Java is case sensitive. It would have been correct if\npublic were the choice. Option E is incorrect because the method\nalready has a void return type. Option F is incorrect because labels are\nnot allowed for methods."
            },
            {
                "id": "82f28a7c-0199-1000-f7d0-0000e41b074c",
                "question": "3. Which of the following methods compile? (Choose all that apply.)",
                "answer_options": [
                    "A. final static void rain() {}",
                    "B. public final int void snow() {}",
                    "C. private void int hail() {}",
                    "D. static final void sleet() {}",
                    "E. void final ice() {}",
                    "F. void public slush() {}"
                ],
                "correct_answer_indexes": [
                    0,
                    3
                ],
                "correct_answer_explanation": "3. A, D. Options A and D are correct because the optional specifiers are\nallowed in any order. Options B and C are incorrect because they each\nhave two return types. Options E and F are incorrect because the return\ntype is before the optional specifier and access modifier, respectively."
            },
            {
                "id": "82f28a7c-0199-1000-0aa2-00002799910a",
                "question": "4. Which of the following can fill in the blank and allow the code to\ncompile? (Choose all that apply.)\n\nfinal ______ song = 6;",
                "answer_options": [
                    "A. int",
                    "B. Integer",
                    "C. long",
                    "D. Long",
                    "E. double",
                    "F. Double"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    2,
                    4
                ],
                "correct_answer_explanation": "4. A, B, C, E. The value 6 can be implicitly promoted to any of the\nprimitive types, making options A, C, and E correct. It can also be\nautoboxed to Integer, making option B correct. It cannot be both\npromoted and autoboxed, making options D and F incorrect."
            },
            {
                "id": "82f28a7c-0199-1000-a7cc-0000d659ea1a",
                "question": "5. Which of the following methods compile? (Choose all that apply.)",
                "answer_options": [
                    "A. public void january() { return; }",
                    "B. public int february() { return null;}",
                    "C. public void march() {}",
                    "D. public int april() { return 9;}",
                    "E. public int may() { return 9.0;}",
                    "F. public int june() { return;}"
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    3
                ],
                "correct_answer_explanation": "5. A, C, D. Options A and C are correct because a void method is\noptionally allowed to have a return statement as long as it doesn’t try\nto return a value. Option B does not compile because null requires a\nreference object as the return type. Since int is primitive, it is not a\nreference object. Option D is correct because it returns an int value.\nOption E does not compile because it tries to return a double when the\nreturn type is int. Since a double cannot be assigned to an int, it\ncannot be returned as one either. Option F does not compile because no\nvalue is actually returned."
            },
            {
                "id": "82f28a7c-0199-1000-bcce-00005cde5cac",
                "question": "6. Which of the following methods compile? (Choose all that apply.)",
                "answer_options": [
                    "A. public void violin(int… nums) {}",
                    "B. public void viola(String values, int… nums) {}",
                    "C. public void cello(int… nums, String values) {}",
                    "D. public void bass(String… values, int… nums) {}",
                    "E. public void flute(String[] values, …int nums) {}",
                    "F. public void oboe(String[] values, int[] nums) {}"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    5
                ],
                "correct_answer_explanation": "6. A, B, F. Options A and B are correct because the single varargs\nparameter is the last parameter declared. Option F is correct because it\ndoesn’t use any varargs parameters. Option C is incorrect because the\nvarargs parameter is not last. Option D is incorrect because two\nvarargs parameters are not allowed in the same method. Option E is\nincorrect because the … for a varargs must be after the type, not before\nit."
            },
            {
                "id": "82f28a7d-0199-1000-6913-00003df425da",
                "question": "7. Given the following method, which of the method calls return 2?\n(Choose all that apply.)\n\npublic int juggle(boolean b, boolean… b2) {\nreturn b2.length;\n}",
                "answer_options": [
                    "A. juggle();",
                    "B. juggle(true);",
                    "C. juggle(true, true);",
                    "D. juggle(true, true, true);",
                    "E. juggle(true, {true, true});",
                    "F. juggle(true, new boolean[2]);"
                ],
                "correct_answer_indexes": [
                    3,
                    5
                ],
                "correct_answer_explanation": "7. D, F. Options D and F are correct. Option D passes the initial\nparameter plus two more to turn into a varargs array of size 2. Option\nF passes the initial parameter plus an array of size 2. Option A does\nnot compile because it does not pass the initial parameter. Option E\ndoes not compile because it does not declare an array properly. It\nshould be new boolean[] {true, true}. Option B creates a varargs\narray of size 0, and option C creates a varargs array of size 1."
            },
            {
                "id": "82f28a7d-0199-1000-4d64-00004a4f1172",
                "question": "8. Which of the following statements is correct?",
                "answer_options": [
                    "A. Package access is more lenient than protected access.",
                    "B. A public class that has private fields and package methods is not",
                    "C. You can use access modifiers so only some of the classes in a",
                    "D. You can use access modifiers to allow access to all methods and",
                    "E. You can use access modifiers to restrict access to all classes that"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "8. D. Option D is correct. A common practice is to set all fields to be\nprivate and all methods to be public. Option A is incorrect because\nprotected access allows everything that package access allows and\nadditionally allows subclasses access. Option B is incorrect because\nthe class is public. This means that other classes can see the class.\nHowever, they cannot call any of the methods or read any of the fields.\nIt is essentially a useless class. Option C is incorrect because package\naccess applies to the whole package. Option E is incorrect because\nJava has no such wildcard access capability."
            },
            {
                "id": "82f28a7d-0199-1000-3646-000034a857db",
                "question": "9. Given the following class definitions, which lines in the main()\nmethod generate a compiler error? (Choose all that apply.)\n\n// Classroom.java\npackage my.school;\npublic class Classroom {\n  private int roomNumber;\n  protected static String teacherName;\n  static int globalKey = 54321;\n  public static int floor = 3;\n  Classroom(int r, String t) {\n    roomNumber = r;\n    teacherName = t; } }\n// School.java\n1: package my.city;\n2: import my.school.*;\n3: public class School {\n4: public static void main(String[] args) {\n5: System.out.println(Classroom.globalKey);\n6: Classroom room = new Classroom(101, \"Mrs.\nAnderson\");\n7: System.out.println(room.roomNumber);\n8: System.out.println(Classroom.floor);\n9: System.out.println(Classroom.teacherName); } }",
                "answer_options": [
                    "A. None: the code compiles fine.",
                    "B. Line 5.",
                    "C. Line 6.",
                    "D. Line 7.",
                    "E. Line 8.",
                    "F. Line 9."
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    3,
                    5
                ],
                "correct_answer_explanation": "9. B, C, D, F. The two classes are in different packages, which means\nprivate access and package access will not compile. This causes\ncompiler errors on lines 5, 6, and 7, making options B, C, and D\ncorrect answers. Additionally, protected access will not compile since\nSchool does not inherit from Classroom. This causes the compiler\nerror on line 9, making option F a correct answer as well."
            },
            {
                "id": "82f28a7d-0199-1000-3966-00004e605937",
                "question": "10. What is the output of executing the Chimp program?\n\n// Rope.java\n1: package rope;\n2: public class Rope {\n3: public static int LENGTH = 5;\n4: static {\n5: LENGTH = 10;\n6: }\n7: public static void swing() {\n8: System.out.print(\"swing \");\n9: } }\n// Chimp.java\n1: import rope.*;\n2: import static rope.Rope.*;\n3: public class Chimp {\n4: public static void main(String[] args) {\n5: Rope.swing();\n6: new Rope().swing();\n7: System.out.println(LENGTH);\n8: } }",
                "answer_options": [
                    "A. swing swing 5",
                    "B. swing swing 10",
                    "C. Compiler error on line 2 of Chimp",
                    "D. Compiler error on line 5 of Chimp",
                    "E. Compiler error on line 6 of Chimp",
                    "F. Compiler error on line 7 of Chimp"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "10. B. Rope runs line 3, setting LENGTH to 5, and then immediately after\nthat runs the static initializer, which sets it to 10. Line 5 in the Chimp\nclass calls the static method normally and prints swing and a space.\nLine 6 also calls the static method. Java allows calling a static\nmethod through an instance variable, although it is not recommended.\nLine 7 uses the static import on line 2 to reference LENGTH. For these\nreasons, option B is correct."
            },
            {
                "id": "82f28a7d-0199-1000-61bd-00006f008e36",
                "question": "11. Which statements are true of the following code? (Choose all that\napply.)\n\n1: public class Rope {\n2: public static void swing() {\n3: System.out.print(\"swing\");\n4: }\n5: public void climb() {\n6: System.out.println(\"climb\");\n7: }\n8: public static void play() {\n9: swing();\n10: climb();\n11: }\n12: public static void main(String[] args) {\n13: Rope rope = new Rope();\n14: rope.play();\n15: Rope rope2 = null;\n16: System.out.print(\"-\");\n17: rope2.play();\n18: } }",
                "answer_options": [
                    "A. The code compiles as is.",
                    "B. There is exactly one compiler error in the code.",
                    "C. There are exactly two compiler errors in the code.",
                    "D. If the line(s) with compiler errors are removed, the output is",
                    "E. If the line(s) with compiler errors are removed, the output is",
                    "F. If the line(s) with compile errors are removed, the code throws a"
                ],
                "correct_answer_indexes": [
                    1,
                    4
                ],
                "correct_answer_explanation": "11. B, E. Line 10 does not compile because static methods are not\nallowed to call instance methods. Even though we are calling play()\nas if it were an instance method and an instance exists, Java knows\nplay() is really a static method and treats it as such. Since this is the\nonly line that does not compile, option B is correct. If line 10 is\nremoved, the code prints swing-swing, making option E correct. It\ndoes not throw a NullPointerException on line 17 because play() is\na static method. Java looks at the type of the reference for rope2 and\ntranslates the call to Rope.play()."
            },
            {
                "id": "82f28a7d-0199-1000-a8da-00005108df01",
                "question": "12. How many variables in the following method are effectively final?\n\n10: public void feed() {\n11: int monkey = 0;\n12: if(monkey> 0) {\n13: var giraffe = monkey++;\n14: String name;\n15: name = \"geoffrey\";\n16: }\n17: String name = \"milly\";\n18: var food = 10;\n19: while(monkey <= 10) {\n20: food = 0;\n21: }\n22: name = null;\n23: }",
                "answer_options": [
                    "A. 1.",
                    "B. 2.",
                    "C. 3.",
                    "D. 4.",
                    "E. 5.",
                    "F. None of the above. The code does not compile."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "12. B. The test for effectively final is if the final modifier can be added to\nthe local variable and the code still compiles. The monkey variable\ndeclared on line 11 is not effectively final because it is modified on\nline 13. The giraffe and name variables declared on lines 13 and 14,\nrespectively, are effectively final and not modified after they are set.\nThe name variable declared on line 17 is not effectively final since it is\nmodified on line 22. Finally, the food variable on line 18 is not\neffectively final since it is modified on line 20. Since there are two\neffectively final variables, option B is correct."
            },
            {
                "id": "82f28a7d-0199-1000-e2d9-00001c55075a",
                "question": "13. What is the output of the following code?\n\n// RopeSwing.java\nimport rope.*;\nimport static rope.Rope.*;\npublic class RopeSwing {\nprivate static Rope rope1 = new Rope();\nprivate static Rope rope2 = new Rope();\n{\nSystem.out.println(rope1.length);\n}\npublic static void main(String[] args) {\nrope1.length = 2;\nrope2.length = 8;\nSystem.out.println(rope1.length);\n}\n}\n// Rope.java\npackage rope;\npublic class Rope {\npublic static int length = 0;\n}",
                "answer_options": [
                    "A. 02",
                    "B. 08",
                    "C. 2",
                    "D. 8",
                    "E. The code does not compile.",
                    "F. An exception is thrown."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "13. D. There are two details to notice in this code. First, note that\nRopeSwing has an instance initializer and not a static initializer. Since\nRopeSwing is never constructed, the instance initializer does not run.\nThe other detail is that length is static. Changes from any object\nupdate this common static variable. The code prints 8, making option\nD correct."
            },
            {
                "id": "82f28a7d-0199-1000-ec9b-0000bcd2d7f3",
                "question": "14. How many lines in the following code have compiler errors?\n\n1: public class RopeSwing {\n2: private static final String leftRope;\n3: private static final String rightRope;\n4: private static final String bench;\n5: private static final String name = \"name\";\n6: static {\n7: leftRope = \"left\";\n8: rightRope = \"right\";\n9: }\n10: static {\n11: name = \"name\";\n12: rightRope = \"right\";\n13: }\n14: public static void main(String[] args) {\n15: bench = \"bench\";\n16: }\n17: }",
                "answer_options": [
                    "A. 0",
                    "B. 1",
                    "C. 2",
                    "D. 3",
                    "E. 4",
                    "F. 5"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "14. E. If a variable is static final, it must be set exactly once, and it\nmust be in the declaration line or in a static initialization block. Line\n4 doesn’t compile because bench is not set in either of these locations.\nLine 15 doesn’t compile because final variables are not allowed to be\nset after that point. Line 11 doesn’t compile because name is set twice:\nonce in the declaration and again in the static block. Line 12 doesn’t\ncompile because rightRope is set twice as well. Both are in static\ninitialization blocks. Since four lines do not compile, option E is\ncorrect."
            },
            {
                "id": "82f28a7d-0199-1000-6e6d-00005eb5c045",
                "question": "15. Which of the following can replace line 2 to make this code compile?\n\n1: import java.util.*;\n2: // INSERT CODE HERE\n3: public class Imports {\n4: public void method(ArrayList<String> list) {\n5: sort(list);\n6: }\n7: }",
                "answer_options": [
                    "A. import static java.util.Collections;",
                    "B. import static java.util.Collections.*;",
                    "C. import static",
                    "D. static import java.util.Collections;",
                    "E. static import java.util.Collections.*;",
                    "F. static import"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "15. B. The two valid ways to do this are import static\njava.util.Collections.*; and import static\njava.util.Collections.sort;, making option B correct. Option A is\nincorrect because you can do a static import only on static members.\nClasses such as Collections require a regular import. Option C is\nnonsense as method parameters have no business in an import. Options\nD, E, and F try to trick you into reversing the syntax of import\nstatic."
            },
            {
                "id": "82f28a7d-0199-1000-db65-0000c4b7b1a0",
                "question": "16. What is the result of the following statements?\n\n1: public class Test {\n2: public void print(byte x) {\n3: System.out.print(\"byte-\");\n4: }\n5: public void print(int x) {\n6: System.out.print(\"int-\");\n7: }\n8: public void print(float x) {\n9: System.out.print(\"float-\");\n10: }\n11: public void print(Object x) {\n12: System.out.print(\"Object-\");\n13: }\n14: public static void main(String[] args) {\n15: Test t = new Test();\n16: short s = 123;\n17: t.print(s);\n18: t.print(true);\n19: t.print(6.789);\n20: }\n21: }",
                "answer_options": [
                    "A. byte-float-Object-",
                    "B. int-float-Object-",
                    "C. byte-Object-float-",
                    "D. int-Object-float-",
                    "E. int-Object-Object-",
                    "F. byte-Object-Object-"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "16. E. The argument on line 17 is a short. It can be promoted to an int, so\nprint() on line 5 is invoked. The argument on line 18 is a boolean. It\ncan be autoboxed to a Boolean, so print() on line 11 is invoked. The\nargument on line 19 is a double. It can be autoboxed to a Double, so\nprint() on line 11 is invoked. Therefore, the output is int-Object-\nObject-, and the correct answer is option E."
            },
            {
                "id": "82f28a7d-0199-1000-1b73-0000946badfa",
                "question": "17. What is the result of the following program?\n\n1: public class Squares {\n2: public static long square(int x) {\n3: var y = x * (long) x;\n4: x = -1;\n5: return y;\n6: }\n7: public static void main(String[] args) {\n8: var value = 9;\n9: var result = square(value);\n10: System.out.println(value);\n11: } }",
                "answer_options": [
                    "A. -1",
                    "B. 9",
                    "C. 81",
                    "D. Compiler error on line 9",
                    "E. Compiler error on a different line"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "17. B. Since Java is pass-by-value and the variable on line 8 never gets\nreassigned, it stays as 9. In the method square, x starts as 9. The y\nvalue becomes 81, and then x gets set to –1. Line 9 does set result to\n81. However, we are printing out value, and that is still 9, making\noption B correct."
            },
            {
                "id": "82f28a7d-0199-1000-3fdc-00009ce24cd4",
                "question": "18. Which of the following are output by the following code? (Choose all\nthat apply.)\n\npublic class StringBuilders {\npublic static StringBuilder work(StringBuilder a,\nStringBuilder b) {\na = new StringBuilder(\"a\");\nb.append(\"b\");\nreturn a;\n}\npublic static void main(String[] args) {\nvar s1 = new StringBuilder(\"s1\");\nvar s2 = new StringBuilder(\"s2\");\nvar s3 = work(s1, s2);\nSystem.out.println(\"s1 = \" + s1);\nSystem.out.println(\"s2 = \" + s2);\nSystem.out.println(\"s3 = \" + s3);\n}\n}",
                "answer_options": [
                    "A. s1 = a",
                    "B. s1 = s1",
                    "C. s2 = s2",
                    "D. s2 = s2b",
                    "E. s3 = a",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    1,
                    3,
                    4
                ],
                "correct_answer_explanation": "18. B, D, E. Since Java is pass-by-value, assigning a new object to a does\nnot change the caller. Calling append() does affect the caller because\nboth the method parameter and the caller have a reference to the same\nobject. Finally, returning a value does pass the reference to the caller\nfor assignment to s3. For these reasons, options B, D, and E are\ncorrect."
            },
            {
                "id": "82f28a7d-0199-1000-6970-00000a5d553d",
                "question": "19. Which of the following will compile when independently inserted in\nthe following code? (Choose all that apply.)\n\n1: public class Order3 {\n2: final String value1 = \"red\";\n3: static String value2 = \"blue\";\n4: String value3 = \"yellow\";\n5: {\n6: // CODE SNIPPET 1\n7: }\n8: static {\n9: // CODE SNIPPET 2\n10: } }",
                "answer_options": [
                    "A. Insert at line 6: value1 = \"green\";",
                    "B. Insert at line 6: value2 = \"purple\";",
                    "C. Insert at line 6: value3 = \"orange\";",
                    "D. Insert at line 9: value1 = \"magenta\";",
                    "E. Insert at line 9: value2 = \"cyan\";",
                    "F. Insert at line 9: value3 = \"turquoise\";"
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    4
                ],
                "correct_answer_explanation": "19. B, C, E. The variable value1 is a final instance variable. It can be set\nonly once: in the variable declaration, an instance initializer, or a\nconstructor. Option A does not compile because the final variable\nwas already set in the declaration. The variable value2 is a static\nvariable. Both instance and static initializers are able to access\nstatic variables, making options B and E correct. The variable\nvalue3 is an instance variable, making option C correct. Options D\nand F do not compile because a static initializer does not have access\nto instance variables. "
            },
            {
                "id": "82f28a7e-0199-1000-8138-0000e9aff75a",
                "question": "20. Which of the following are true about the following code? (Choose all\nthat apply.)\n\npublic class Run {\nstatic void execute() {\nSystem.out.print(\"1-\");\n}\nstatic void execute(int num) {\nSystem.out.print(\"2-\");\n}\nstatic void execute(Integer num) {\nSystem.out.print(\"3-\");\n}\nstatic void execute(Object num) {\nSystem.out.print(\"4-\");\n}\nstatic void execute(int… nums) {\nSystem.out.print(\"5-\");\n}\npublic static void main(String[] args) {\nRun.execute(100);\nRun.execute(100L);\n}\n}",
                "answer_options": [
                    "A. The code prints out 2-4-.",
                    "B. The code prints out 3-4-.",
                    "C. The code prints out 4-2-.",
                    "D. The code prints out 4-4-.",
                    "E. The code prints 3-4- if you remove the method static void",
                    "F. The code prints 4-4- if you remove the method static void"
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "20. A, E. The 100 parameter is an int and so calls the matching int\nmethod, making option A correct. When this method is removed, Java\nlooks for the next most specific constructor. Java prefers autoboxing to\nvarargs, so it chooses the Integer constructor. The 100L parameter is a\nlong. Since it can’t be converted into a smaller type, it is autoboxed\ninto a Long, and then the method for Object is called, making option E\ncorrect."
            },
            {
                "id": "82f28a7e-0199-1000-3bae-00000b0a8e57",
                "question": "21. Which method signatures are valid overloads of the following method\nsignature? (Choose all that apply.)\n\npublic void moo(int m, int… n)",
                "answer_options": [
                    "A. public void moo(int a, int… b)",
                    "B. public int moo(char ch)",
                    "C. public void moooo(int… z)",
                    "D. private void moo(int… x)",
                    "E. public void moooo(int y)",
                    "F. public void moo(int… c, int d)",
                    "G. public void moo(int… i, int j…)"
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "21. B, D. Option A is incorrect because it has the same parameter list of\ntypes and therefore the same signature as the original method. Options\nB and D are the correct answers, as they are valid method overloads in\nwhich the types of parameters change. When overloading methods, the\nreturn type and access modifiers do not need to be the same. Options C\nand E are incorrect because the method name is different. Options F\nand G do not compile. There can be at most one varargs parameter, and\nit must be the last element in the parameter list."
            },
            {
                "id": "82f28a7e-0199-1000-1bcf-0000c14e8e88",
                "question": "1. Which code can be inserted to have the code print 2?\n\npublic class BirdSeed {\nprivate int numberBags;\nboolean call;\npublic BirdSeed() {\n// LINE 1\ncall = false;\n// LINE 2\n}\npublic BirdSeed(int numberBags) {\nthis.numberBags = numberBags;\n}\npublic static void main(String[] args) {\nvar seed = new BirdSeed();\nSystem.out.print(seed.numberBags);\n} }",
                "answer_options": [
                    "A. Replace line 1 with BirdSeed(2);",
                    "B. Replace line 2 with BirdSeed(2);",
                    "C. Replace line 1 with new BirdSeed(2);",
                    "D. Replace line 2 with new BirdSeed(2);",
                    "E. Replace line 1 with this(2);",
                    "F. Replace line 2 with this(2);",
                    "G. The code prints 2 without any changes."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "1. E. Options A and B will not compile because constructors cannot be\ncalled without new. Options C and D will compile but will create a new\nobject rather than setting the fields in this one. The result is the\nprogram will print 0, not 2, at runtime. Calling an overloaded\nconstructor, using this(), or a parent constructor, using super(), is\nallowed only on the first line of the constructor, making option E\ncorrect and option F incorrect. Finally, option G is incorrect because\nthe program prints 0 without any changes, not 2."
            },
            {
                "id": "82f28a7e-0199-1000-3673-00006bd23105",
                "question": "2. Which modifier pairs can be used together in a method declaration?\n(Choose all that apply.)",
                "answer_options": [
                    "A. static and final",
                    "B. private and static",
                    "C. static and abstract",
                    "D. private and abstract",
                    "E. abstract and final",
                    "F. private and final"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    5
                ],
                "correct_answer_explanation": "2. A, B, F. The final modifier can be used with private and static,\nmaking options A and F correct. Marking a private method final is\nredundant but allowed. A private method may also be marked\nstatic, making option B correct. Options C, D, and E are incorrect\nbecause methods marked static, private, or final cannot be\noverridden; therefore, they cannot be marked abstract."
            },
            {
                "id": "82f28a7e-0199-1000-d1da-0000e9bf1a34",
                "question": "3. Which of the following statements about methods are true? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. Overloaded methods must have the same signature.",
                    "B. Overridden methods must have the same signature.",
                    "C. Hidden methods must have the same signature.",
                    "D. Overloaded methods must have the same return type.",
                    "E. Overridden methods must have the same return type.",
                    "F. Hidden methods must have the same return type."
                ],
                "correct_answer_indexes": [
                    1,
                    2
                ],
                "correct_answer_explanation": "3. B, C. Overloaded methods have the same method name but a different\nsignature (the method parameters differ), making option A incorrect.\nOverridden instance methods and hidden static methods must have\nthe same signature (the name and method parameters must match),\nmaking options B and C correct. Overloaded methods can have\ndifferent return types, while overridden and hidden methods can have\ncovariant return types. None of these methods is required to use the\nsame return type, making options D, E, and F incorrect."
            },
            {
                "id": "82f28a7e-0199-1000-6e1c-0000490c6834",
                "question": "4. What is the output of the following program?\n\n1: class Mammal {\n2: private void sneeze() {}\n3: public Mammal(int age) {\n4: System.out.print(\"Mammal\");\n5: } }\n6: public class Platypus extends Mammal {\n7: int sneeze() { return 1; }\n8: public Platypus() {\n9: System.out.print(\"Platypus\");\n10: }\n11: public static void main(String[] args) {\n12: new Mammal(5);\n13: } }",
                "answer_options": [
                    "A. Platypus",
                    "B. Mammal",
                    "C. PlatypusMammal",
                    "D. MammalPlatypus",
                    "E. The code will compile if line 7 is changed.",
                    "F. The code will compile if line 9 is changed."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "F. The code will not compile as is, because the parent class Mammal\ndoes not define a no-argument constructor. For this reason, the first\nline of a Platypus constructor should be an explicit call to\nsuper(int), making option F the correct answer. Option E is\nincorrect, as line 7 compiles without issue. The sneeze() method in\nthe Mammal class is marked private, meaning it is not inherited and\ntherefore is not overridden in the Platypus class. For this reason, the\nsneeze() method in the Platypus class is free to define the same\nmethod with any return type."
            },
            {
                "id": "82f28a7e-0199-1000-00b0-00001a8ad145",
                "question": "5. Which of the following completes the constructor so that this code\nprints out 50?\n\nclass Speedster {\nint numSpots;\n}\npublic class Cheetah extends Speedster {\nint numSpots;\npublic Cheetah(int numSpots) {\n// INSERT CODE HERE\n}\npublic static void main(String[] args) {\nSpeedster s = new Cheetah(50);\nSystem.out.print(s.numSpots);\n}\n}",
                "answer_options": [
                    "A. numSpots = numSpots;",
                    "B. numSpots = this.numSpots;",
                    "C. this.numSpots = numSpots;",
                    "D. numSpots = super.numSpots;",
                    "E. super.numSpots = numSpots;",
                    "F. The code does not compile regardless of the code inserted into the",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "5. E. The code compiles, making option F incorrect. An instance variable\nwith the same name as an inherited instance variable is hidden, not\noverridden. This means that both variables exist, and the one that is\nused depends on the location and reference type. Because the main()\nmethod uses a reference type of Speedster to access the numSpots\nvariable, the variable in the Speedster class, not the Cheetah class,\nmust be set to 50. Option A is incorrect, as it reassigns the method\nparameter to itself. Option B is incorrect, as it assigns the method\nparameter the value of the instance variable in Cheetah, which is 0.\nOption C is incorrect, as it assigns the value to the instance variable in\nCheetah, not Speedster. Option D is incorrect, as it assigns the\nmethod parameter the value of the instance variable in Speedster,\nwhich is 0. Options A, B, C, and D all print 0 at runtime. Option E is\nthe correct answer, as it assigns the instance variable numSpots in the\nSpeedster class a value of 50. The numSpots variable in the\nSpeedster class is then correctly referenced in the main() method,\nprinting 50 at runtime."
            },
            {
                "id": "82f28a7e-0199-1000-8c20-0000e2f1211e",
                "question": "6. Which of the following declare immutable classes? (Choose all that\napply.)\n\npublic final class Moose {\nprivate final int antlers;\n}\npublic class Caribou {\nprivate int antlers = 10;\n}\npublic class Reindeer {\nprivate final int antlers = 5;\n}\npublic final class Elk {}\npublic final class Deer {\nprivate final Object o = new Object();\n}",
                "answer_options": [
                    "A. Moose",
                    "B. Caribou",
                    "C. Reindeer",
                    "D. Elk",
                    "E. Deer",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    3,
                    4
                ],
                "correct_answer_explanation": "6. D, E. The Moose class doesn’t compile, as the final variable antlers\nis not initialized when it is declared, in an instance initializer, or in a\nconstructor. Caribou and Reindeer are not immutable because they are\nnot marked final, which means a subclass could extend them and add\nmutable fields. Elk and Deer are both immutable classes since they are\nmarked final and only include private final members, making\noptions D and E correct. As shown with Elk, a class doesn’t need to\ndeclare any fields to be considered immutable."
            },
            {
                "id": "82f28a7e-0199-1000-ed58-0000f7c5eefe",
                "question": "7. What is the output of the following code?\n\n1: class Arthropod {\n2: protected void printName(long input) {\n3: System.out.print(\"Arthropod\");\n4: }\n5: void printName(int input) {\n6: System.out.print(\"Spooky\");\n7: } }\n8: public class Spider extends Arthropod {\n9: protected void printName(int input) {\n10: System.out.print(\"Spider\");\n11: }\n12: public static void main(String[] args) {\n13: Arthropod a = new Spider();\n14: a.printName((short)4);\n15: a.printName(4);\n16: a.printName(5L);\n17: } }",
                "answer_options": [
                    "A. SpiderSpiderArthropod",
                    "B. SpiderSpiderSpider",
                    "C. SpiderSpookyArthropod",
                    "D. SpookySpiderArthropod",
                    "E. The code will not compile because of line 5.",
                    "F. The code will not compile because of line 9.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "7. A. The code compiles and runs without issue, so options E and F are\nincorrect. The Arthropod class defines two overloaded versions of the\nprintName() method. The printName() method that takes an int\nvalue on line 5 is correctly overridden in the Spider class on line 9.\nRemember, an overridden method can have a broader access modifier,\nand protected access is broader than package access. Because of\npolymorphism, the overridden method replaces the method on all calls,\neven if an Arthropod reference variable is used, as is done in the\nmain() method. For these reasons, the overridden method is called on\nlines 14 and 15, printing Spider twice. Note that the short value is\nautomatically cast to the larger type of int, which then uses the\noverridden method. Line 16 calls the overloaded method in the\nArthropod class, as the long value 5L does not match the overridden\nmethod, resulting in Arthropod being printed. Therefore, option A is\nthe correct answer."
            },
            {
                "id": "82f28a7e-0199-1000-5930-000049657c95",
                "question": "8. What is the result of the following code?\n\n1: abstract class Bird {\n2: private final void fly() {\nSystem.out.println(\"Bird\"); }\n3: protected Bird() { System.out.print(\"Wow-\"); }\n4: }\n5: public class Pelican extends Bird {\n6: public Pelican() { System.out.print(\"Oh-\"); }\n7: protected void fly() {\nSystem.out.println(\"Pelican\"); }\n8: public static void main(String[] args) {\n9: var chirp = new Pelican();\n10: chirp.fly();\n11: } }",
                "answer_options": [
                    "A. Oh-Bird",
                    "B. Oh-Pelican",
                    "C. Wow-Oh-Bird",
                    "D. Wow-Oh-Pelican",
                    "E. The code contains a compilation error.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "8. D. The code compiles without issue. The question is making sure you\nknow that superclass constructors are called in the same manner in\nabstract classes as they are in non-abstract classes. Line 9 calls the\nconstructor on line 6. The compiler automatically inserts super() as\nthe first line of the constructor defined on line 6. The program then\ncalls the constructor on line 3 and prints Wow-. Control then returns to\nline 6, and Oh- is printed. Finally, the method call on line 10 uses the\nversion of fly() in the Pelican class, since it is marked private and\nthe reference type of var is resolved as Pelican. The final output is\nWow-Oh-Pelican, making option D the correct answer. Remember that\nprivate methods cannot be overridden. If the reference type of chirp\nwas Bird, then the code would not compile as it would not be\naccessible outside the class."
            },
            {
                "id": "82f28a7e-0199-1000-e117-0000acf4f091",
                "question": "9. Which of the following statements about overridden methods are true?\n(Choose all that apply.)",
                "answer_options": [
                    "A. An overridden method must contain method parameters that are",
                    "B. An overridden method may declare a new exception, provided it",
                    "C. An overridden method must be more accessible than the method",
                    "D. An overridden method may declare a broader checked exception",
                    "E. If an inherited method returns void, then the overridden version",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    1,
                    4
                ],
                "correct_answer_explanation": "9. B, E. The signature must match exactly, making option A incorrect.\nThere is no such thing as a covariant signature. An overridden method\nmust not declare any new checked exceptions or a checked exception\nthat is broader than the inherited method. For this reason, option B is\ncorrect, and option D is incorrect. Option C is incorrect because an\noverridden method may have the same access modifier as the version\nin the parent class. Finally, overridden methods must have covariant\nreturn types, and only void is covariant with void, making option E\ncorrect."
            },
            {
                "id": "82f28a7e-0199-1000-fbd5-0000884934ed",
                "question": "10. Which of the following pairs, when inserted into the blanks, allow the\ncode to compile? (Choose all that apply.)\n\n1: public class Howler {\n2: public Howler(long shadow) {\n3: ____________;\n4: }\n5: private Howler(int moon) {\n6: super();\n7: }\n8: }\n9: class Wolf extends Howler {\n10: protected Wolf(String stars) {\n11: super(2L);\n12: }\n13: public Wolf() {\n14: _____________;\n15: }\n16: }",
                "answer_options": [
                    "A. this(3) at line 3, this(\"\") at line 14.",
                    "B. this() at line 3, super(1) at line 14.",
                    "C. this((short)1) at line 3, this(null) at line 14.",
                    "D. super() at line 3, super() at line 14.",
                    "E. this(2L) at line 3, super((short)2) at line 14.",
                    "F. this(5) at line 3, super(null) at line 14.",
                    "G. Remove lines 3 and 14."
                ],
                "correct_answer_indexes": [
                    0,
                    2
                ],
                "correct_answer_explanation": "10. A, C. Option A is correct, as this(3) calls the constructor declared on\nline 5, while this(\"\") calls the constructor declared on line 10. Option\nB does not compile, as inserting this() at line 3 results in a compiler\nerror, since there is no matching constructor. Option C is correct, as\nshort can be implicitly cast to int, resulting in this((short)1)\ncalling the constructor declared on line 5. In addition, this(null)\ncalls the String constructor declared on line 10. Option D does not\ncompile because inserting super() on line 14 results in an invalid\nconstructor call. The Howler class does not contain a no-argument\nconstructor. Option E is also incorrect. Inserting this(2L) at line 3\nresults in a recursive constructor definition. The compiler detects this\nand reports an error. Option F is incorrect, as using super(null) on\nline 14 does not match any parent constructors. If an explicit cast was\nused, such as super((Integer)null), then the code would have\ncompiled but would throw an exception at runtime during unboxing.\nFinally, option G is incorrect because the superclass Howler does not\ncontain a no-argument constructor. Therefore, the constructor declared\non line 13 will not compile without an explicit call to an overloaded or\nparent constructor."
            },
            {
                "id": "82f28a7e-0199-1000-7e5c-0000d57251b6",
                "question": "11. What is the result of the following?\n\n1: public class PolarBear {\n2: StringBuilder value = new StringBuilder(\"t\");\n3: { value.append(\"a\"); }\n4: { value.append(\"c\"); }\n5: private PolarBear() {\n6: value.append(\"b\");\n7: }\n8: public PolarBear(String s) {\n9: this();\n10: value.append(s);\n11: }\n12: public PolarBear(CharSequence p) {\n13: value.append(p);\n14: }\n15: public static void main(String[] args) {\n16: Object bear = new PolarBear();\n17: bear = new PolarBear(\"f\");\n18: System.out.println(((PolarBear)bear).value);\n19: } }",
                "answer_options": [
                    "A. tacb",
                    "B. tacf",
                    "C. tacbf",
                    "D. tcafb",
                    "E. taftacb",
                    "F. The code does not compile.",
                    "G. An exception is thrown."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "11. C. The code compiles and runs without issue, making options F and G\nincorrect. Line 16 initializes a PolarBear instance and assigns it to the\nbear reference. The variable declaration and instance initializers are\nrun first, setting value to tac. The constructor declared on line 5 is\ncalled, resulting in value being set to tacb. Remember, a static\nmain() method can access private constructors declared in the same\nclass. Line 17 creates another PolarBear instance, replacing the bear\nreference declared on line 16. First, value is initialized to tac as\nbefore. Line 17 calls the constructor declared on line 8, since String is\nthe narrowest match of a String literal. This constructor then calls the\noverloaded constructor declared on line 5, resulting in value being\nupdated to tacb. Control returns to the previous constructor, with line\n10 updating value to tacbf, and making option C the correct answer.\nNote that if the constructor declared on line 8 did not exist, then the\nconstructor on line 12 would match. Finally, the bear reference is\nproperly cast to PolarBear on line 18, making the value parameter\naccessible."
            },
            {
                "id": "82f28a7e-0199-1000-1c24-0000df9413a9",
                "question": "12. How many lines of the following program contain a compilation error?\n\n1: public class Rodent {\n2: public Rodent(Integer x) {}\n3: protected static Integer chew() throws Exception {\n4: System.out.println(\"Rodent is chewing\");\n5: return 1;\n6: }\n7: }\n8: class Beaver extends Rodent {\n9: public Number chew() throws RuntimeException {\n10: System.out.println(\"Beaver is chewing on wood\");\n11: return 2;\n12: } }",
                "answer_options": [
                    "A. None",
                    "B. 1",
                    "C. 2",
                    "D. 3",
                    "E. 4",
                    "F. 5"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "12. C. The code doesn’t compile, so option A is incorrect. The first\ncompilation error is on line 8. Since Rodent declares at least one\nconstructor, and it is not a no-argument constructor, Beaver must\ndeclare a constructor with an explicit call to a super() constructor.\nLine 9 contains two compilation errors. First, the return types are not\ncovariant since Number is a supertype, not a subtype, of Integer.\nSecond, the inherited method is static, but the overridden method is\nnot, making this an invalid override. The code contains three\ncompilation errors, although they are limited to two lines, making\noption C the correct answer."
            },
            {
                "id": "82f28a7f-0199-1000-46f2-000058246481",
                "question": "13. Which of these classes compile and will include a default constructor\ncreated by the compiler? (Choose all that apply.)",
                "answer_options": [
                    "A. public class Bird {}",
                    "B. public class Bird {",
                    "C. public class Bird {",
                    "D. public class Bird {",
                    "E. public class Bird {",
                    "F. public class Bird {",
                    "G. public class Bird {"
                ],
                "correct_answer_indexes": [
                    0,
                    6
                ],
                "correct_answer_explanation": "13. A, G. The compiler will insert a default no-argument constructor if the\nclass compiles and does not define any constructors. Options A and G\nfulfill this requirement, making them the correct answers. The bird()\ndeclaration in option G is a method declaration, not a constructor.\nOptions B and C do not compile. Since the constructor name does not\nmatch the class name, the compiler treats these as methods with\nmissing return types. Options D, E, and F all compile, but since they\ndeclare at least one constructor, the compiler does not supply one."
            },
            {
                "id": "82f28a7f-0199-1000-1d65-00008c735dec",
                "question": "14. Which of the following statements about inheritance are correct?\n(Choose all that apply.)",
                "answer_options": [
                    "A. A class can directly extend any number of classes.",
                    "B. A class can implement any number of interfaces.",
                    "C. All variables inherit java.lang.Object.",
                    "D. If class A is extended by B, then B is a superclass of A.",
                    "E. If class C implements interface D, then C is a subtype of D.",
                    "F. Multiple inheritance is the property of a class to have multiple"
                ],
                "correct_answer_indexes": [
                    1,
                    4,
                    5
                ],
                "correct_answer_explanation": "14. B, E, F. A class can only directly extend a single class, making option\nA incorrect. A class can implement any number of interfaces, though,\nmaking option B correct. Option C is incorrect because primitive\nvariables types do not inherit java.lang.Object. If a class extends\nanother class, then it is a subclass, not a superclass, making option D\nincorrect. A class that implements an interface is a subtype of that\ninterface, making option E correct. Finally, option F is correct as it is\nan accurate description of multiple inheritance, which is not permitted\nin Java."
            },
            {
                "id": "82f28a7f-0199-1000-398c-0000ee93d829",
                "question": "15. Which statement about the following program is correct?",
                "answer_options": [
                    "A. It compiles and prints true.",
                    "B. It compiles and prints false.",
                    "C. The code will not compile because of line 2.",
                    "D. The code will not compile because of line 5.",
                    "E. The code will not compile because of line 7.",
                    "F. The code will not compile because of line 8.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "15. C. The code does not compile because the isBlind() method in\nNocturnal is not marked abstract and does not contain a method\nbody. The rest of the lines compile without issue, making option C the\ncorrect answer. If the abstract modifier was added to line 2, then the\ncode would compile and print false at runtime, making option B the\ncorrect answer."
            },
            {
                "id": "82f28a7f-0199-1000-9503-0000ced3d0dc",
                "question": "16. What is the result of the following?\n\n1: class Arachnid {\n2: static StringBuilder sb = new StringBuilder();\n3: { sb.append(\"c\"); }\n4: static\n5: { sb.append(\"u\"); }\n6: { sb.append(\"r\"); }\n7: }\n8: public class Scorpion extends Arachnid {\n9: static\n10: { sb.append(\"q\"); }\n11: { sb.append(\"m\"); }\n12: public static void main(String[] args) {\n13: System.out.print(Scorpion.sb + \" \");\n14: System.out.print(Scorpion.sb + \" \");\n15: new Arachnid();\n16: new Scorpion();\n17: System.out.print(Scorpion.sb);\n18: } }",
                "answer_options": [
                    "A. qu qu qumrcrc",
                    "B. u u ucrcrm",
                    "C. uq uq uqmcrcr",
                    "D. uq uq uqcrcrm",
                    "E. qu qu qumcrcr",
                    "F. qu qu qucrcrm",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "16. D. The code compiles, so option G is incorrect. Based on order of\ninitialization, the static components are initialized first, starting with\nthe Arachnid class, since it is the parent of the Scorpion class, which\ninitializes the StringBuilder to u. The static initializer in Scorpion\nthen updates sb to contain uq, which is printed twice by lines 13 and\n14 along with spaces separating the values. Next, an instance of\nArachnid is initialized on line 15. There are two instance initializers in\nArachnid, and they run in order, appending cr to the StringBuilder,\nresulting in a value of uqcr. An instance of Scorpion is then initialized\non line 16. The instance initializers in the superclass Arachnid run\nfirst, appending cr again and updating the value of sb to uqcrcr.\nFinally, the instance initializer in Scorpion runs and appends m. The\nprogram completes with the final value printed being uq uq uqcrcrm,\nmaking option D the correct answer."
            },
            {
                "id": "82f28a7f-0199-1000-a9c7-0000d75eb78f",
                "question": "17. Which of the following are true? (Choose all that apply.)",
                "answer_options": [
                    "A. this() can be called from anywhere in a constructor.",
                    "B. this() can be called from anywhere in an instance method.",
                    "C. this.variableName can be called from any instance method in",
                    "D. this.variableName can be called from any static method in the",
                    "E. You can call the default constructor written by the compiler using",
                    "F. You can access a private constructor with the main() method in"
                ],
                "correct_answer_indexes": [
                    2,
                    5
                ],
                "correct_answer_explanation": "17. C, F. Calling an overloaded constructor with this() may be used only\nas the first line of a constructor, making options A and B incorrect.\nAccessing this.variableName can be performed from any instance\nmethod, constructor, or instance initializer, but not from a static\nmethod or static initializer. For this reason, option C is correct, and\noption D is incorrect. Option E is tricky. The default constructor is\nwritten by the compiler only if no user-defined constructors were\nprovided. And this() can only be called from a constructor in the\nsame class. Since there can be no user-defined constructors in the class\nif a default constructor was created, it is impossible for option E to be\ntrue. Since the main() method is in the same class, it can call private\nmethods in the class, making option F correct."
            },
            {
                "id": "82f28a7f-0199-1000-3c13-0000b8d5c4ec",
                "question": "18. Which statements about the following classes are correct? (Choose all\nthat apply.)\n\n1: public class Mammal {\n2: private void eat() {}\n3: protected static void drink() {}\n4: public Integer dance(String p) { return null; }\n5: }\n6: class Primate extends Mammal {\n7: public void eat(String p) {}\n8: }\n9: class Monkey extends Primate {\n10: public static void drink() throws RuntimeException\n{}\n11: public Number dance(CharSequence p) { return null; }\n12: public int eat(String p) {}\n13: }",
                "answer_options": [
                    "A. The eat() method in Mammal is correctly overridden on line 7.",
                    "B. The eat() method in Mammal is correctly overloaded on line 7.",
                    "C. The drink() method in Mammal is correctly overridden on line 10.",
                    "D. The drink() method in Mammal is correctly hidden on line 10.",
                    "E. The dance() method in Mammal is correctly overridden on line 11.",
                    "F. The dance() method in Mammal is correctly overloaded on line 11.",
                    "G. The eat() method in Primate is correctly hidden on line 12.",
                    "H. The eat() method in Primate is correctly overloaded on line 12."
                ],
                "correct_answer_indexes": [
                    3,
                    5
                ],
                "correct_answer_explanation": "18. D, F. The eat() method is private in the Mammal class. Since it is not\ninherited in the Primate class, it is neither overridden nor overloaded,\nmaking options A and B incorrect. The drink() method in Mammal is\ncorrectly hidden in the Monkey class, as the signature is the same and\nboth are static, making option D correct and option C incorrect. The\nversion in the Monkey class throws a new exception, but it is\nunchecked; therefore, it is allowed. The dance() method in Mammal is\ncorrectly overloaded in the Monkey class because the signatures are not\nthe same, making option E incorrect and option F correct. For methods\nto be overridden, the signatures must match exactly. Finally, line 12 is\nan invalid override and does not compile, as int is not covariant with\nvoid, making options G and H both incorrect."
            },
            {
                "id": "82f28a7f-0199-1000-238d-000044ca4fe5",
                "question": "19. What is the output of the following code?\n\n1: class Reptile {\n2: {System.out.print(\"A\");}\n3: public Reptile(int hatch) {}\n4: void layEggs() {\n5: System.out.print(\"Reptile\");\n6: } }\n7: public class Lizard extends Reptile {\n8: static {System.out.print(\"B\");}\n9: public Lizard(int hatch) {}\n10: public final void layEggs() {\n11: System.out.print(\"Lizard\");\n12: }\n13: public static void main(String[] args) {\n14: var reptile = new Lizard(1);\n15: reptile.layEggs();\n16: } }",
                "answer_options": [
                    "A. AALizard",
                    "B. BALizard",
                    "C. BLizardA",
                    "D. ALizard",
                    "E. The code will not compile because of line 3.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "19. F. The Reptile class defines a constructor, but it is not a no-argument\nconstructor. Therefore, the Lizard constructor must explicitly call\nsuper(), passing in an int value. For this reason, line 9 does not\ncompile, and option F is the correct answer. If the Lizard class were\ncorrected to call the appropriate super() constructor, then the program\nwould print BALizard at runtime, with the static initializer running\nfirst, followed by the instance initializer, and finally the method call\nusing the overridden method."
            },
            {
                "id": "82f28a7f-0199-1000-1cf9-0000fc8d25c0",
                "question": "20. Which statement about the following program is correct?\n\n1: class Bird {\n2: int feathers = 0;\n3: Bird(int x) { this.feathers = x; }\n4: Bird fly() {\n5: return new Bird(1);\n6: } }\n7: class Parrot extends Bird {\n8: protected Parrot(int y) { super(y); }\n9: protected Parrot fly() {\n10: return new Parrot(2);\n11: } }\n12: public class Macaw extends Parrot {\n13: public Macaw(int z) { super(z); }\n14: public Macaw fly() {\n15: return new Macaw(3);\n16: }\n17: public static void main(String… sing) {\n18: Bird p = new Macaw(4);\n19: System.out.print(((Parrot)p.fly()).feathers);\n20: } }",
                "answer_options": [
                    "A. One line contains a compiler error.",
                    "B. Two lines contain compiler errors.",
                    "C. Three lines contain compiler errors.",
                    "D. The code compiles but throws a ClassCastException at runtime.",
                    "E. The program compiles and prints 3.",
                    "F. The program compiles and prints 0."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "20. E. The program compiles and runs without issue, making options A\nthrough D incorrect. The fly() method is correctly overridden in each\nsubclass since the signature is the same, the access modifier is less\nrestrictive, and the return types are covariant. For covariance, Macaw is\na subtype of Parrot, which is a subtype of Bird, so overridden return\ntypes are valid. Likewise, the constructors are all implemented\nproperly, with explicit calls to the parent constructors as needed. Line\n19 calls the overridden version of fly() defined in the Macaw class, as\noverriding replaces the method regardless of the reference type. This\nresults in feathers being assigned a value of 3. The Macaw object is\nthen cast to Parrot, which is allowed because Macaw inherits Parrot.\nThe feathers variable is visible since it is defined in the Bird class,\nand line 19 prints 3, making option E the correct answer."
            },
            {
                "id": "82f28a7f-0199-1000-d28a-0000ce82125e",
                "question": "21. Which of the following are properties of immutable classes? (Choose\nall that apply.)",
                "answer_options": [
                    "A. The class can contain setter methods, provided they are marked",
                    "B. The class must not be able to be extended outside the class",
                    "C. The class may not contain any instance variables.",
                    "D. The class must be marked static.",
                    "E. The class may not contain any static variables.",
                    "F. The class may only contain private constructors.",
                    "G. The data for mutable instance variables may be read, provided"
                ],
                "correct_answer_indexes": [
                    1,
                    6
                ],
                "correct_answer_explanation": "21. B, G. Immutable objects do not include setter methods, making option\nA incorrect. An immutable class must be marked final or contain\nonly private constructors, so no subclass can extend it and make it\nmutable, making option B correct. Options C and E are incorrect, as\nimmutable classes can contain both instance and static variables.\nOption D is incorrect, as marking a class static is not a property of\nimmutable objects. Option F is incorrect. While an immutable class\nmay contain only private constructors, this is not a requirement.\nFinally, option G is correct. It is allowed for the caller to access data in\nmutable elements of an immutable object, provided they have no\\\nability to modify these elements."
            },
            {
                "id": "82f28a7f-0199-1000-5f6e-0000d9d9125f",
                "question": "22. What does the following program print?\n\n1: class Person {\n2: static String name;\n3: void setName(String q) { name = q; } }\n4: public class Child extends Person {\n5: static String name;\n6: void setName(String w) { name = w; }\n7: public static void main(String[] p) {\n8: final Child m = new Child();\n9: final Person t = m;\n10: m.name = \"Elysia\";\n11: t.name = \"Sophia\";\n12: m.setName(\"Webby\");\n13: t.setName(\"Olivia\");\n14: System.out.println(m.name + \" \" + t.name);\n15: } }",
                "answer_options": [
                    "A. Elysia Sophia",
                    "B. Webby Olivia",
                    "C. Olivia Olivia",
                    "D. Olivia Sophia",
                    "E. The code does not compile.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "22. D. The code compiles and runs without issue, making option E\nincorrect. The Child class overrides the setName() method and hides\nthe static name variable defined in the inherited Person class. Since\nvariables are only hidden, not overridden, there are two distinct name\nvariables accessible, depending on the location and reference type.\nLine 8 creates a Child instance, which is implicitly cast to a Person\nreference type on line 9. Line 10 uses the Child reference type,\nupdating Child.name to Elysia. Line 11 uses the Person reference\ntype, updating Person.name to Sophia. Lines 12 and 13 both call the\noverridden setName() instance method declared on line 6. This sets\nChild.name to Webby on line 12 and then to Olivia on line 13. The\nfinal values of Child.name and Person.name are Olivia and Sophia,\nrespectively, making option D the correct answer."
            },
            {
                "id": "82f28a7f-0199-1000-63b6-00009f41e648",
                "question": "23. What is the output of the following program?\n\n1: class Canine {\n2: public Canine(boolean t) { logger.append(\"a\"); }\n3: public Canine() { logger.append(\"q\"); }\n4:\n5: private StringBuilder logger = new StringBuilder();\n6: protected void print(String v) { logger.append(v); }\n7: protected String view() { return logger.toString();\n}\n8: }\n9:\n10: class Fox extends Canine {\n11: public Fox(long x) { print(\"p\"); }\n12: public Fox(String name) {\n13: this(2);\n14: print(\"z\");\n15: }\n16: }\n17:\n18: public class Fennec extends Fox {\n19: public Fennec(int e) {\n20: super(\"tails\");\n21: print(\"j\");\n22: }\n23: public Fennec(short f) {\n24: super(\"eevee\");\n25: print(\"m\");\n26: }\n27:\n28: public static void main(String… unused) {\n29: System.out.println(new Fennec(1).view());\n30: } }",
                "answer_options": [
                    "A. qpz",
                    "B. qpzj",
                    "C. jzpa",
                    "D. apj",
                    "E. apjm",
                    "F. The code does not compile.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "23. B. The program compiles, making option F incorrect. The constructors\nare called from the child class upward, but since each line of a\nconstructor is a call to another constructor, via this() or super(),\nthey are ultimately executed in a top-down manner. On line 29, the\nmain() method calls the Fennec() constructor declared on line 19.\nRemember, integer literals in Java are considered int by default. This\nconstructor calls the Fox() constructor defined on line 12, which in\nturn calls the overloaded Fox() constructor declared on line 11. Since\nthe constructor on line 11 does not explicitly call a parent constructor,\nthe compiler inserts a call to the no-argument super() constructor,\nwhich exists on line 3 of the Canine class. Line 3 is then executed,\nadding q to the output, and the compiler chain is unwound. Line 11\nthen executes, adding p, followed by line 14, adding z. Finally, line 21\nis executed, and j is added, resulting in a final value for logger of\nqpzj and making option B correct. For the exam, remember to follow\nconstructors from the lowest level upward to determine the correct\npathway, but then execute them from the top down using the\nestablished order."
            },
            {
                "id": "82f28a7f-0199-1000-ac96-000077dabddd",
                "question": "24. What is printed by the following program?\n\n1: class Antelope {\n2: public Antelope(int p) {\n3: System.out.print(\"4\");\n4: }\n5: { System.out.print(\"2\"); }\n6: static { System.out.print(\"1\"); }\n7: }\n8: public class Gazelle extends Antelope {\n9: public Gazelle(int p) {\n10: super(6);\n11: System.out.print(\"3\");\n12: }\n13: public static void main(String hopping[]) {\n14: new Gazelle(0);\n15: }\n16: static { System.out.print(\"8\"); }\n17: { System.out.print(\"9\"); }\n18: }",
                "answer_options": [
                    "A. 182640",
                    "B. 182943",
                    "C. 182493",
                    "D. 421389",
                    "E. The code does not compile.",
                    "F. The output cannot be determined until runtime."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "24. C. The code compiles and runs without issue, making options E and F\nincorrect. First, the class is initialized, starting with the superclass\nAntelope and then the subclass Gazelle. This involves invoking the\nstatic variable declarations and static initializers. The program first\nprints 1, followed by 8. Then we follow the constructor pathway from\nthe object created on line 14 upward, initializing each class instance\nusing a top-down approach. Within each class, the instance initializers\nare run, followed by the referenced constructors. The Antelope\ninstance is initialized, printing 24, followed by the Gazelle instance,\nprinting 93. The final output is 182493, making option C the correct\nanswer."
            },
            {
                "id": "82f28a7f-0199-1000-5e9a-000011bf0035",
                "question": "25. Which of the following are true about a concrete class? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. A concrete class can be declared as abstract.",
                    "B. A concrete class must implement all inherited abstract methods.",
                    "C. A concrete class can be marked as final.",
                    "D. A concrete class must be immutable.",
                    "E. A concrete method that implements an abstract method must"
                ],
                "correct_answer_indexes": [
                    1,
                    2
                ],
                "correct_answer_explanation": "25. B, C. Concrete classes are, by definition, not abstract, so option A is\nincorrect. A concrete class must implement all inherited abstract\nmethods, so option B is correct. Concrete classes can be optionally\nmarked final, so option C is correct. Option D is incorrect; concrete\nclasses need not be immutable. A concrete subclass only needs to\noverride the inherited abstract method, not match the declaration\nexactly. For example, a covariant return type can be used. For this\nreason, option E is incorrect."
            },
            {
                "id": "82f28a7f-0199-1000-d737-0000c7d7fcce",
                "question": "26. What is the output of the following code?\n\n4: public abstract class Whale {\n5: public abstract void dive();\n6: public static void main(String[] args) {\n7: Whale whale = new Orca();\n8: whale.dive(3);\n9: }\n10: }\n11: class Orca extends Whale {\n12: static public int MAX = 3;\n13: public void dive() {\n14: System.out.println(\"Orca diving\");\n15: }\n16: public void dive(int… depth) {\n17: System.out.println(\"Orca diving deeper \"+MAX);\n18: } }",
                "answer_options": [
                    "A. Orca diving",
                    "B. Orca diving deeper 3",
                    "C. The code will not compile because of line 4.",
                    "D. The code will not compile because of line 8.",
                    "E. The code will not compile because of line 11.",
                    "F. The code will not compile because of line 12.",
                    "G. The code will not compile because of line 17.",
                    "H. None of the above."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "26. D. The classes are structured correctly, but the body of the main()\nmethod contains a compiler error. The Orca object is implicitly cast to\na Whale reference on line 7. This is permitted because Orca is a\nsubclass of Whale. By performing the cast, the whale reference on line\n8 does not have access to the dive(int… depth) method. For this\nreason, line 8 does not compile, making option D correct."
            },
            {
                "id": "82f28a7f-0199-1000-b447-0000e2888e4c",
                "question": "1. Which of the following are valid record declarations? (Choose all that\napply.)\n\npublic record Iguana(int age) {\nprivate static final int age = 10; \n}\npublic final record Gecko() {}\npublic abstract record Chameleon() {\nprivate static String name; \n}\npublic record BeardedDragon(boolean fun) {\n@Override public boolean fun() { return false; } \n}\npublic record Reptile(long size) {\npublic Reptile {\nif(size == 1) throw new IllegalArgumentException();\n} }\npublic record Newt(double age) extends Reptile {\npublic Newt(double age) {\nage = this.age % 2 == 0 ? 5 : 10;\n} }",
                "answer_options": [
                    "A. Iguana",
                    "B. Gecko",
                    "C. Chameleon",
                    "D. BeardedDragon",
                    "E. Reptile",
                    "F. Newt",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    3,
                    4
                ],
                "correct_answer_explanation": "1. B, D, E. Iguana does not compile, as it declares a static field with the\nsame name as an instance field. Records are implicitly final and\ncannot be marked abstract, which is why Gecko compiles and\nChameleon does not, making option B correct. Notice in Gecko that\nrecords are not required to declare any fields. BeardedDragon also\ncompiles, as records may override any accessor methods, making\noption D correct. Reptile compiles as it contains a valid compact\nconstructor, making option E correct. Newt does not compile because it\ncannot extend another record. It also does not compile because the\ncompact constructor tries to read this.age, which is not permitted."
            },
            {
                "id": "82f28a80-0199-1000-8486-0000c97089f9",
                "question": "2. Which of the following statements can be inserted in the blank line so\nthat the code will compile successfully? (Choose all that apply.)\n\ninterface CanHop {}\npublic class Frog implements CanHop {\npublic static void main(String[] args) {\n____________ frog = new TurtleFrog();\n}\n}\nclass BrazilianHornedFrog extends Frog {}\nclass TurtleFrog extends Frog {}",
                "answer_options": [
                    "A. Frog",
                    "B. TurtleFrog",
                    "C. BrazilianHornedFrog",
                    "D. CanHop",
                    "E. var",
                    "F. Long",
                    "G. None of the above; the code contains a compilation error."
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    3,
                    4
                ],
                "correct_answer_explanation": "2. A, B, D, E. The code compiles without issue, so option G is incorrect.\nThe blank can be filled with any class or interface that is a supertype\nof TurtleFrog. Option A is the direct superclass of TurtleFrog, and\noption B is the same class, so both are correct. BrazilianHornedFrog\nis not a superclass of TurtleFrog, so option C is incorrect. TurtleFrog\ninherits the CanHop interface, so option D is correct. Option E is also\ncorrect, as var is permitted when the type is known. Finally, Long is an\nunrelated class that is not a superclass of TurtleFrog and is therefore\nincorrect."
            },
            {
                "id": "82f28a80-0199-1000-d8f2-0000a7aa1200",
                "question": "3. What is the result of the following program?\n\n11: public class Favorites {\n12: enum Flavors {\n13: VANILLA, CHOCOLATE, STRAWBERRY\n14: public Flavors() {}\n15: }\n16: public static void main(String[] args) {\n17: for(final var e : Flavors.values())\n18: System.out.print((e.ordinal() % 2) + \" \");\n19: } }",
                "answer_options": [
                    "A. 0 1 0",
                    "B. 1 0 1",
                    "C. Exactly one line of code does not compile.",
                    "D. More than one line of code does not compile.",
                    "E. The code compiles but produces an exception at runtime.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "3. D. When an enum contains only a list of values, the semicolon (;) after\nthe list is optional. When an enum contains any other members, such\nas a constructor or variable, the semicolon is required. For this reason,\nline 13 does not compile. Line 14 also does not compile, as enum\nconstructors are implicitly private and cannot be declared as public\nor protected. For this reason, option D is correct. If these two issues\nwere corrected, then the program would print 0 1 0 at runtime."
            },
            {
                "id": "82f28a80-0199-1000-91b6-00000cb81100",
                "question": "4. What is the output of the following program?\n\npublic sealed class ArmoredAnimal permits Armadillo {\npublic ArmoredAnimal(int size) {}\n@Override public String toString() { return \"Strong\"; }\npublic static void main(String[] a) {\nvar c = new Armadillo(10, null);\nSystem.out.println(c);\n}\n}\nclass Armadillo extends ArmoredAnimal {\n@Override public String toString() { return \"Cute\"; }\npublic Armadillo(int size, String name) {\nsuper(size);\n}\n}",
                "answer_options": [
                    "A. Strong",
                    "B. Cute",
                    "C. The program does not compile.",
                    "D. The code compiles but produces an exception at runtime.",
                    "E. None of the above."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "4. C. A class extending a sealed class must be marked final, sealed, or\nnon-sealed. Since Armadillo is missing a modifier, the code does not\ncompile, and option C is correct."
            },
            {
                "id": "82f28a80-0199-1000-43da-00001aaaec62",
                "question": "5. Which statement about the following program is correct?\n\n1: interface HasExoskeleton {\n2: double size = 2.0f;\n3: abstract int getNumberOfSections();\n4: }\n5: abstract class Insect implements HasExoskeleton {\n6: abstract int getNumberOfLegs();\n7: }\n8: public class Beetle extends Insect {\n9: int getNumberOfLegs() { return 6; }\n10: int getNumberOfSections(int count) { return 1; }\n11: }",
                "answer_options": [
                    "A. It compiles without issue.",
                    "B. The code will produce a ClassCastException if called at",
                    "C. The code will not compile because of line 2.",
                    "D. The code will not compile because of line 5.",
                    "E. The code will not compile because of line 8.",
                    "F. The code will not compile because of line 10."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "5. E. First, the declarations of HasExoskeleton and Insect are correct\nand do not contain any errors, making options C and D incorrect. The\nconcrete class Beetle extends Insect and inherits two abstract\nmethods, getNumberOfSections() and getNumberOfLegs(). The\nBeetle class includes an overloaded version of\ngetNumberOfSections() that takes an int value. The method\ndeclaration is valid, making option F incorrect, although it does not\nsatisfy the abstract method requirement inherited from\nHasExoskeleton. For this reason, only one of the two abstract methods\nis properly overridden. The Beetle class therefore does not compile,\nand option E is correct."
            },
            {
                "id": "82f28a80-0199-1000-4e7d-000026562a7d",
                "question": "6. Which statements about the following program are correct? (Choose\nall that apply.)\n\n1: public abstract interface Herbivore {\n2: int amount = 10;\n3: public void eatGrass();\n4: public abstract int chew() { return 13; }\n5: }\n6:\n7: abstract class IsAPlant extends Herbivore {\n8: Object eatGrass(int season) { return null; }\n9: }",
                "answer_options": [
                    "A. It compiles and runs without issue.",
                    "B. The code will not compile because of line 1.",
                    "C. The code will not compile because of line 2.",
                    "D. The code will not compile because of line 4.",
                    "E. The code will not compile because of line 7.",
                    "F. The code will not compile because line 8 contains an invalid"
                ],
                "correct_answer_indexes": [
                    3,
                    4
                ],
                "correct_answer_explanation": "6. D, E. Line 4 does not compile, since an abstract method cannot\ninclude a body. Line 7 also does not compile because the wrong\nkeyword is used. A class implements an interface; it does not extend it.\nFor these reasons, options D and E are correct."
            },
            {
                "id": "82f28a80-0199-1000-720e-0000f8040c9f",
                "question": "7. What is the output of the following program?\n\n1: interface Aquatic {\n2: int getNumOfGills(int p);\n3: }\n4: public class ClownFish implements Aquatic {\n5: String getNumOfGills() { return \"14\"; }\n6: int getNumOfGills(int input) { return 15; }\n7: public static void main(String[] args) {\n8: System.out.println(new\nClownFish().getNumOfGills(-1));\n9: } }",
                "answer_options": [
                    "A. 14",
                    "B. 15",
                    "C. The code will not compile because of line 4.",
                    "D. The code will not compile because of line 5.",
                    "E. The code will not compile because of line 6.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "7. E. The inherited interface method getNumOfGills(int) is implicitly\npublic; therefore, it must be declared public in any concrete class that\nimplements the interface. Since the method uses the package (default)\nmodifier in the ClownFish class, line 6 does not compile, making\noption E the correct answer. If the method declaration were corrected\nto include public on line 6, then the program would compile and print\n15 at runtime, and option B would be the correct answer."
            },
            {
                "id": "82f28a80-0199-1000-4000-000030ed16d4",
                "question": "8. Given the following, select the statements that can be inserted into the\nblank line so that the code will compile and print true at runtime?\n(Choose all that apply.)\n\nrecord Walrus(List<String> diet) {}\nrecord Exhibit(Walrus animal, String location) {}\nvar e = new Exhibit(new Walrus(List.of(\"Wally\")), \"Artic\");\nSystem.out.print(e instanceof _____________);",
                "answer_options": [
                    "A. Exhibit(Walrus(List<Integer> z), Object a)",
                    "B. Exhibit(Walrus(List m), Object n)",
                    "C. Object w && w.animal().diet().size() == 0",
                    "D. Exhibit(Walrus(var i), var i)",
                    "E. Exhibit(var p, var q)",
                    "F. Exhibit(List<?> g, var h)",
                    "G. Exhibit(var x, CharSequence y)",
                    "H. Exhibit(Walrus(null), var v)",
                    "I. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    4,
                    6
                ],
                "correct_answer_explanation": "8. B, E, G. Options A and F do not compile because they are not\ncompatible with List<String>. Option C does not compile because\nthe reference type of w is Object, which doesn’t have an animal()\nmethod. Option D does not compile because the variable i is used\ntwice in the same pattern matching statement. Option H does not\ncompile because you can’t use null in a pattern matching statement.\nOptions B, E, and G correctly compile and print true at runtime."
            },
            {
                "id": "82f28a80-0199-1000-b353-0000c79ce2ee",
                "question": "9. Which of the following statements can be inserted in the blank so that\nthe code will compile successfully? (Choose all that apply.)\n\nabstract class Snake {}\nclass Cobra extends Snake {}\nclass GardenSnake extends Cobra {}\npublic class SnakeHandler {\nprivate Snake snakey;\npublic void setSnake(Snake mySnake) { this.snakey =\nmySnake; }\npublic static void main(String[] args) {\nnew SnakeHandler().setSnake(_____________);\n} }",
                "answer_options": [
                    "A. new Cobra()",
                    "B. new Snake()",
                    "C. new Object()",
                    "D. new String(\"Snake\")",
                    "E. new GardenSnake()",
                    "F. null",
                    "G. None of the above. The class does not compile, regardless of the"
                ],
                "correct_answer_indexes": [
                    0,
                    4,
                    5
                ],
                "correct_answer_explanation": "9. A, E, F. The setSnake() method requires an instance of Snake. Cobra\nis a direct subclass, while GardenSnake is an indirect subclass. For\nthese reasons, options A and E are correct. Option B is incorrect\nbecause Snake is abstract and requires a concrete subclass for\ninstantiation. Option C is incorrect because Object is a supertype of\nSnake, not a subtype. Option D is incorrect as String is an unrelated\nclass and does not inherit Snake. Finally, a null value can always be\npassed as an object value, regardless of type, so option F is also\ncorrect."
            },
            {
                "id": "82f28a80-0199-1000-708c-00009a965b06",
                "question": "10. What types can be inserted in the blanks on the lines marked X and Z\nthat allow the code to compile? (Choose all that apply.)\n\ninterface Walk { private static List move() { return null;\n} }\ninterface Run extends Walk { public ArrayList move(); }\nclass Leopard implements Walk {\npublic ___________ move() { // X\nreturn null;\n}\n}\nclass Panther implements Run {\npublic move(___________) { // Z\nreturn null;\n}\n}",
                "answer_options": [
                    "A. Integer on the line marked X",
                    "B. ArrayList on the line marked X",
                    "C. List on the line marked X",
                    "D. List on the line marked Z",
                    "E. ArrayList on the line marked Z",
                    "F. None of the above, since the Run interface does not compile.",
                    "G. Does not compile for a different reason."
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    2,
                    4
                ],
                "correct_answer_explanation": "10. A, B, C, E. Walk declares a private method that is not inherited in any\nof its subtypes. For this reason, any valid class is supported on line X,\nmaking options A, B, and C correct. Line Z is more restrictive, with\nonly ArrayList or subtypes of ArrayList supported, making option E\ncorrect."
            },
            {
                "id": "82f28a80-0199-1000-2b9f-00002d554117",
                "question": "11. What is the result of compiling and executing the following code?\n\n1: public class Movie {\n2: private int butter = 5;\n3: private Movie() {}\n4: protected class Popcorn {\n5: private Popcorn() {}\n6: public static int butter = 10;\n7: public void startMovie() {\n8: System.out.println(butter);\n9: }\n10: }\n11: public static void main(String[] args) {\n12: var movie = new Movie();\n13: Movie.Popcorn in = new Movie().new Popcorn();\n14: in.startMovie();\n15: } }",
                "answer_options": [
                    "A. The output is 5.",
                    "B. The output is 10.",
                    "C. Line 6 generates a compiler error.",
                    "D. Line 12 generates a compiler error.",
                    "E. Line 13 generates a compiler error.",
                    "F. The code compiles but produces an exception at runtime."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "11. B. Inner classes can contain static variables, so the code compiles.\nRemember that private constructors can be used by any methods\nwithin the outer class. The butter reference on line 8 refers to the\ninner class variable defined on line 6, with the output being 10 at\nruntime, and making option B correct."
            },
            {
                "id": "82f28a80-0199-1000-b559-000029da4e9f",
                "question": "12. Which variables or members are accessible from within the hiss()\nmethod? (Choose all that apply.)\n\n13: public class BoaConstrictor {\n14:   private Body body;\n15:   BoaConstrictor(Body b) { this.body = b; }\n16:   private long tail = 10;\n17:   record Body(int stripes) {\n18:     private static int counter = 0;\n19:     int counter() { return counter; }\n20:     Body {\n21:       stripes = stripes + counter++;\n22:     }\n23:   private void hiss() {} } }",
                "answer_options": [
                    "A. counter()",
                    "B. tail",
                    "C. body",
                    "D. stripes()",
                    "E. stripes",
                    "F. counter",
                    "G. Line 15 does not compile.",
                    "H. Line 17 does not compile.",
                    "I. Lines 20–22 do not compile."
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    4,
                    5
                ],
                "correct_answer_explanation": "12. A, D, E, F. The code compiles, making options G, H, and I incorrect.\nThe hiss() method is an instance member, so it can access any visible\nstatic members inside itself or the outer class, making option F\ncorrect. It can also access instance variables and methods within the\nrecord, making options A, D, and E correct. Because nested records\nare inherently static, it cannot access body or tail, which are\ninstance members of the outer class, making options B and C incorrect."
            },
            {
                "id": "82f28a80-0199-1000-4421-0000d2147ccb",
                "question": "13. What is the result of the following program?\n\npublic class Weather {\nenum Seasons {\nWINTER, SPRING, SUMMER, FALL\n}\npublic static void main(String[] args) {\nSeasons v = null;\nswitch (v) {\ncase Seasons.SPRING -> System.out.print(\"s\");\ncase Seasons.WINTER -> System.out.print(\"w\");\ncase Seasons.SUMMER -> System.out.print(\"m\");\ndefault -> System.out.println(\"missing data\"); }\n} }\n\nA. s\nB. w\nC. m\nD. missing data\nE. Exactly one line of code does not compile.\nF. More than one line of code does not compile.\nG. The code compiles but produces an exception at runtime.\n\n13. G. The code compiles without issue, so options E and F are incorrect.\nIt prints a NullPointerException at runtime, making option G\ncorrect.\n\n14. Which statements about sealed classes are correct? (Choose all that\napply.)",
                "answer_options": [
                    "A. A sealed interface restricts which subinterfaces may extend it.",
                    "B. A sealed class cannot be indirectly extended by a class that is not",
                    "C. A sealed class can be extended by an abstract class.",
                    "D. A sealed class can be extended by a subclass that uses the",
                    "E. A sealed interface restricts which subclasses may implement it.",
                    "F. A sealed class cannot contain any nested subclasses.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    4
                ],
                "correct_answer_explanation": "14. A, C, E. A sealed interface restricts which interfaces may extend it, or\nwhich classes may implement it, making options A and E correct.\nOption B is incorrect. For example, a non-sealed subclass allows\nclasses not listed in the permits clause to indirectly extend the sealed\nclass. Option C is correct. While a sealed class is commonly extended\nby a subclass marked final, it can also be extended by a sealed or\nnon-sealed subclass marked abstract. Option D is incorrect, as the\nmodifier is non-sealed, not nonsealed. Finally, option F is incorrect,\nas sealed classes can contain nested subclasses."
            },
            {
                "id": "82f28a80-0199-1000-3ad8-00004effa4d3",
                "question": "15. Which line allows the code to print Not scared at runtime?\n\npublic class Ghost {\npublic static void boo() {\nSystem.out.println(\"Not scared\");\n}\nprotected final class Spirit {\npublic void boo() {\nSystem.out.println(\"Booo!!!\");\n}\n}\npublic static void main(String… haunt) {\nvar g = new Ghost().new Spirit() {};\n_______________________________;\n} }",
                "answer_options": [
                    "A. g.boo()",
                    "B. g.super.boo()",
                    "C. new Ghost().boo()",
                    "D. g.Ghost.boo()",
                    "E. new Spirit().boo()",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "15. F. Trick question—the code does not compile! For this reason, option\nF is correct. The Spirit class is marked final, so it cannot be\nextended. The main() method uses an anonymous class that inherits\nfrom Spirit, which is not allowed. If Spirit were not marked final,\nthen option C would be correct. Option A would print Booo!!!, while\noptions B, D, and E would not compile for various reasons."
            },
            {
                "id": "82f28a80-0199-1000-7ae9-0000f35cce4c",
                "question": "16. The following code appears in a file named Ostrich.java. What is the\nresult of compiling the source file?\n\n1: public class Ostrich {\n2: private int count;\n3: static class OstrichWrangler {\n4: public int stampede() {\n5: return count;\n6: } } }",
                "answer_options": [
                    "A. The code compiles successfully, and one bytecode file is",
                    "B. The code compiles successfully, and two bytecode files are",
                    "C. The code compiles successfully, and two bytecode files are",
                    "D. A compiler error occurs on line 3.",
                    "E. A compiler error occurs on line 5."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "16. E. The OstrichWrangler class is a static nested class; therefore, it\ncannot access the instance member count. For this reason, line 5 does\nnot compile, and option E is correct."
            },
            {
                "id": "82f28a80-0199-1000-ce0a-00003ee2f18f",
                "question": "17. Which lines of the following interface declarations do not compile?\n(Choose all that apply.)\n\n1: public interface Omnivore {\n2: int amount = 10;\n3: static boolean gather = true;\n4: static void eatGrass() {}\n5: int findMore() { return 2; }\n6: default float rest() { return 2; }\n7: protected int chew() { return 13; }\n8: private static void eatLeaves() {}\n9: }",
                "answer_options": [
                    "A. All of the lines compile without issue.",
                    "B. Line 2.",
                    "C. Line 3.",
                    "D. Line 4.",
                    "E. Line 5.",
                    "F. Line 6.",
                    "G. Line 7.",
                    "H. Line 8."
                ],
                "correct_answer_indexes": [
                    4,
                    6
                ],
                "correct_answer_explanation": "17. E, G. Lines 2 and 3 compile with interface variables implicitly public,\nstatic, and final. Line 4 also compiles, as static methods are\nimplicitly public. Line 5 does not compile, making option E correct.\nNon-static interface methods with a body must be explicitly marked\nprivate or default. Line 6 compiles, with the public modifier being\nadded by the compiler. Line 7 does not compile, as interfaces do not\nhave protected members, making option G correct. Finally, line 8\ncompiles without issue."
            },
            {
                "id": "82f28a81-0199-1000-639d-000071b55e1a",
                "question": "18. What is printed by the following program?\n\npublic class Deer {\nenum Food {APPLES, BERRIES, GRASS}\nprotected class Diet {\nprivate Food getFavorite() {\nreturn Food.BERRIES;\n}\n}\npublic static void main(String[] seasons) {\nSystem.out.print(switch(new Diet().getFavorite()) {\ncase APPLES -> \"a\";\ncase BERRIES -> \"b\";\ndefault -> \"c\";\n});\n} }",
                "answer_options": [
                    "A. a",
                    "B. b",
                    "C. c",
                    "D. The code declaration of the Diet class does not compile.",
                    "E. The main() method does not compile.",
                    "F. The code compiles but produces an exception at runtime.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "18. E. Diet is an inner class, which requires an instance of Deer to\ninstantiate. Since the main() method is static, there is no such\ninstance. Therefore, the main() method does not compile, and option E\nis correct. If a reference to Deer were used, such as calling new\nDeer().new Diet(), then the code would compile and print b at\nruntime."
            },
            {
                "id": "82f28a81-0199-1000-4f7d-0000ed9a1993",
                "question": "19. Which of the following is printed by the Bear program?\n\npublic class Bear {\nenum FOOD {\nBERRIES, INSECTS {\npublic boolean isHealthy() { return true; }},\nFISH, ROOTS, COOKIES, HONEY;\npublic abstract boolean isHealthy();\n}\npublic static void main(String[] args) {\nSystem.out.print(FOOD.INSECTS);\nSystem.out.print(FOOD.INSECTS.ordinal());\nSystem.out.print(FOOD.INSECTS.isHealthy());\nSystem.out.print(FOOD.COOKIES.isHealthy());\n} }",
                "answer_options": [
                    "A. insects",
                    "B. Insects",
                    "C. 0",
                    "D. 1",
                    "E. false",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "19. F. The isHealthy() method is marked abstract in the enum;\ntherefore, it must be implemented in each enum value declaration.\nSince only INSECTS implements it, the code does not compile, making\noption F correct."
            },
            {
                "id": "82f28a81-0199-1000-78e9-000000f125de",
                "question": "20. What is the output of this code?\n\n13: record Gorilla(int x, Double y) {\n14: Gorilla {}\n15: Gorilla() { this(1,2.0); }\n16: }\n17: record Family(Gorilla parent1, Gorilla parent2) {}\n18:\n19: var family = new Family(\n20: new Gorilla(1, null), new Gorilla(0, 1.2));\n21: System.out.print(switch (family) {\n22: case Family(var a, var b) -> \"1\";\n23: case Family(Gorilla c, Gorilla (int d, double e)) ->\n\"2\";\n24: case Family(Gorilla (int f, Double g), var h) ->\n\"3\";\n25: case Family(Gorilla i, Gorilla (int j, Double k)) ->\n\"4\";\n26: case Family(Object m, Object n) -> \"5\";\n27: case null -> \"6\";\n28: default -> \"7\";\n29: });",
                "answer_options": [
                    "A. 1",
                    "B. 2",
                    "C. 3",
                    "D. 4",
                    "E. 5",
                    "F. 6",
                    "G. 7",
                    "H. None of the above"
                ],
                "correct_answer_indexes": [
                    7
                ],
                "correct_answer_explanation": "20. H. The record declarations compile but the switch expression does\nnot, making option H correct. First, the second case statement does not\ncompile, as double is not compatible with Double. Next, the pattern\nmatching case statement on line 22 dominates the ones on lines 23–25.\nIf three of them were to be removed (including the second one), then\nthe code would compile and print the value associated with the\nremaining one."
            },
            {
                "id": "82f28a81-0199-1000-a323-00003c7989b1",
                "question": "21. Given the following record declaration, which line of code can fill in\nthe blank and allow the code to compile?\n\npublic record RabbitFood(int size, String brand, LocalDate\nexpires) {\npublic static int MAX_STORAGE = 100;\npublic RabbitFood() {\n__________________________;\n}\n}",
                "answer_options": [
                    "A. size = MAX_STORAGE",
                    "B. this.size = 10",
                    "C. if(expires.isAfter(LocalDate.now())) throw new",
                    "D. if(brand==null) super.brand = \"Unknown\"",
                    "E. throw new RuntimeException()",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "21. F. The record defines an overloaded constructor using parentheses, not\na compact one. For this reason, the first line must be a call to another\nconstructor, such as this(500, \"Acme\", LocalDate.now()). For this\nreason, the code does not compile and option F is correct."
            },
            {
                "id": "82f28a81-0199-1000-603d-00000d1d744f",
                "question": "22. Which of the following can be inserted in the rest() method? (Choose\nall that apply.)\n\npublic class Lion {\nclass Cub {}\nstatic class Den {}\nstatic void rest() {\n________________;\n} }",
                "answer_options": [
                    "A. Cub a = Lion.new Cub()",
                    "B. Lion.Cub b = new Lion().Cub()",
                    "C. Lion.Cub c = new Lion().new Cub()",
                    "D. var d = new Den()",
                    "E. var e = Lion.new Cub()",
                    "F. Lion.Den f = Lion.new Den()",
                    "G. Lion.Den g = new Lion.Den()",
                    "H. var h = new Cub()```"
                ],
                "correct_answer_indexes": [
                    2,
                    3,
                    6
                ],
                "correct_answer_explanation": "22. C, D, G. Option C correctly creates an instance of an inner class Cub\nusing an instance of the outer class Lion. Options A, B, E, and H use\nincorrect syntax for creating an instance of the Cub class. Options D\nand G correctly create an instance of the static nested Den class,\nwhich does not require an instance of Lion, while option F uses invalid\nsyntax."
            },
            {
                "id": "82f28a81-0199-1000-9818-0000de92a108",
                "question": "23. Given the following program, what can be inserted into the blank line\nthat would allow it to print Swim! at runtime?\n\ninterface Swim {\ndefault void perform() { System.out.print(\"Swim!\"); }\n}\ninterface Dance {\ndefault void perform() { System.out.print(\"Dance!\"); }\n}\npublic class Penguin implements Swim, Dance {\npublic void perform() { System.out.print(\"Smile!\"); }\nprivate void doShow() {\n____________________;\n}\npublic static void main(String[] eggs) {\nnew Penguin().doShow();\n} }",
                "answer_options": [
                    "A. super.perform()",
                    "B. Swim.perform()",
                    "C. super.Swim.perform()",
                    "D. Swim.super.perform()",
                    "E. The code does not compile regardless of what is inserted into the",
                    "F. The code compiles, but due to polymorphism, it is not possible to"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "23. D. First, if a class or interface inherits two interfaces containing\ndefault methods with the same signature, it must override the method\nwith its own implementation. The Penguin class does this correctly, so\noption E is incorrect. The way to access an inherited default method\nis by using the syntax Swim.super.perform(), making option D\ncorrect. We agree that the syntax is bizarre, but you need to learn it.\nOptions A, B, and C are incorrect and result in compiler errors."
            },
            {
                "id": "82f28a81-0199-1000-a0e6-00007c5a6f80",
                "question": "24. Which lines of the following interface do not compile? (Choose all that\napply.)\n\n1: public interface BigCat {\n2: abstract String getName();\n3: static int hunt() { getName(); return 5; }\n4: default void climb() { rest(); }\n5: private void roar() { getName(); climb(); hunt(); }\n6: private static boolean sneak() { roar(); return true;\n}\n7: private int rest() { return 2; };\n8: }",
                "answer_options": [
                    "A. Line 2",
                    "B. Line 3",
                    "C. Line 4",
                    "D. Line 5",
                    "E. Line 6",
                    "F. Line 7",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    4
                ],
                "correct_answer_explanation": "24. B, E. Line 3 does not compile because the static method hunt()\ncannot access an abstract instance method getName(), making option\nB correct. Line 6 does not compile because the private static\nmethod sneak() cannot access the private instance method roar(),\nmaking option E correct. The rest of the lines compile without issue."
            },
            {
                "id": "82f28a81-0199-1000-4dca-000066461f50",
                "question": "25. What does the following program print?\n\n1: public class Zebra {\n2: private int x = 24;\n3: public int hunt() {\n4: String message = \"x is \";\n5: abstract class Stripes {\n6: private int x = 0;\n7: public void print() {\n8: System.out.print(message + Zebra.this.x);\n9: }\n10: }\n11: var s = new Stripes() {};\n12: s.print();\n13: return x;\n14: }\n15: public static void main(String[] args) {\n16: new Zebra().hunt();\n17: } }",
                "answer_options": [
                    "A. x is 0",
                    "B. x is 24",
                    "C. Line 6 generates a compiler error.",
                    "D. Line 8 generates a compiler error.",
                    "E. Line 11 generates a compiler error.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "25. B. Zebra.this.x is the correct way to refer to x in the Zebra class.\nLine 5 defines an abstract local class within a method, while line 11\ndefines a concrete anonymous class that extends the Stripes class.\nThe code compiles without issue and prints x is 24 at runtime,\nmaking option B the correct answer."
            },
            {
                "id": "82f28a81-0199-1000-4ccf-00009a9f666f",
                "question": "26. What is the output of the following program?\n\n20: public enum Animals {\n21: MAMMAL(List.of(2,4)),\n22: INVERTEBRATE(List.of(2, 4, 6, 8, 100)),\n23: BIRD(null) {\n24: public int stand() {\n25: return legs.get(0) + 4;\n26: }\n27: };\n28: List<Integer> legs;\n29: Animals(List<Integer> legs) {\n30: this.legs = legs;\n31: }\n32: public int stand() { return legs.get(0); }\n33: public static void main(String[] a) {\n34: Animals.BIRD.legs = List.of(-1);\n35: System.out.println(Animals.BIRD.stand());\n36: } }",
                "answer_options": [
                    "A. null",
                    "B. -1",
                    "C. 3",
                    "D. 4",
                    "E. Compiler error on lines 23.",
                    "F. Compiler error on lines 24.",
                    "G. Compiler error on line 34.",
                    "H. The code compiles but produces a NullPointerException at",
                    "I. None of the above."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "26. C. The code compiles and runs without issue. The stand() method is\noverridden on line 24, so the code prints 3 (-1 + 4) at runtime, making\noption C correct. Note that unlike records, enums can have mutable\nmembers, so the modification of legs on line 34 is permitted (albeit\nnot recommended!)."
            },
            {
                "id": "82f28a81-0199-1000-02e2-0000c9ad7cd0",
                "question": "27. Assuming a record is defined with at least one field, which\ncomponents does the compiler always insert, each of which may be\noverridden or redeclared? (Choose all that apply.)",
                "answer_options": [
                    "A. A no-argument constructor",
                    "B. An accessor method for each field",
                    "C. The toString() method",
                    "D. The equals() method",
                    "E. A mutator method for each field",
                    "F. A sort method for each field",
                    "G. The hashCode() method"
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    3,
                    6
                ],
                "correct_answer_explanation": "27. B, C, D, G. The compiler inserts an accessor for each field, a\nconstructor containing all of the fields in the order they are declared,\nand useful implementations of equals(), hashCode(), and\ntoString(), making options B, C, D, and G correct. Option A is\nincorrect, as the compiler would only insert a no-argument constructor\nif the record had no fields. Option E is incorrect, as records are\nimmutable. Option F is also incorrect and not a property of records."
            },
            {
                "id": "82f28a81-0199-1000-034f-0000017f46cd",
                "question": "28. Which of the following classes and interfaces do not compile? (Choose\nall that apply.)\n\npublic abstract class Camel { void travel(); }\npublic interface EatsGrass { private abstract int chew(); }\npublic abstract class Elephant {\nabstract private class SleepsAlot {\nabstract int sleep();\n} }\npublic class Eagle { abstract soar(); }\npublic interface Spider { default void crawl() {} }",
                "answer_options": [
                    "A. Camel",
                    "B. EatsGrass",
                    "C. Elephant",
                    "D. Eagle",
                    "E. Spider"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    3
                ],
                "correct_answer_explanation": "28. A, B, D. Camel does not compile because the travel() method does\nnot declare a body, nor is it marked abstract, making option A\ncorrect. EatsGrass also does not compile because an interface method\ncannot be marked both private and abstract, making option B\ncorrect. Finally, Eagle does not compile because it declares an abstract\nmethod soar() in a concrete class, making option D correct. The other\nclasses compile without issue."
            },
            {
                "id": "82f28a81-0199-1000-4963-0000494d8610",
                "question": "29. How many lines of the following program contain a compilation error?\n\n1: class Primate {\n2: protected int age = 2;\n3: { age = 1; }\n4: public Primate() {\n5: this().age = 3;\n6: }\n7: }\n8: public class Orangutan {\n9: protected int age = 4;\n10: { age = 5; }\n11: public Orangutan() {\n12: this().age = 6;\n13: }\n14: public static void main(String[] bananas) {\n15: final Primate x = (Primate)new Orangutan();\n16: System.out.println(x.age);\n17: }\n18: }",
                "answer_options": [
                    "A. None, and the program prints 1 at runtime.",
                    "B. None, and the program prints 3 at runtime.",
                    "C. None, but it causes a ClassCastException at runtime.",
                    "D. 1",
                    "E. 2",
                    "F. 3",
                    "G. 4"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "29. F. The code does not compile, so options A through options C are\nincorrect. Both lines 5 and 12 do not compile, as this() is used\ninstead of this. Remember, this() refers to calling a constructor,\nwhereas this is a reference to the current instance. Next, the compiler\ndoes not allow casting to an unrelated class type. Since Orangutan is\nnot a subclass of Primate, the cast on line 15 is invalid, and the code\ndoes not compile. Due to these three lines containing compilation\nerrors, option F is the correct answer."
            },
            {
                "id": "82f28a81-0199-1000-a335-0000b5ddaf43",
                "question": "30. Assuming the following classes are declared as top-level types in the\nsame file, which classes contain compiler errors? (Choose all that\napply.)\n\nsealed class Bird {\npublic final class Flamingo extends Bird {}\n}\nsealed class Monkey {}\nclass EmperorTamarin extends Monkey {}\nnon-sealed class Mandrill extends Monkey {}\nsealed class Friendly extends Mandrill permits Silly {}\nfinal class Silly {}",
                "answer_options": [
                    "A. Bird",
                    "B. Monkey",
                    "C. EmperorTamarin",
                    "D. Mandrill",
                    "E. Friendly",
                    "F. Silly",
                    "G. All of the classes compile without issue."
                ],
                "correct_answer_indexes": [
                    2,
                    4
                ],
                "correct_answer_explanation": "30. C, E. Bird and its nested Flamingo subclass compile without issue.\nThe permits clause is optional if the subclass is nested or declared in\nthe same file. For this reason, Monkey and its subclass Mandrill also\ncompile without issue. EmperorTamarin does not compile, as it is\nmissing a non-sealed, sealed, or final modifier, making option C\ncorrect. Friendly also does not compile, since it lists a subclass Silly\nthat does not extend it, making option E correct. While the permits\nclause is optional, the extends clause is not. Silly compiles just fine.\nEven though it does not extend Friendly, the compiler error is in the\nsealed class."
            },
            {
                "id": "82f28a82-0199-1000-9271-0000f3466f34",
                "question": "1. What is the result of the following class?\n\n1: import java.util.function.*;\n2:\n3: public class Panda {\n4: int age;\n5: public static void main(String[] args) {\n6: Panda p1 = new Panda();\n7: p1.age = 1;\n8: check(p1, p -> p.age < 5);\n9: }\n10: private static void check(Panda panda,\n11: Predicate<Panda> pred) {\n12: String result =\n13: pred.test(panda) ? \"match\" : \"not match\";\n14: System.out.print(result);\n15: } }",
                "answer_options": [
                    "A. match",
                    "B. not match",
                    "C. Compiler error on line 8",
                    "D. Compiler error on lines 10 and 11",
                    "E. Compiler error on lines 12 and 13",
                    "F. A runtime exception"
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "1. A. This code is correct. Line 8 creates a lambda expression that checks\nwhether the age is less than 5, making option A correct. Since there is\nonly one parameter and it does not specify a type, the parentheses\naround the parameter are optional. Lines 11 and 13 use the Predicate\ninterface, which declares a test() method."
            },
            {
                "id": "82f28a82-0199-1000-8fd1-0000900d3540",
                "question": "2. What is the result of the following code?\n\n1: interface Climb {\n2: boolean isTooHigh(int height, int limit);\n3: }\n4:\n5: public class Climber {\n6: public static void main(String[] args) {\n7: check((h, m) -> h.append(m).isEmpty(), 5);\n8: }\n9: private static void check(Climb climb, int height) {\n10: if (climb.isTooHigh(height, 10))\n11: System.out.println(\"too high\");\n12: else\n13: System.out.println(\"ok\");\n14: }\n15: }",
                "answer_options": [
                    "A. ok",
                    "B. too high",
                    "C. Compiler error on line 7.",
                    "D. Compiler error on line 10.",
                    "E. Compiler error on a different line.",
                    "F. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "2. C. The interface takes two int parameters. The code on line 7 attempts\nto use them as if h is a StringBuilder, making option C correct. It is\ntricky to use types in a lambda when they are implicitly specified.\nRemember to check the interface for the real type."
            },
            {
                "id": "82f28a82-0199-1000-a583-00002fe71635",
                "question": "3. Which statements about functional interfaces are true? (Choose all that\napply.)",
                "answer_options": [
                    "A. A functional interface can contain default and private methods.",
                    "B. A functional interface can be defined as a class or an interface.",
                    "C. Abstract methods with signatures that are contained in public",
                    "D. A functional interface cannot contain static or private static",
                    "E. A functional interface must be marked with the"
                ],
                "correct_answer_indexes": [
                    0,
                    2
                ],
                "correct_answer_explanation": "3. A, C. A functional interface can contain any number of nonabstract\nmethods, including default, private, static, and private static.\nFor this reason, option A is correct, and option D is incorrect. Option\nB is incorrect, as classes are never considered functional interfaces. A\nfunctional interface contains exactly one abstract method, although\nmethods that have matching signatures as public methods in\njava.lang.Object do not count toward the single method test. For\nthese reasons, option C is correct. Finally, option E is incorrect. While\na functional interface can be marked with the @FunctionalInterface\nannotation, it is not required."
            },
            {
                "id": "82f28a82-0199-1000-01fb-0000425a6971",
                "question": "4. Which lambda can replace the MySecret class to return the same\nvalue? (Choose all that apply.)\n\ninterface Secret {\nString magic(double d);\n}\nclass MySecret implements Secret {\npublic String magic(double d) {\nreturn \"Poof\";\n} }",
                "answer_options": [
                    "A. (e) -> \"Poof\"",
                    "B. (e) -> {\"Poof\"}",
                    "C. (e) -> { String e = \"\"; \"Poof\" }",
                    "D. (e) -> { String e = \"\"; return \"Poof\"; }",
                    "E. (e) -> { String e = \"\"; return \"Poof\" }",
                    "F. (e) -> { String f = \"\"; return \"Poof\"; }"
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "4. A, F. Option B is incorrect because it does not use the return\nkeyword. Options C, D, and E are incorrect because the variable e is\nalready in use from the lambda and cannot be redefined. Additionally,\noption C is missing the return keyword, and option E is missing the\nsemicolon. Therefore, options A and F are correct."
            },
            {
                "id": "82f28a82-0199-1000-1f78-000049f213f3",
                "question": "5. Which of the following functional interfaces contain an abstract\nmethod that returns a primitive value? (Choose all that apply.)",
                "answer_options": [
                    "A. BooleanSupplier",
                    "B. CharSupplier",
                    "C. DoubleSupplier",
                    "D. FloatSupplier",
                    "E. IntSupplier",
                    "F. StringSupplier"
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    4
                ],
                "correct_answer_explanation": "5. A, C, E. Java includes support for three primitive streams, along with\nnumerous functional interfaces to go with them: int, double, and\nlong. For this reason, options C and E are correct. Additionally, there\nis a BooleanSupplier functional interface, making option A correct.\nJava does not include primitive streams or related functional interfaces\nfor other numeric data types, making options B and D incorrect.\nOption F is incorrect because String is not a primitive but an object.\nOnly primitives have custom suppliers."
            },
            {
                "id": "82f28a82-0199-1000-db3d-00000bf9af47",
                "question": "6. Which of the following lambda expressions can be passed to a function\nof Predicate<String> type? (Choose all that apply.)",
                "answer_options": [
                    "A. s -> s.isEmpty()",
                    "B. s --> s.isEmpty()",
                    "C. (String s) -> s.isEmpty()",
                    "D. (String s) --> s.isEmpty()",
                    "E. (StringBuilder s) -> s.isEmpty()",
                    "F. (StringBuilder s) --> s.isEmpty()"
                ],
                "correct_answer_indexes": [
                    0,
                    2
                ],
                "correct_answer_explanation": "6. A, C. Predicate<String> takes a parameter list of one parameter\nusing the specified type. Options E and F are incorrect because they\nspecify the wrong type. Options B, D, and F are incorrect because they\nuse the wrong syntax for the arrow operator. This leaves us with\noptions A and C as the answers."
            },
            {
                "id": "82f28a82-0199-1000-6fde-0000d38adbd6",
                "question": "7. Which of these statements is true about the following code?\n\npublic void method() {\nx((var x) -> {}, (var x, var y) -> false);\n}\npublic void x(Consumer<String> x, BinaryOperator<Boolean>\ny) {}",
                "answer_options": [
                    "A. The code does not compile because of one of the variables named",
                    "B. The code does not compile because of one of the variables named",
                    "C. The code does not compile for another reason.",
                    "D. The code compiles, and the x in each lambda refers to the same",
                    "E. The code compiles, and the x in each lambda refers to a different"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "7. E. While there appears to have been a variable name shortage when\nthis code was written, it does compile. Lambda variables and method\nnames are allowed to be the same. The x lambda parameter is scoped\nto within each lambda, so it is allowed to be reused. The type is\ninferred by the method it calls. The first lambda maps x to a String\nand the second to a Boolean. Therefore, option E is correct."
            },
            {
                "id": "82f28a82-0199-1000-37df-000000b3a12a",
                "question": "8. Which of the following is equivalent to this code?\nUnaryOperator<Integer> u = x -> x * x;",
                "answer_options": [
                    "A. BiFunction<Integer> f = x -> x*x;",
                    "B. BiFunction<Integer, Integer> f = x -> x*x;",
                    "C. BinaryOperator<Integer, Integer> f = x -> x*x;",
                    "D. Function<Integer> f = x -> x*x;",
                    "E. Function<Integer, Integer> f = x -> x*x;",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "8. E. The question starts with a UnaryOperator<Integer>, which takes\none parameter and returns a value of the same type. Therefore, option\nE is correct, as UnaryOperator extends Function. Notice that other\noptions don’t even compile because they have the wrong number of\ngeneric types for the functional interface provided. You should know\nthat a BiFunction<T,U,R> takes three generic arguments, a\nBinaryOperator<T> takes one generic argument, and a Function<T,R>\ntakes two generic arguments."
            },
            {
                "id": "82f28a82-0199-1000-91ef-000031c01e7e",
                "question": "9. Which statements are true? (Choose all that apply.)",
                "answer_options": [
                    "A. The Consumer interface is good for printing out an existing value.",
                    "B. The Supplier interface is good for printing out an existing value.",
                    "C. The IntegerSupplier interface returns an int.",
                    "D. The Predicate interface returns an int.",
                    "E. The Function interface has a method named test().",
                    "F. The Predicate interface has a method named test()."
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "9. A, F. Option A is correct, and option B is incorrect because a Supplier\nreturns a value while a Consumer takes one and acts on it. Option C is\ntricky. IntSupplier does return an int. However, the option asks\nabout IntegerSupplier, which doesn’t exist. Option D is incorrect\nbecause a Predicate returns a boolean. It does have a method named\ntest(), making option F correct. Finally, option E is incorrect because\nFunction has an apply() method."
            },
            {
                "id": "82f28a82-0199-1000-a8f5-0000955d6d7e",
                "question": "10. Which of the following can be inserted without causing a compilation\nerror? (Choose all that apply.)\n\npublic void remove(List<Character> chars) {\nchar end = 'z';\nPredicate<Character> predicate = c -> {\nchar start = 'a'; return start <= c && c <= end; };\n// INSERT LINE HERE\n}",
                "answer_options": [
                    "A. char start = ’a’;",
                    "B. char c = ’x’;",
                    "C. chars = null;",
                    "D. end = ’1’;",
                    "E. None of the above"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    2
                ],
                "correct_answer_explanation": "10. A, B, C. Since the scope of start and c is within the lambda, the\nvariables can be declared or updated after it without issue, making\noptions A, B, and C correct. Option D is incorrect because setting end\nprevents it from being effectively final."
            },
            {
                "id": "82f28a82-0199-1000-95b4-0000691c04ef",
                "question": "11. How many times is true printed out by this code?\n\nimport java.util.function.Predicate;\npublic class Fantasy {\npublic static void scary(String animal) {\nvar dino = s -> \"dino\".equals(animal);\nvar dragon = s -> \"dragon\".equals(animal);\nvar combined = dino.or(dragon);\nSystem.out.println(combined.test(animal));\n}\npublic static void main(String[] args) {\nscary(\"dino\");\nscary(\"dragon\");\nscary(\"unicorn\");\n}\n}",
                "answer_options": [
                    "A. One.",
                    "B. Two.",
                    "C. Three.",
                    "D. The code does not compile.",
                    "E. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "11. D. The code does not compile because the lambdas are assigned to\nvar. The compiler does not have enough information to determine they\nare of type Predicate<String>. Therefore, option D is correct."
            },
            {
                "id": "82f28a82-0199-1000-0fd3-0000909c725b",
                "question": "12. What does the following code output?\n\nFunction<Integer, Integer> s = a -> a + 4;\nFunction<Integer, Integer> t = a -> a * 3;\nFunction<Integer, Integer> c = s.compose(t);\nSystem.out.print(c.apply(1));",
                "answer_options": [
                    "A. 7",
                    "B. 15",
                    "C. The code does not compile because of the data types in the",
                    "D. The code does not compile because of the compose() call.",
                    "E. The code does not compile for another reason."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "12. A. The a.compose(b) method calls the Function parameter b before\nthe reference Function variable a. In this case, that means we multiply\nby 3 before adding 4. This gives a result of 7, making option A correct."
            },
            {
                "id": "82f28a82-0199-1000-89dc-000071f5a9da",
                "question": "13. Which is true of the following code?\n\nint length = 3;\nfor (int i = 0; i<3; i++) {\nif (i%2 == 0) {\nSupplier<Integer> supplier = () -> length; // A\nSystem.out.println(supplier.get()); // B\n} else {\nint j = i;\nSupplier<Integer> supplier = () -> j; // C\nSystem.out.println(supplier.get()); // D\n}\n}",
                "answer_options": [
                    "A. The first compiler error is on line A.",
                    "B. The first compiler error is on line B.",
                    "C. The first compiler error is on line C.",
                    "D. The first compiler error is on line D.",
                    "E. The code compiles successfully."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "13. E. Lambdas are only allowed to reference final or effectively final\nvariables. You can tell the variable j is effectively final because adding\na final keyword before it wouldn’t introduce a compiler error. Each\ntime the else statement is executed, the variable is redeclared and goes\nout of scope. Therefore, it is not reassigned. Similarly, length is\neffectively final. There are no compiler errors, and option E is correct."
            },
            {
                "id": "82f28a82-0199-1000-7395-0000ef8f744e",
                "question": "14. Which of the following are valid lambda expressions? (Choose all that\napply.)",
                "answer_options": [
                    "A. (Wolf w, var c) -> 39",
                    "B. (final Camel c) -> {}",
                    "C. (a,b,c) -> {int b = 3; return 2;}",
                    "D. (x,y) -> new RuntimeException()",
                    "E. (var y) -> return 0;",
                    "F. () -> {float r}",
                    "G. (Cat a, b) -> {}"
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "14. B, D. Option B is a valid functional interface, one that could be\nassigned to a Consumer<Camel> reference. Notice that the final\nmodifier is permitted on variables in the parameter list. Option D is\ncorrect, as the exception is being returned as an object and not thrown.\nThis would be compatible with a BiFunction that included\nRuntimeException as its return type.\nOptions A and G are incorrect because they mix format types for the\nparameters. Option C is invalid because the variable b is used twice.\nOption E is incorrect, as a return statement is permitted only inside\nbraces ({}). Option F is incorrect because the variable declaration\nrequires a semicolon (;) after it."
            },
            {
                "id": "82f28a82-0199-1000-42fa-0000057b88d8",
                "question": "15. Which lambda expression, when entered into the blank line in the\nfollowing code, causes the program to print hahaha? (Choose all that\napply.)\n\nimport java.util.function.Predicate;\npublic class Hyena {\nprivate int age = 1;\npublic static void main(String[] args) {\nvar p = new Hyena();\ndouble height = 10;\nint age = 1;\ntestLaugh(p, ________________);\nage = 2;\n}\nstatic void testLaugh(Hyena panda, Predicate<Hyena>\njoke) {\nvar r = joke.test(panda) ? \"hahaha\" : \"silence\";\nSystem.out.print(r);\n}\n}",
                "answer_options": [
                    "A. var -> p.age <= 10",
                    "B. shenzi -> age==1",
                    "C. p -> true",
                    "D. age==1",
                    "E. shenzi -> age==2",
                    "F. h -> h.age < 5",
                    "G. None of the above, as the code does not compile"
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "15. A, F. Option A is a valid lambda expression. While main() is a static\nmethod, it can access age since it is using a reference to an instance of\nHyena, which is effectively final in this method. Since var is not a\nreserved word, it may be used for variable names. Option F is also\ncorrect, with the lambda variable being a reference to a Hyena object.\nThe variable is processed using deferred execution in the testLaugh()\nmethod.\nOptions B and E are incorrect; since the local variable age is not\neffectively final, this would lead to a compilation error. Option C\nwould also cause a compilation error, since the expression uses the\nvariable name p, which is already declared within the method. Finally,\noption D is incorrect, as this is not even a lambda expression."
            },
            {
                "id": "82f28a83-0199-1000-6de2-000065b5e245",
                "question": "16. Which of the following can be inserted without causing a compilation\nerror?\n\npublic void remove(List<Character> chars) {\nchar end = 'z';\n// INSERT LINE HERE\nPredicate<Character> predicate = c -> {\nchar start = 'a'; return start <= c && c <= end; };\n}",
                "answer_options": [
                    "A. char start = ’a’;",
                    "B. char c = ’x’;",
                    "C. chars = null;",
                    "D. end = ’1’;",
                    "E. None of the above"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "16. C. Lambdas are not allowed to redeclare local variables, making\noptions A and B incorrect. Option D is incorrect because setting end\nprevents it from being effectively final. Lambdas are only allowed to\nreference final or effectively final variables. Option C compiles since\nchars is not used."
            },
            {
                "id": "82f28a83-0199-1000-a7fe-0000a3269da9",
                "question": "17. What is the result of running the following class?\n\n1: import java.util.function.*;\n2:\n3: public class Panda {\n4: int age;\n5: public static void main(String[] args) {\n6: Panda p1 = new Panda();\n7: p1.age = 1;\n8: check(p1, p -> {p.age < 5});\n9: }\n10: private static void check(Panda panda,\n11: Predicate<Panda> pred) {\n12: String result = pred.test(panda)\n13: ? \"match\" : \"not match\";\n14: System.out.print(result);\n15: } }",
                "answer_options": [
                    "A. match",
                    "B. not match",
                    "C. Compiler error on line 8.",
                    "D. Compiler error on line 10.",
                    "E. Compiler error on line 12.",
                    "F. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "17. C. Line 8 uses braces around the body. This means the return\nkeyword and semicolon are required. Since the code doesn’t compile,\noption C is the answer."
            },
            {
                "id": "82f28a83-0199-1000-6831-0000949f3650",
                "question": "18. Which functional interfaces complete the following code? For line 7,\nassume m and n are instances of functional interfaces that exist and\nhave the same type as y. (Choose three.)\n\n6: _____________ x = String::new;\n7: _____________ y = m.andThen(n);\n8: _____________ z = a -> a + a;",
                "answer_options": [
                    "A. BinaryConsumer<String, String>",
                    "B. BiConsumer<String, String>",
                    "C. BinaryFunction<String, String>",
                    "D. BiFunction<String, String>",
                    "E. Predicate<String>",
                    "F. Supplier<String>",
                    "G. UnaryOperator<String>",
                    "H. UnaryOperator<String, String>"
                ],
                "correct_answer_indexes": [
                    1,
                    5,
                    6
                ],
                "correct_answer_explanation": "18. B, F, G. We can eliminate four choices right away. Options A and C\nare there to mislead you; these interfaces don’t exist. Option D is\nincorrect because a BiFunction<T,U,R> takes three generic arguments,\nnot two. Option E is incorrect because none of the examples returns a\nboolean.\nThe declaration on line 6 doesn’t take any parameters, and it returns a\nString, so a Supplier<String> can fill in the blank, making option F\ncorrect. The declaration on line 7 requires you to recognize that\nConsumer and Function, along with their binary equivalents, have an\nandThen() method. This makes option B correct. Finally, line 8 takes a\nsingle parameter, and it returns the same type, which is a\nUnaryOperator. Since the types are the same, only one generic\nparameter is needed, making option G correct."
            },
            {
                "id": "82f28a83-0199-1000-913a-000094904824",
                "question": "19. Which of the following compiles and prints out the entire set?\n\nSet<?> set = Set.of(\"lion\", \"tiger\", \"bear\");\nvar s = Set.copyOf(set);\nConsumer<Object> consumer = ________________;\ns.forEach(consumer);",
                "answer_options": [
                    "A. () -> System.out.println(s)",
                    "B. s -> System.out.println(s)",
                    "C. (s) -> System.out.println(s)",
                    "D. System.out.println(s)",
                    "E. System::out::println",
                    "F. System.out::println"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "19. F. While there is a lot in this question trying to confuse you, note that\nthere are no options about the code not compiling. This allows you to\nfocus on the lambdas and method references. Option A is incorrect\nbecause a Consumer requires one parameter. Options B and C are close.\nThe syntax for the lambda is correct. However, s is already defined as\na local variable, and therefore the lambda can’t redefine it. Options D\nand E use incorrect syntax for a method reference. Option F is correct."
            },
            {
                "id": "82f28a84-0199-1000-8880-0000f8b41948",
                "question": "20. Which lambda can replace the new Sloth() call in the main() method\nand produce the same output at runtime?\n\nimport java.util.List;\ninterface Yawn {\nString yawn(double d, List<Integer> time);\n}\nclass Sloth implements Yawn {\npublic String yawn(double zzz, List<Integer> time) {\nreturn \"Sleep: \" + zzz;\n} }\npublic class Vet {\npublic static String takeNap(Yawn y) {\nreturn y.yawn(10, null);\n}\npublic static void main(String… unused) {\nSystem.out.print(takeNap(new Sloth()));\n} }",
                "answer_options": [
                    "A. (z,f) -> { String x = \"\"; return \"Sleep: \" + x }",
                    "B. (t,s) -> { String t = \"\"; return \"Sleep: \" + t; }",
                    "C. (w,q) -> {\"Sleep: \" + w}",
                    "D. (e,u) -> { String g = \"\"; \"Sleep: \" + e }",
                    "E. (a,b) -> \"Sleep: \" + (double)(b==null ? a : a)",
                    "F. (r,k) -> { String g = \"\"; return \"Sleep:\"; }",
                    "G. None of the above, as the program does not compile"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "20. E. Option A does not compile because the second statement within the\nblock is missing a semicolon (;) at the end. Option B is an invalid\nlambda expression because t is defined twice: in the parameter list and\nwithin the lambda expression. Options C and D are both missing a\nreturn statement and semicolon. Options E and F are both valid\nlambda expressions, although only option E matches the behavior of\nthe Sloth class. In particular, option F only prints Sleep:, not Sleep:\n10.0."
            },
            {
                "id": "82f28a84-0199-1000-3032-0000cbf690e8",
                "question": "21. Which of the following are valid functional interfaces? (Choose all\nthat apply.)\n\npublic interface Transport {\npublic int go();\npublic boolean equals(Object o);\n}\npublic abstract class Car {\npublic abstract Object swim(double speed, int duration);\n}\npublic interface Locomotive extends Train {\npublic int getSpeed();\n}\npublic interface Train extends Transport {}\nabstract interface Spaceship extends Transport {\ndefault int blastOff();\n}\npublic interface Boat {\nint hashCode();\nint hashCode(String input);\n}",
                "answer_options": [
                    "A. Boat",
                    "B. Car",
                    "C. Locomotive",
                    "D. Spaceship",
                    "E. Transport",
                    "F. Train",
                    "G. None of these is a valid functional interface."
                ],
                "correct_answer_indexes": [
                    0,
                    4,
                    5
                ],
                "correct_answer_explanation": "21. A, E, F. A valid functional interface is one that contains a single\nabstract method, excluding any public methods that are already\ndefined in the java.lang.Object class. Transport and Boat are valid\nfunctional interfaces, as they each contain a single abstract method:\ngo() and hashCode(String), respectively. This gives us options A and\nE. Since the other methods are part of Object, they do not count as\nabstract methods. Train is also a functional interface since it extends\nTransport and does not define any additional abstract methods. This\nadds option F as the final correct answer.\nCar is not a functional interface because it is an abstract class.\nLocomotive is not a functional interface because it includes two\nabstract methods, one of which is inherited. Finally, Spaceship is not a\nvalid interface, let alone a functional interface, because a default\nmethod must provide a body. A quick way to test whether an interface\nis a functional interface is to apply the @FunctionalInterface\nannotation and check if the code still compiles."
            },
            {
                "id": "82f28a84-0199-1000-1c6f-0000cb1729c6",
                "question": "1. Suppose you need to display a collection of products for sale, which may contain duplicates. Additionally, you have a collection of sales that you need to track, sorted by the natural order of the sale ID, and you need to retrieve the text of each. Which two of the following classes best suit your needs for each of these scenarios? (Choose two.)",
                "answer_options": [
                    "A. 1. ArrayList",
                    "B. 2. HashMap",
                    "C. 3. HashSet",
                    "D. 4. LinkedList",
                    "E. 5. SequencedTreeSet",
                    "F. 6. TreeMap"
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "1. A, F. Option E is incorrect for both scenarios, as SequencedTreeSet\ndoes not exist. For the first scenario, the answer needs to implement\nList because the scenario allows duplicates, narrowing it down to\noptions A and D. Option A is a better answer than option D because\nLinkedList is both a List and a Queue, and you just need a regular\nList. For the second scenario, the answer needs to implement Map\nbecause you are dealing with key/value pairs per the unique id field.\nThis narrows it down to options B and F. Since the question talks about\nordering, you need the TreeMap. Therefore, the answer is option F."
            },
            {
                "id": "82f28a84-0199-1000-22fd-000091b26493",
                "question": "2. Which of the following are true? (Choose all that apply.)\n\n12: List<?> q = List.of(\"mouse\", \"parrot\");\n13: var v = List.of(\"mouse\", \"parrot\");\n14:\n15: q.removeIf(String::isEmpty);\n16: q.removeIf(s -> s.length() == 4);\n17: v.removeIf(String::isEmpty);\n18: v.removeIf(s -> s.length() == 4);",
                "answer_options": [
                    "A. 1. This code compiles and runs without error.",
                    "B. 2. Exactly one of these lines contains a compiler error.",
                    "C. 3. Exactly two of these lines contain a compiler error.",
                    "D. 4. Exactly three of these lines contain a compiler error.",
                    "E. 5. Exactly four of these lines contain a compiler error.",
                    "F. 6. If any lines with compiler errors are removed, this code runs without throwing an",
                    "G. 7. If any lines with compiler errors are removed, this code throws an exception."
                ],
                "correct_answer_indexes": [
                    2,
                    6
                ],
                "correct_answer_explanation": "2. C, G. Line 12 creates a List<?>, which means it is treated as if all the\nelements are of type Object rather than String. Lines 15 and 16 do\nnot compile since they call the String methods isEmpty() and\nlength(), which are not defined on Object. Line 13 creates a\nList<String> because var uses the type that it deduces from the\ncontext. Lines 17 and 18 do compile. However, List.of() creates an\nimmutable list, so both of those lines would throw an\nUnsupportedOperationException if run. Therefore, options C and G\nare correct."
            },
            {
                "id": "82f28a84-0199-1000-468d-0000f506289b",
                "question": "3. What is the result of the following statements?\n\n3: var greetings = new ArrayDeque<String>();\n4: greetings.offerLast(\"hello\");\n5: greetings.offerLast(\"hi\");\n6: greetings.offerFirst(\"ola\");\n7: greetings.pop();\n8: greetings.peek();\n9: while (greetings.peek() != null)\n10: System.out.print(greetings.pop());",
                "answer_options": [
                    "A. 1. hello",
                    "B. 2. hellohi",
                    "C. 3. hellohiola",
                    "D. 4. hiola",
                    "E. 5. The code does not compile.",
                    "F. 6. An exception is thrown."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "3. B. This is a double-ended queue. On lines 4 and 5, we add to the back,\ngiving us [hello, hi]. On line 6, we add to the front and have [ola,\nhello, hi]. On line 7, we remove the first element, which is \"ola\".\nOn line 8, we look at the new first element (\"hello\") but don’t remove\nit. On lines 9 and 10, we remove each element in turn until no\nelements are left, printing hello and hi together, which makes option\nB the answer."
            },
            {
                "id": "82f28a84-0199-1000-0d12-0000f9f3dd41",
                "question": "4. Which of these statements compile? (Choose all that apply.)",
                "answer_options": [
                    "A. 1. HashSet<Number> hs = new HashSet<Integer>();",
                    "B. 2. HashSet<? super ClassCastException> set = new HashSet<Exception>();",
                    "C. 3. List<> list = new ArrayList<String>();",
                    "D. 4. List<Object> values = new HashSet<Object>();",
                    "E. 5. List<Object> objects = new ArrayList<? extends Object>();",
                    "F. 6. Map<String, ? extends Number> hm = new HashMap<String, Integer>();"
                ],
                "correct_answer_indexes": [
                    1,
                    5
                ],
                "correct_answer_explanation": "4. B, F. Option A does not compile because the generic types are not\ncompatible. We could say HashSet<? extends Number> hs2 = new\nHashSet<Integer>();. Option B uses a lower bound, so it allows\nsuperclass generic types. Option C does not compile because the\ndiamond operator is allowed only on the right side. Option D does not\ncompile because a Set is not a List. Option E does not compile\nbecause upper bounds are not allowed when instantiating the type.\nFinally, option F does compile because the upper bound is on the\ncorrect side of the =."
            },
            {
                "id": "82f28a85-0199-1000-723f-00004320af0f",
                "question": "5. What is the result of the following code?\n\n1: public record Hello<T>(T t) {\n2: public Hello(T t) { this.t = t; }\n3: private <T> void println(T message) {\n4: System.out.print(t + \"-\" + message);\n5: }\n6: public static void main(String[] args) {\n7: new Hello<String>(\"hi\").println(1);\n8: new Hello(\"hola\").println(true);\n9: } }",
                "answer_options": [
                    "A. 1. hi followed by a runtime exception.",
                    "B. 2. hi-1hola-true",
                    "C. 3. The first compiler error is on line 1.",
                    "D. 4. The first compiler error is on line 3.",
                    "E. 5. The first compiler error is on line 8.",
                    "F. 6. The first compiler error is on another line."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "5. B. The record compiles and runs without issue. Line 8 gives a\ncompiler warning for not using generics but not a compiler error. Line\n7 creates the Hello class with the generic type String. It also passes\nan int to the println() method, which gets autoboxed into an\nInteger. While the println() method takes a generic parameter of\ntype T, it is not the same <T> defined for the class on line 1. Instead, it\nis a different T defined as part of the method declaration on line 3.\nTherefore, the String argument on line 7 applies only to the class. The\nmethod can take any object as a parameter, including autoboxed\nprimitives. Line 8 creates the Hello class with the generic type Object\nsince no type is specified for that instance. It passes a boolean to\nprintln(), which gets autoboxed into a Boolean. The result is that hi-\n1hola-true is printed, making option B correct."
            },
            {
                "id": "82f28a85-0199-1000-5dfc-0000fa9dd514",
                "question": "6. Which of the following can fill in the blank to print [7, 5, 3]? (Choose all that apply.)\n\n8: public record Platypus(String name, int beakLength) {\n9: @Override public String toString() {return \"\" + beakLength;}\n10:\n11: public static void main(String[] args) {\n12: Platypus p1 = new Platypus(\"Paula\", 3);\n13: Platypus p2 = new Platypus(\"Peter\", 5);\n14: Platypus p3 = new Platypus(\"Peter\", 7);\n15:\n16: List<Platypus> list = Arrays.asList(p1, p2, p3);\n17:\n18: Collections.sort(list, Comparator.comparing_______________);\n19:\n20: System.out.println(list);\n21: }\n22: }",
                "answer_options": [
                    "A. 1. (Platypus::beakLength)",
                    "B. 2. (Platypus::beakLength).reversed()",
                    "C. 3. (Platypus::name) .thenComparing(Platypus::beakLength)",
                    "D. 4. (Platypus::name) .thenComparing( Comparator.comparing(Platypus::beakLength) .reversed())",
                    "E. 5. (Platypus::name) .thenComparingNumber(Platypus::beakLength) .reversed()",
                    "F. 6. (Platypus::name) .thenComparingInt(Platypus::beakLength) .reversed()"
                ],
                "correct_answer_indexes": [
                    1,
                    5
                ],
                "correct_answer_explanation": "6. B, F. We’re looking for a Comparator definition that sorts in\ndescending order by beakLength. Option A is incorrect because it sorts\nin ascending order by beakLength. Similarly, option C is incorrect\nbecause it sorts by beakLength in ascending order within those\nmatches that have the same name. Option E is incorrect because there\nis no thenComparingNumber() method.\n  Option B is a correct answer, as it sorts by beakLength in descending\norder. Options D and F are trickier. First, notice that we can call either\nthenComparing() or thenComparingInt() because the former will\nsimply autobox the int into an Integer. Then observe what\nreversed() applies to. Option D is incorrect because it sorts by name\nin ascending order and only reverses the beak length of those with the\nsame name. Option F creates a comparator that sorts by name in\nascending order and then by beak size in ascending order. Finally, it\nreverses the result. This is just what we want, so option F is correct."
            },
            {
                "id": "82f28a85-0199-1000-de98-000029a34c0d",
                "question": "7. Which of the following method signatures are valid overrides of the hairy() method in\nthe Alpaca class? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "1. public List<String> hairy(List<CharSequence> list) { return null; }\n2. public List<String> hairy(List<String> list) { return null; }\n3. public List<String> hairy(List<Integer> list) { return null; }\n4. public List<CharSequence> hairy(List<String> list) { return null; }\n5. public Object hairy(List<String> list) { return null; }\n6. public ArrayList<String> hairy(List<String> list) { return null; }"
            },
            {
                "id": "82f28a85-0199-1000-6dd4-0000602fcbf0",
                "question": "7. Which of the following method signatures are valid overrides of the hairy() method in\nthe Alpaca class? (Choose all that apply.)\n\nimport java.util.*;\npublic class Alpaca {\npublic List<String> hairy(List<String> list) { return null; }\n}",
                "answer_options": [
                    "A. 1. public List<String> hairy(List<CharSequence> list) { return null; }",
                    "B. 2. public List<String> hairy(List<String> list) { return null; }",
                    "C. 3. public List<String> hairy(List<Integer> list) { return null; }",
                    "D. 4. public List<CharSequence> hairy(List<String> list) { return null; }",
                    "E. 5. public Object hairy(List<String> list) { return null; }",
                    "F. 6. public ArrayList<String> hairy(List<String> list) { return null; }"
                ],
                "correct_answer_indexes": [
                    1,
                    5
                ],
                "correct_answer_explanation": "7. B, F. A valid override of a method with generic arguments must have a\nreturn type that is covariant, with matching generic type parameters.\nOptions D and E are incorrect because the return type is too broad.\nAdditionally, the generic arguments must have the same signature with\nthe same generic types. This eliminates options A and C. The\nremaining options are correct, making the answer options B and F."
            },
            {
                "id": "82f28a85-0199-1000-52ba-0000ed28e12b",
                "question": "8. Which of the following fills in the blank, allowing the code to compile and run without\nissue?\n\n11: SequencedCollection<String> animals = new _____________<>();\n12: animals.addFirst(\"lions\");\n13: animals.addLast(\"tigers\");\n14: for(var a : animals)\n15: System.out.println(a);\n16: System.out.println(animals.get(0));",
                "answer_options": [
                    "A. 1. HashSet",
                    "B. 2. LinkedList",
                    "C. 3. TreeSetMap",
                    "D. 4. HashMap",
                    "E. 5. None of the above"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "8. E. There is no get(int) method defined in SequencedCollection,\nmeaning line 16 does not compile, regardless of what is placed in the\nblank. For this reason, option E is correct. If line 16 was removed or\ncorrected to use getFirst(), then LinkedList would be the correct\nanswer."
            },
            {
                "id": "82f28a85-0199-1000-9214-0000ab89c0ab",
                "question": "9. What is the result of the following program?\n\n3: public class MyComparator implements Comparator<String> {\n4: public int compare(String a, String b) {\n5: return b.toLowerCase().compareTo(a.toLowerCase());\n6: }\n7: public static void main(String[] args) {\n8: String[] values = { \"123\", \"Abb\", \"aab\" };\n9: Arrays.sort(values, new MyComparator());\n10: for (var s: values)\n11: System.out.print(s + \" \");\n12: }\n13: }",
                "answer_options": [
                    "A. 1. Abb aab 123",
                    "B. 2. aab Abb 123",
                    "C. 3. 123 Abb aab",
                    "D. 4. 123 aab Abb",
                    "E. 5. The code does not compile.",
                    "F. 6. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "9. A. The array is sorted using MyComparator, which sorts the elements in\nreverse alphabetical order in a case-insensitive fashion. Normally,\nnumbers sort before letters. This code reverses that by calling the\ncompareTo() method on b instead of a. Therefore, option A is correct."
            },
            {
                "id": "82f28a85-0199-1000-74b6-0000e35c6d8d",
                "question": "10. Which of these statements can fill in the blank so that the Helper class compiles\nsuccessfully? (Choose all that apply.)\n\n2: public class Helper {\n3: public static <U extends Exception>\n4: void printException(U u) {\n5:\n6: System.out.println(u.getMessage());\n7: }\n8: public static void main(String[] args) {\n9: Helper.____________________________________________;\n10: } }",
                "answer_options": [
                    "A. 1. printException(new FileNotFoundException(\"A\"))",
                    "B. 2. printException(new Exception(\"B\"))",
                    "C. 3. <Throwable>printException(new Exception(\"C\"))",
                    "D. 4. <NullPointerException>printException(new NullPointerException (\"D\"))",
                    "E. 5. printException(new Throwable(\"E\"))"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    3
                ],
                "correct_answer_explanation": "10. A, B, D. The generic type must be Exception or a subclass of\nException since this is an upper bound, making options A and B\ncorrect. Options C and E are wrong because Throwable is a superclass\nof Exception. Additionally, option D is correct despite the odd syntax\nby explicitly listing the type. You should still be able to recognize it as\nacceptable."
            },
            {
                "id": "82f28a85-0199-1000-3004-00002e051f67",
                "question": "11. Which of the following will compile when filling in the blank? (Choose all that apply.)\n\nvar list = List.of(1, 2, 3);\nvar set = Set.of(1, 2, 3);\nvar map = Map.of(1, 2, 3, 4);\n____________.forEach(System.out::println);",
                "answer_options": [
                    "A. 1. list",
                    "B. 2. set",
                    "C. 3. map",
                    "D. 4. map.keys()",
                    "E. 5. map.keySet()",
                    "F. 6. map.values()",
                    "G. 7. map.valueSet()"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    4,
                    5
                ],
                "correct_answer_explanation": "11. A, B, E, F. The forEach() method works with a Collection, such as\nList or a Set. Therefore, options A and B are correct. Additionally,\noptions E and F return a Set and Collection, respectively, and can be\nused as well. Options D and G refer to methods that do not exist.\nOption C is tricky because a Map does have a forEach() method.\nHowever, it uses two lambda parameters rather than one. Since there is\nno matching System.out.println method, it does not compile."
            },
            {
                "id": "82f28a85-0199-1000-0cff-000084f9f196",
                "question": "12. Which of these statements can fill in the blank so that the Wildcard class compiles\nsuccessfully? (Choose all that apply.)\n\n3: public class Wildcard {\n4: public void showSize(List<?> list) {\n5: System.out.println(list.size());\n6: }\n7: public static void main(String[] args) {\n8: Wildcard card = new Wildcard();\n9: _________________________________________;\n10: card.showSize(list);\n11: } }",
                "answer_options": [
                    "A. 1. List<?> list = new HashSet <String>()",
                    "B. 2. ArrayList<? super Date> list = new ArrayList<Date>()",
                    "C. 3. List<?> list = new ArrayList<?>()",
                    "D. 4. List<Exception> list = new LinkedList<java.io.IOException>()",
                    "E. 5. ArrayList <? extends Number> list = new ArrayList <Integer>()",
                    "F. 6. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    4
                ],
                "correct_answer_explanation": "12. B, E. The showSize() method can take any type of List since it uses\nan unbounded wildcard. Option A is incorrect because it is a Set and\nnot a List. Option C is incorrect because the wildcard is not allowed\nto be on the right side of an assignment. Option D is incorrect because\nthe generic types are not compatible.\nOption B is correct because a lower-bounded wildcard allows that\nsame type to be the generic. Option E is correct because Integer is a\nsubclass of Number."
            },
            {
                "id": "82f28a85-0199-1000-8dfa-0000678cc836",
                "question": "13. What is the result of the following program?\n\n3: public record Sorted(int num, String text)\n4: implements Comparable<Sorted>, Comparator<Sorted> {\n5:\n6: public String toString() { return \"\" + num; }\n7: public int compareTo(Sorted s) {\n8: return text.compareTo(s.text);\n9: }\n10: public int compare(Sorted s1, Sorted s2) {\n11: return s1.num - s2.num;\n12: }\n13: public static void main(String[] args) {\n14: var s1 = new Sorted(88, \"a\");\n15: var s2 = new Sorted(55, \"b\");\n16: SequencedSet<Sorted> t1 = new TreeSet<Sorted>();\n17: t1.add(s1); t1.add(s2);\n18: var t2 = new TreeSet<Sorted>(s1);\n19: t2.add(s1); t2.add(s2);\n20: System.out.println(t1 + \" \" + t2);\n21: } }",
                "answer_options": [
                    "A. 1. [55, 88] [55, 88]",
                    "B. 2. [55, 88] [88, 55]",
                    "C. 3. [88, 55] [55, 88]",
                    "D. 4. [88, 55] [88, 55]",
                    "E. 5. The code does not compile.",
                    "F. 6. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "13. C. This question is difficult because it defines both Comparable and\nComparator on the same object. The t1 object doesn’t specify a\nComparator, so it uses the Comparable object’s compareTo() method.\nThis sorts by the text instance variable. The t2 object does specify a\nComparator when calling the constructor, so it uses the compare()\nmethod, which sorts by the int. This gives us option C as the answer.\nNote that the SequencedSet reference on line 16 does not change the\nordering, as the underlying object is still a TreeSet."
            },
            {
                "id": "82f28a86-0199-1000-c842-000087d24f63",
                "question": "14. What is the result of the following code?\n\nComparator<Integer> c1 = (o1, o2) -> o2 - o1;\nComparator<Integer> c2 = Comparator.naturalOrder();\nComparator<Integer> c3 = Comparator.reverseOrder();\nvar list = Arrays.asList(5, 4, 7, 2);\nCollections.sort(list,_____________);\nCollections.reverse(list);\nCollections.reverse(list);\nSystem.out.println(Collections.binarySearch(list, 2));",
                "answer_options": [
                    "A. 1. One or more of the comparators can fill in the blank so that the code prints 0.",
                    "B. 2. One or more of the comparators can fill in the blank so that the code prints 1.",
                    "C. 3. One or more of the comparators can fill in the blank so that the code prints 2.",
                    "D. 4. The result is undefined regardless of which comparator is used.",
                    "E. 5. A runtime exception is thrown regardless of which comparator is used.",
                    "F. 6. The code does not compile."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "14. A. When using binarySearch(), the List must be sorted in the same\norder that the Comparator uses. Since the binarySearch() method\ndoes not specify a Comparator explicitly, the default sort order is used.\nOnly c2 uses that sort order and correctly identifies that the value 2 is\nat index 0. Therefore, option A is correct. The other two comparators\nsort in descending order. Therefore, the precondition for\nbinarySearch() is not met, and the result is undefined for those two.\nThe two calls to reverse() are just there to distract you; they cancel\neach other out."
            },
            {
                "id": "82f28a86-0199-1000-773c-0000aea16a17",
                "question": "15. Which of the following lines can be inserted to make the code compile? (Choose all that\napply.)\n\nclass W {}\nclass X extends W {}\nclass Y extends X {}\nclass Z<Y> {\n// INSERT CODE HERE\n}",
                "answer_options": [
                    "A. 1. W w1 = new W();",
                    "B. 2. W w2 = new X();",
                    "C. 3. W w3 = new Y();",
                    "D. 4. Y y1 = new W();",
                    "E. 5. Y y2 = new X();",
                    "F. 6. Y y3 = new Y();"
                ],
                "correct_answer_indexes": [
                    0,
                    1
                ],
                "correct_answer_explanation": "15. A, B. Y is both a class and a type parameter. This means that within the\nclass Z, when we refer to Y, it uses the type parameter. All of the\nchoices that mention class Y are incorrect because it no longer means\nthe class Y. Only options A and B are correct."
            },
            {
                "id": "82f28a86-0199-1000-1824-0000f7fe1575",
                "question": "16. Which options are true of the following code? (Choose all that apply.)\n\n_____________ q = new LinkedList<>();\nvar u = Collections.unmodifiableCollection(q);\nq.add(10);\nq.add(12);\nq.remove(1);\nSystem.out.print(u);",
                "answer_options": [
                    "A. 1. If we fill in the blank with List<Integer>, the output is [10].",
                    "B. 2. If we fill in the blank with Queue<Integer>, the output is [10].",
                    "C. 3. If we fill in the blank with var, the output is [10].",
                    "D. 4. One or more of the scenarios does not compile.",
                    "E. 5. One or more of the scenarios throws a runtime exception."
                ],
                "correct_answer_indexes": [
                    0,
                    2
                ],
                "correct_answer_explanation": "16. A, C. A LinkedList implements both List and Queue. The List\ninterface has a method to remove by index. Since this method exists,\nJava does not autobox to call the other method, making the output\n[10] and option A correct. Similarly, option C is correct because the\nmethod to remove an element by index is available on a\nLinkedList<Object> (which is what var represents here). By contrast,\nQueue has only the remove by object method, so Java does autobox\nthere. Since the number 1 is not in the list, Java does not remove\nanything for the Queue, and the output is [10, 12]. The\nunmodifiableCollection() call is a distractor as it is an unmodifiable\nview and the underlying connection can be changed."
            },
            {
                "id": "82f28a86-0199-1000-b1bd-00000c438fd6",
                "question": "17. What is the result of the following code?\n\n4: Map m = new HashMap();\n5: m.put(123, \"456\");\n6: m.put(\"abc\", \"def\");\n7: System.out.println(m.contains(\"123\"));",
                "answer_options": [
                    "A. 1. false",
                    "B. 2. true",
                    "C. 3. Compiler error on line 4.",
                    "D. 4. Compiler error on line 5.",
                    "E. 5. Compiler error on line 7.",
                    "F. 6. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "17. E. This question looks like it is about generics, but it’s not. It is trying\nto see whether you noticed that Map does not have a contains()\nmethod. It has containsKey() and containsValue() instead, making\noption E the answer. If containsKey() were called, the answer would\nbe false because 123 is an Integer key in the Map, rather than a\nString."
            },
            {
                "id": "82f28a86-0199-1000-35ba-0000f0006b85",
                "question": "18. What is the result of the following code? (Choose all that apply.)\n\n48: var map = Map.of(1,2, 3, 6);\n49: var list = List.copyOf(map.entrySet());\n50:\n51: List<Integer> one = List.of(8, 16, 2);\n52: var copy = List.copyOf(one);\n53: var copyOfCopy = List.copyOf(copy);\n54: var thirdCopy = new ArrayList<>(copyOfCopy);\n55:\n56: list.replaceAll(x -> x * 2);\n57: one.replaceAll(x -> x * 2);\n58: thirdCopy.replaceAll(x -> x * 2);\n59:\n60: System.out.println(thirdCopy);",
                "answer_options": [
                    "A. 1. One line fails to compile.",
                    "B. 2. Two lines fail to compile.",
                    "C. 3. Three lines fail to compile.",
                    "D. 4. The code compiles but throws an exception at runtime.",
                    "E. 5. If any lines with compiler errors are removed, the code throws an exception at",
                    "F. 6. If any lines with compiler errors are removed, the code prints [16, 32, 4].",
                    "G. 7. The code compiles and prints [16, 32, 4] without any changes."
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "18. A, E. The key to this question is keeping track of the types. Line 48 is\na Map<Integer, Integer>. Line 49 builds a List out of a Set of\nEntry objects, giving us List<Entry<Integer, Integer>>. This\ncauses a compiler error on line 56 since we can’t multiply an Entry\nobject by two.\nLines 51–54 are all of type List<Integer>. The first three are\nimmutable, and the one on line 54 is mutable. This means line 57\nthrows an UnsupportedOperationException since we attempt to\nmodify the list. Line 58 would work if we could get to it. Since there is\none compiler error and one runtime error, options A and E are correct."
            },
            {
                "id": "82f28a86-0199-1000-10db-00008637210d",
                "question": "19. What code change is needed to make the method compile, assuming there is no class\nnamed T?\n\npublic static T identity(T t) {\nreturn t;\n}",
                "answer_options": [
                    "A. 1. Add <T> after the public keyword.",
                    "B. 2. Add <T> after the static keyword.",
                    "C. 3. Add <T> after T.",
                    "D. 4. Add <?> after the public keyword.",
                    "E. 5. Add <?> after the static keyword.",
                    "F. 6. No change is required. The code already compiles."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "19. B. When using generic types in a method, the generic specification\ngoes before the return type, so option B is correct."
            },
            {
                "id": "82f28a86-0199-1000-2bb8-000071e8aaaa",
                "question": "20. Assuming keys are printed in order, what is the result of the following?\n\nvar map = new HashMap<Integer, Integer>();\nmap.put(1, 10);\nmap.put(2, 20);\nmap.put(3, null);\nmap.merge(1, 3, (a,b) -> a + b);\nmap.merge(3, 3, (a,b) -> a + b);\nSystem.out.println(map);",
                "answer_options": [
                    "A. 1. {1=10, 2=20}",
                    "B. 2. {1=10, 2=20, 3=null}",
                    "C. 3. {1=10, 2=20, 3=3}",
                    "D. 4. {1=13, 2=20}",
                    "E. 5. {1=13, 2=20, 3=null}",
                    "F. 6. {1=13, 2=20, 3=3}",
                    "G. 7. The code does not compile.",
                    "H. 8. An exception is thrown."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "20. F. The first call to merge() calls the mapping function and adds the\nnumbers to get 13. It then updates the map. The second call to merge()\nsees that the map currently has a null value for that key. It does not\ncall the mapping function but instead replaces it with the new value of\n3. Therefore, option F is correct."
            },
            {
                "id": "82f28a86-0199-1000-f74d-00006c7d71c0",
                "question": "21. Which of the following statements are true? (Choose all that apply.)",
                "answer_options": [
                    "A. 1. Comparable is in the java.util package.",
                    "B. 2. Comparator is in the java.util package.",
                    "C. 3. compare() is in the Comparable interface.",
                    "D. 4. compare() is in the Comparator interface.",
                    "E. 5. compare() takes one method parameter.",
                    "F. 6. compare() takes two method parameters."
                ],
                "correct_answer_indexes": [
                    1,
                    3,
                    5
                ],
                "correct_answer_explanation": "21. B, D, F. The java.lang.Comparable interface is implemented on the\nobject to compare. It specifies the compareTo() method, which takes\none parameter. The java.util.Comparator interface specifies the\ncompare() method, which takes two parameters. This gives us options\nB, D, and F as the answers."
            },
            {
                "id": "82f28a86-0199-1000-98a3-0000fbcc77c6",
                "question": "22. What is the output of the following code snippet?\n\n21: SequencedMap<Integer, String> cats = new TreeMap<>();\n22: cats.put(3, \"Snowball\");\n23: cats.put(2, \"Sugar\");\n24: cats.put(1, \"Minnie Mouse\");\n25: cats.pollFirstEntry();\n26: var id = cats.lastEntry().getKey();\n27: cats.pollFirstEntry();\n28: System.out.print(cats.firstEntry().getValue());",
                "answer_options": [
                    "A. 1. Minnie Mouse",
                    "B. 2. Snowball",
                    "C. 3. Sugar",
                    "D. 4. The code does not compile.",
                    "E. 5. The code compiles, but an exception is thrown at runtime."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "22. B. The code compiles and runs without issue, so options D and E are\nincorrect. A TreeMap sorts its items in the natural order of keys (not the\nvalues). Therefore, lines 25 and 27 remove [1, Minnie Mouse] and\n[2, Sugar], respectively. Line 26 has no impact on the map. On line\n28, Snowball is printed, making option B correct. If line 26 were\nchanged to use pollLastEntry(), then the map would be empty and\nline 28 would throw a NullPointerException trying to call\ngetValue()."
            },
            {
                "id": "82f28a86-0199-1000-00ab-0000cd958282",
                "question": "23. What is the output of the following code snippet?\n\nvar fishes = new TreeSet<String>();\nfishes.add(\"Koi\");\nfishes.addFirst(\"clown\");\nfishes.add(\"carp\");\nfor(var fish : fishes)\nSystem.out.print(fish + \", \");",
                "answer_options": [
                    "A. 1. carp, clown, Koi,",
                    "B. 2. carp, Koi, clown,",
                    "C. 3. clown, carp, Koi,",
                    "D. 4. clown, Koi, carp,",
                    "E. 5. Koi, carp, clown,",
                    "F. 6. Koi, clown, carp,",
                    "G. 7. The code does not compile.",
                    "H. 8. The code compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    7
                ],
                "correct_answer_explanation": "23. H. TreeSet is a SequencedSet, so it does have an addFirst() method.\nFor this reason, the code does compile. Unfortunately, addFirst() is\nnot supported at runtime, as inserting an element at the front of the\nTreeSet could violate the Comparator of the TreeSet. For this reason,\nthe code program throws an UnsupportedOperationException on the\nthird line."
            },
            {
                "id": "82f28a86-0199-1000-33a9-0000ac38f980",
                "question": "1. What could be the output of the following?\n\nvar stream = Stream.iterate(\"\", (s) -> s + \"1\");\nSystem.out.println(stream.limit(2).map(x -> x + \"2\"));",
                "answer_options": [
                    "A. 12112",
                    "B. 212",
                    "C. 212112",
                    "D. java.util.stream.ReferencePipeline$3@4517d9a3",
                    "E. The code does not compile.",
                    "F. An exception is thrown.",
                    "G. The code hangs."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "1. D. No terminal operation is called, so the stream never executes. The\nfirst line creates an infinite stream reference. If the stream were\nexecuted on the second line, it would get the first two elements from\nthat infinite stream, \"\" and \"1\", and add an extra character, resulting in\n\"2\" and \"12\", respectively. Since the stream is not executed, the\nreference is printed instead, giving us option D."
            },
            {
                "id": "82f28a86-0199-1000-fb2d-00005aa69388",
                "question": "2. What could be the output of the following?\n\nPredicate<String> predicate = s -> s.startsWith(\"g\");\nvar stream1 = Stream.generate(() -> \"growl!\");\nvar stream2 = Stream.generate(() -> \"growl!\");\nvar b1 = stream1.anyMatch(predicate);\nvar b2 = stream2.allMatch(predicate);\nSystem.out.println(b1 + \" \" + b2);",
                "answer_options": [
                    "A. true false",
                    "B. true true",
                    "C. java.util.stream.ReferencePipeline$3@4517d9a3",
                    "D. The code does not compile.",
                    "E. An exception is thrown.",
                    "F. The code hangs."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "2. F. Both streams created in this code snippet are infinite streams. The\nvariable b1 is set to true since anyMatch() terminates. Even though\nthe stream is infinite, Java finds a match on the first element and stops\nlooking. However, when allMatch() runs, it needs to keep going until\nthe end of the stream since it keeps finding matches. Since all elements\ncontinue to match, the program hangs, making option F the answer."
            },
            {
                "id": "82f28a87-0199-1000-4930-0000be97b370",
                "question": "3. What could be the output of the following?\n\nPredicate<String> predicate = s -> s.length()> 3;\nvar stream = Stream.iterate(\"-\",\ns -> ! s.isEmpty(), (s) -> s + s);\nvar b1 = stream.noneMatch(predicate);\nvar b2 = stream.anyMatch(predicate);\nSystem.out.println(b1 + \" \" + b2);",
                "answer_options": [
                    "A. false false",
                    "B. false true",
                    "C. java.util.stream.ReferencePipeline$3@4517d9a3",
                    "D. The code does not compile.",
                    "E. An exception is thrown.",
                    "F. The code hangs."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "3. E. An infinite stream is generated where each element is twice as long\nas the previous one. While this code uses the three-parameter\niterate() method, the condition is never false. The variable b1 is set\nto false because Java finds an element that matches when it gets to\nthe element of length 4. However, the next line tries to operate on the\nsame stream. Since streams can be used only once, this throws an\nexception that the “stream has already been operated upon or closed,”\nmaking option E the answer. If two different streams were used, the\nresult would be option B."
            },
            {
                "id": "82f28a87-0199-1000-6ec2-0000e71c9603",
                "question": "4. Which are true statements about terminal operations in a stream that runs successfully?\n(Choose all that apply.)",
                "answer_options": [
                    "A. At most one terminal operation can exist in a stream pipeline.",
                    "B. Terminal operations are a required part of the stream pipeline in order to get a result.",
                    "C. Terminal operations have Stream as the return type.",
                    "D. The peek() method is an example of a terminal operation.",
                    "E. The referenced Stream may be used after calling a terminal operation."
                ],
                "correct_answer_indexes": [
                    0,
                    1
                ],
                "correct_answer_explanation": "4. A, B. Terminal operations are the final step in a stream pipeline.\nExactly one is required, because it triggers the execution of the entire\nstream pipeline. Therefore, options A and B are correct. Option C is\ntrue of intermediate operations rather than terminal operations. Option\nD is incorrect because peek() is an intermediate operation. Finally,\noption E is incorrect because once a stream pipeline is run, the Stream\nis marked invalid."
            },
            {
                "id": "82f28a87-0199-1000-d546-0000d53395ef",
                "question": "5. Which of the following sets result to 8.0? (Choose all that apply.)",
                "answer_options": [],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "5. C, F. Yes, we know this question is a lot of reading. Remember to look\nfor the differences between options rather than studying each line.\nThese options all have much in common. All of them start out with a\nLongStream and attempt to convert it to an IntStream. However,\noptions B and E are incorrect because they do not cast the long to an\nint, resulting in a compiler error on the mapToInt() calls.\nNext, we hit the second difference. Options A and D are incorrect\nbecause they are missing boxed() before the collect() call. Since\ngroupingBy() is creating a Collection, we need a nonprimitive\nStream. The final difference is that option F specifies the type of\nCollection. This is allowed, though, meaning both options C and F\nare correct."
            },
            {
                "id": "82f28a87-0199-1000-1ad2-0000341a32eb",
                "question": "6. Which of the following methods can fill in the blank so that the code prints out false?\n\nvar s = Stream.generate(() -> \"meow\");\nvar match = s.__________(String::isEmpty);\nSystem.out.println(match);",
                "answer_options": [
                    "A. Only allMatch",
                    "B. Only anyMatch",
                    "C. Only noneMatch",
                    "D. Both allMatch and anyMatch",
                    "E. Both allMatch and noneMatch",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "6. A. The anyMatch() and noneMatch() methods run infinitely. The\nstream has no way to know that a match won’t show up later. Option A\nis correct because only allMatch() makes it safe to return false as\nsoon as one element passes through the stream that doesn’t match."
            },
            {
                "id": "82f28a87-0199-1000-fce6-00004880d916",
                "question": "7. We have a method that returns a sorted list without changing the original. We want to\nrewrite it. Which of the following pairs can fill in the blanks in refactored() to do the\nsame with streams?\n\nprivate static List<String> sort(List<String> list) {\nvar copy = new ArrayList<String>(list);\nCollections.sort(copy, (a, b) -> b.compareTo(a));\nreturn copy;\n}\nprivate static List<String> refactored(List<String> list) {\nreturn list.stream()\n._______((a, b) -> b.compareTo(a))\n.__________;\n}",
                "answer_options": [
                    "A. compare and toList()",
                    "B. compare and sort()",
                    "C. compareTo and toList()",
                    "D. compareTo and sort()",
                    "E. sorted and collect()",
                    "F. sorted and collect(Collectors.toList())"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "7. F. There is no Stream<T> method called compare() or compareTo(), so\noptions A through D can be eliminated. The sorted() method is\ncorrect to use in a stream pipeline to return a sorted Stream and fills in\nthe first blank. Either toList() or collect(Collectors.toList())\ncan fill in the second blank. Only one answer correctly fills in both\nblanks, and therefore option F is correct."
            },
            {
                "id": "82f28a87-0199-1000-735e-00006b54badb",
                "question": "8. Which of the following are true given this declaration? (Choose all that apply.)\n\nvar is = IntStream.empty();",
                "answer_options": [
                    "A. is.average() returns the type int.",
                    "B. is.average() returns the type OptionalInt.",
                    "C. is.findAny() returns the type int.",
                    "D. is.findAny() returns the type OptionalInt.",
                    "E. is.sum() returns the type int.",
                    "F. is.sum() returns the type OptionalInt."
                ],
                "correct_answer_indexes": [
                    3,
                    4
                ],
                "correct_answer_explanation": "8. D, E. The average() method returns an OptionalDouble since\naverages of any type can result in a fraction. Therefore, options A and\nB are both incorrect. The findAny() method returns an OptionalInt\nbecause there might not be any elements to find. Therefore, option D is\ncorrect. The sum() method returns an int rather than an OptionalInt\nbecause the sum of an empty stream is zero. Therefore, option E is\ncorrect."
            },
            {
                "id": "82f28a87-0199-1000-af4b-0000238bb90e",
                "question": "9. Which of the following can we add after line 6 for the code to run without error and not\nproduce any output? (Choose all that apply.)\n\n4: var stream = LongStream.of(1, 2, 3);\n5: var opt = stream.map(n -> n * 10)\n6: .filter(n -> n < 5).findFirst();",
                "answer_options": [
                    "E. None of these; the code does not compile.",
                    "F. None of these; line 6 throws an exception at runtime."
                ],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "9. B, D. Lines 4–6 compile and run without issue, making options E and\nF incorrect. Line 4 creates a stream of elements [1, 2, 3]. Line 5\nmaps the stream to a new stream with values [10, 20, 30]. Line 6\nfilters out all items not less than 5, which in this case results in an\nempty stream. For this reason, findFirst() returns an empty\nOptional.\nOption A does not compile. It would work for a Stream<T> object, but\nwe have a LongStream and therefore need to call getAsLong(). Option\nC also does not compile, as it is missing the :: that would make it a\nmethod reference. Options B and D both compile and run without\nerror, although neither produces any output at runtime since the stream\nis empty."
            },
            {
                "id": "82f28a87-0199-1000-cfd4-000074347c6f",
                "question": "10. Given the four statements (L, M, N, O), select the order that would cause the code to output \n10 lines.\nStream.generate(() -> \"1\")\n\nL: .filter(x -> x.length()> 1)\nM: .forEach(System.out::println)\nN: .limit(10)\nO: .peek(System.out::println)\n;",
                "answer_options": [
                    "A. L, N",
                    "B. L, N, O",
                    "C. L, N, M",
                    "D. L, N, M, O",
                    "E. L, O, M",
                    "F. N, M",
                    "G. N, O"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "10. F. Only one of the method calls, forEach(), is a terminal operation, so\nany answer in which M is not the last line will not execute the pipeline.\nThis eliminates all but options C, E, and F. Option C is incorrect\nbecause filter() is called before limit(). Since none of the elements\nof the stream meets the requirement for the Predicate<String>, the\nfilter() operation will run infinitely, never passing any elements to\nlimit(). Option E is incorrect because there is no limit() operation,\nwhich means that the code would run infinitely. Option F is correct. It\nfirst limits the infinite stream to a finite stream of 10 elements and then\nprints the result."
            },
            {
                "id": "82f28a87-0199-1000-1f2d-0000aea35a4e",
                "question": "11. What changes need to be made together for this code to print the string 12345? (Choose all\nthat apply.)\n\nStream.iterate(1, x -> x++)\n.limit(5).map(x -> x)\n.collect(Collectors.joining());",
                "answer_options": [
                    "A. Changing Collectors.joining() to Collectors.joining(\",\")",
                    "B. Changing map(x -> x) to map(x -> \"\" + x)",
                    "C. Changing x -> x++ to x -> ++x",
                    "D. Adding .forEach(System.out::print) after the call to collect()",
                    "E. Wrapping the entire line in a System.out.print statement",
                    "F. None of the above; the code already prints 12345"
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    4
                ],
                "correct_answer_explanation": "11. B, C, E. As written, the code doesn’t compile because the\nCollectors.joining() expects to get a Stream<String>. Option B\nfixes this, at which point nothing is output because the collector\ncreates a String without outputting the result. Option E fixes this and\ncauses the output to be 11111. Since the post-increment operator is\nused, the stream contains an infinite number of the character 1. Option\nC fixes this and causes the stream to contain increasing numbers."
            },
            {
                "id": "82f28a87-0199-1000-84eb-000077f452fb",
                "question": "12. Which is true of the following code?\n\nSet<String> birds = Set.of(\"oriole\", \"flamingo\");\nStream.concat(birds.stream(), birds.stream(), birds.stream())\n.sorted() // line X\n.distinct()\n.findAny()\n.ifPresent(System.out::println);",
                "answer_options": [
                    "A. It is guaranteed to print flamingo as is and when line X is removed.",
                    "B. It is guaranteed to print oriole as is and when line X is removed.",
                    "C. It is guaranteed to print flamingo as is, but not when line X is removed.",
                    "D. It is guaranteed to print oriole as is, but not when line X is removed.",
                    "E. The output may vary as is.",
                    "F. The code does not compile.",
                    "G. It throws an exception because the same list is used as the source for multiple streams."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "12. F. The code does not compile because Stream.concat() takes two\nparameters, not the three provided. This makes the answer option F."
            },
            {
                "id": "82f28a87-0199-1000-66e7-0000babcc5fc",
                "question": "13. Which of the following is true?\n\nList<Integer> x1 = List.of(1, 2, 3);\nList<Integer> x2 = List.of(4, 5, 6);\nList<Integer> x3 = List.of();\nStream.of(x1, x2, x3).map(x -> x + 1)\n.flatMap(x -> x.stream())\n.forEach(System.out::print);",
                "answer_options": [
                    "A. The code compiles and prints 123456.",
                    "B. The code compiles and prints 234567.",
                    "C. The code compiles but does not print anything.",
                    "D. The code compiles but prints stream references.",
                    "E. The code runs infinitely.",
                    "F. The code does not compile.",
                    "G. The code throws an exception."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "13. F. If the map() and flatMap() calls were reversed, option B would be\ncorrect. In this case, the Stream created from the source is of type\nStream<List>. Trying to use the addition operator (+) on a List is not\nsupported in Java. Therefore, the code does not compile, and option F\nis correct."
            },
            {
                "id": "82f28a87-0199-1000-33af-000007ac3a2f",
                "question": "14. Which of the following are true? (Choose all that apply.)\n\n4: Stream<Integer> s = Stream.of(1);\n5: IntStream is = s.boxed();\n6: DoubleStream ds = s.mapToDouble(x -> x);\n7: Stream<Integer> s2 = ds.mapToInt(x -> x);\n8: s2.forEach(System.out::print);",
                "answer_options": [
                    "A. Line 4 causes a compiler error.",
                    "B. Line 5 causes a compiler error.",
                    "C. Line 6 causes a compiler error.",
                    "D. Line 7 causes a compiler error.",
                    "E. Line 8 causes a compiler error.",
                    "F. The code compiles but throws an exception at runtime.",
                    "G. The code compiles and prints 1."
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "14. B, D. Line 4 creates a Stream and uses autoboxing to put the Integer\nwrapper of 1 inside. Line 5 does not compile because boxed() is\navailable only on primitive streams like IntStream, not\nStream<Integer>. This makes option B one answer. Line 6 converts to\na double primitive, which works since Integer can be unboxed to a\nvalue that can be implicitly cast to a double. Line 7 does not compile\nfor two reasons, making option D the second answer. First, converting\nfrom a double to an int would require an explicit cast. Also,\nmapToInt() returns an IntStream, so the data type of s2 is incorrect.\nThe rest of the lines compile without issue."
            },
            {
                "id": "82f28a87-0199-1000-5d15-000000f62b96",
                "question": "15. Given the generic type String, the partitioningBy() collector creates a Map<Boolean,\nList<String>> when passed to collect() by default. When a downstream collector is\npassed to partitioningBy(), which return types can be created? (Choose all that apply.)",
                "answer_options": [
                    "A. Map<boolean, List<String>>",
                    "B. Map<Boolean, List<String>>",
                    "C. Map<Boolean, Map<String>>",
                    "D. Map<Boolean, Set<String>>",
                    "E. Map<Long, TreeSet<String>>",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "15. B, D. Options A and C do not compile because they are invalid generic\ndeclarations. Primitives are not allowed as generics, and Map must have\ntwo generic type parameters. Option E is incorrect because partitioning\nonly gives a Boolean key. Options B and D are correct because they\nreturn a Map with a Boolean key and a value type that can be\ncustomized to any Collection."
            },
            {
                "id": "82f28a87-0199-1000-fd05-00004cc9204a",
                "question": "16. Which of the following statements are true about this code? (Choose all that apply.)\n\n20: Predicate<String> empty = String::isEmpty;\n21: Predicate<String> notEmpty = empty.negate();\n22:\n23: var result = Stream.generate(() -> \"\")\n24: .limit(10)\n25: .filter(notEmpty)\n26: .collect(Collectors.groupingBy(k -> k))\n27: .entrySet()\n28: .stream()\n29: .map(Entry::getValue)\n30: .flatMap(Collection::stream)\n31: .collect(Collectors.partitioningBy(notEmpty));\n32: System.out.println(result);",
                "answer_options": [
                    "A. It outputs {}.",
                    "B. It outputs {false=[], true=[]}.",
                    "C. If we changed line 31 from partitioningBy(notEmpty) to groupingBy(n -> n), it",
                    "D. If we changed line 31 from partitioningBy(notEmpty) to groupingBy(n -> n), it",
                    "E. The code does not compile.",
                    "F. The code compiles but does not terminate at runtime."
                ],
                "correct_answer_indexes": [
                    1,
                    2
                ],
                "correct_answer_explanation": "16. B, C. First, this mess of code does compile. While it starts with an\ninfinite stream on line 23, it becomes finite on line 24 thanks to\nlimit(), making option F incorrect. The pipeline preserves only\nnonempty elements on line 25. Since there aren’t any of those, the\npipeline is empty. Line 26 converts this to an empty map.\nLines 27 and 28 create a Set with no elements and then another empty\nstream. Lines 29 and 30 convert the generic type of the Stream to\nList<String> and then String. Finally, line 31 gives us another\nMap<Boolean, List<String>>.\nThe partitioningBy() operation always returns a map with two\nBoolean keys, even if there are no corresponding values. Therefore,\noption B is correct if the code is kept as is. By contrast, groupingBy()\nreturns only keys that are actually needed, making option C correct if\nthe code is modified on line 31."
            },
            {
                "id": "82f28a87-0199-1000-c382-000073d36d09",
                "question": "17. What is the result of the following?\n\nvar s = DoubleStream.of(1.2, 2.4);\ns.peek(System.out::println).filter(x -> x> 2).count();",
                "answer_options": [
                    "A. 1",
                    "B. 2",
                    "C. 2.4",
                    "D. 1.2 and 2.4",
                    "E. There is no output.",
                    "F. The code does not compile.",
                    "G. An exception is thrown."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "17. D. The terminal operation is count(). Since there is a terminal\noperation, the intermediate operations run. The peek() operation\ncomes before the filter(), so both numbers are printed, making\noption D the answer. After the filter(), the count() happens to be 1\nsince one of the numbers is filtered out. However, the result of the\nstream pipeline isn’t stored in a variable or printed, and it is ignored."
            },
            {
                "id": "82f28a87-0199-1000-40fc-00002fa32858",
                "question": "18. What is the output of the following?\n\n11: public class Paging {\n12: record Sesame(String name, boolean human) {\n13: @Override public String toString() {\n14: return name();\n15: }\n16: }\n17: record Page(List<Sesame> list, long count) {}\n18:\n19: public static void main(String[] args) {\n20: var monsters = Stream.of(new Sesame(\"Elmo\", false));\n21: var people = Stream.of(new Sesame(\"Abby\", true));\n22: printPage(monsters, people);\n23: }\n24:\n25: private static void printPage(Stream<Sesame> monsters,\n26: Stream<Sesame> people) {\n27: Page page = Stream.concat(monsters, people)\n28: .collect(Collectors.teeing(\n29: Collectors.filtering(s -> s.name().startsWith(\"E\"),\n30: Collectors.toList()),\n31: Collectors.counting(),\n32: (l, c) -> new Page(l, c)));\n33: System.out.println(page);\n34: } }",
                "answer_options": [
                    "A. Page[list=[Abby], count=1]",
                    "B. Page[list=[Abby], count=2]",
                    "C. Page[list=[Elmo], count=1]",
                    "D. Page[list=[Elmo], count=2]",
                    "E. The code does not compile due to Stream.concat().",
                    "F. The code does not compile due to Collectors.teeing().",
                    "G. The code does not compile for another reason."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "18. D. This compiles, ruling out options E, F, and G. Since line 29 filters\nby names starting with E, that rules out options A and B. Finally, line\n31 counts the entire list, which is of size 2, giving us option D as the\nanswer."
            },
            {
                "id": "82f28a88-0199-1000-de4b-0000f4cf64fb",
                "question": "19. What is the simplest way of rewriting this code?\n\nList<Integer> x = IntStream.range(1, 6)\n.mapToObj(i -> i)\n.collect(Collectors.toList());\nx.forEach(System.out::println);",
                "answer_options": [
                    "D. None of the above is equivalent.",
                    "E. The provided code does not compile."
                ],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "19. B. Both lists and streams have forEach() methods. There is no reason\nto collect into a list just to loop through it. Option A is incorrect\nbecause it does not contain a terminal operation or print anything.\nOptions B and C both work. However, the question asks about the\nsimplest way, which is option B."
            },
            {
                "id": "82f28a88-0199-1000-f208-000001098499",
                "question": "20. Which of the following throw an exception when an Optional is empty? (Choose all that\napply.)",
                "answer_options": [
                    "A. opt.orElse(\"\");",
                    "B. opt.orElseGet(() -> \"\");",
                    "C. opt.orElseThrow();",
                    "D. opt.orElseThrow(() -> throw new Exception());",
                    "E. opt.orElseThrow(RuntimeException::new);",
                    "F. opt.get();",
                    "G. opt.get(\"\");"
                ],
                "correct_answer_indexes": [
                    2,
                    4,
                    5
                ],
                "correct_answer_explanation": "20. C, E, F. Options A and B compile and return an empty string without\nthrowing an exception, using a String and Supplier parameter,\nrespectively. Option G does not compile as the get() method does not\ntake a parameter. Options C and F throw a NoSuchElementException.\nOption E throws a RuntimeException. Option D looks correct but will\ncompile only if the throw is removed. Remember, the orElseThrow()\nshould get a lambda expression or method reference that returns an\nexception, not one that throws an exception."
            },
            {
                "id": "82f28a88-0199-1000-7f85-00005ef5b5df",
                "question": "21. What is the output of the following?\n\nvar spliterator = Stream.generate(() -> \"x\")\n.spliterator();\nspliterator.tryAdvance(System.out::print);\nvar split = spliterator.trySplit();\nsplit.tryAdvance(System.out::print);",
                "answer_options": [
                    "A. x",
                    "B. xx",
                    "C. A long list of x’s.",
                    "D. There is no output.",
                    "E. The code does not compile.",
                    "F. The code compiles but does not terminate at runtime."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "21. B. We start with an infinite stream where each element is x. The\nspliterator() method is a terminal operation since it returns a\nSpliterator rather than a Stream. The tryAdvance() method gets the\nfirst element and prints a single x. The trySplit() method takes a\nlarge number of elements from the stream. Since this is an infinite\nstream, it doesn’t attempt to take half. Then tryAdvance() is called on\nthe new split variable, and another x is printed. Since there are two\nvalues printed, option B is correct."
            },
            {
                "id": "82f28a88-0199-1000-47aa-0000b4a518b0",
                "question": "1. Which of the following can be inserted on line 8 to make this code\ncompile? (Choose all that apply.)\n\n7: public void whatHappensNext() throws IOException {\n8: // INSERT CODE HERE\n9: }",
                "answer_options": [
                    "A. System.out.println(\"it’s ok\");",
                    "B. throw new Exception();",
                    "C. throw new IllegalArgumentException();",
                    "D. throw new java.io.IOException();",
                    "E. throw new RuntimeException();",
                    "F. None of the above"
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    3,
                    4
                ],
                "correct_answer_explanation": "1. A, C, D, E. A method that declares an exception isn’t required to throw\none, making option A correct. Unchecked exceptions can be thrown in\nany method, making options C and E correct. Option D matches the\nexception type declared, so it’s also correct. Option B is incorrect\nbecause a broader exception is not allowed."
            },
            {
                "id": "82f28a88-0199-1000-e0e8-0000810d0187",
                "question": "2. Which statement about the following class is correct?\n\n1: class Problem extends Exception {\n2: public Problem() {}\n3: }\n4: class YesProblem extends Problem {}\n5: public class MyDatabase {\n6: public static void connectToDatabase() throw Problem\n{\n7: throws new YesProblem();\n8: }\n9: public static void main(String[] c) throw Exception\n{\n10: connectToDatabase();\n11: }\n12: }",
                "answer_options": [
                    "A. The code compiles and prints a stack trace for YesProblem at",
                    "B. The code compiles and prints a stack trace for Problem at",
                    "C. The code does not compile because Problem defines a",
                    "D. The code does not compile because YesProblem does not define a",
                    "E. The code does not compile but would if Problem and YesProblem",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "2. F. The code does not compile because the throw and throws keywords\nare incorrectly used on lines 6, 7, and 9. If the keywords were fixed,\nthe rest of the code would compile and print a stack trace with\nYesProblem at runtime. For this reason, option F is correct."
            },
            {
                "id": "82f28a88-0199-1000-73df-0000df66fe0a",
                "question": "3. Which of the following are common types to localize? (Choose all that\napply.)",
                "answer_options": [
                    "A. Dates",
                    "B. Lambda expressions",
                    "C. Class names",
                    "D. Currency",
                    "E. Numbers",
                    "F. Variable names"
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    4
                ],
                "correct_answer_explanation": "3. A, D, E. Localization refers to user-facing elements. Dates, currency,\nand numbers are commonly used in different formats for different\ncountries, making options A, D, and E correct. Class and variable\nnames, along with lambda expressions, are internal to the application,\nso there is no need to translate them for users."
            },
            {
                "id": "82f28a88-0199-1000-6e4c-000052fa4985",
                "question": "4. What is the output of the following snippet, assuming a and b are both\n0?\n\n3: try {\n4: System.out.print(a / b);\n5: } catch (RuntimeException e) {\n6: System.out.print(-1);\n7: } catch (ArithmeticException e) {\n8: System.out.print(0);\n9: } finally {\n10: System.out.print(\"done\");\n11: }",
                "answer_options": [
                    "A. -1",
                    "B. 0",
                    "C. done-1",
                    "D. done0",
                    "E. The code does not compile.",
                    "F. An uncaught exception is thrown.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "4. E. The order of catch blocks is important because they’re checked in\nthe order they appear after the try block. Because\nArithmeticException is a child class of RuntimeException, the\ncatch block on line 7 is unreachable (if an ArithmeticException is\nthrown in the try block, it will be caught on line 5). Line 7 generates a\ncompiler error because it is unreachable code, making option E\ncorrect."
            },
            {
                "id": "82f28a88-0199-1000-c63c-00000ea53ea9",
                "question": "5. Assuming the current locale uses dollars ($) and the following method\nis called with a double value of 100_102.2, which of the following\nvalues are printed? (Choose all that apply.)\n\npublic void print(double t) {\nSystem.out.print(NumberFormat.getCompactNumberInstance().fo\nrmat(t));\nSystem.out.print(\nNumberFormat.getCompactNumberInstance(\nLocale.getDefault(), Style.SHORT).format(t));\nSystem.out.print(NumberFormat.getCurrencyInstance().format(\nt));\n}",
                "answer_options": [
                    "A. 100",
                    "B. $100,000.00",
                    "C. 100K",
                    "D. 100 thousand",
                    "E. 100M",
                    "F. $100,102.20",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    2,
                    5
                ],
                "correct_answer_explanation": "5. C, F. The code compiles and runs without issue. When a\nCompactNumberFormat instance is requested without a style, it uses the\nSHORT style by default. This results in both of the first two statements\nprinting 100K, making option C correct. If the LONG style were used,\nthen 100 thousand would be printed. Option F is also correct, as the\nfull value is printed with a currency formatter."
            },
            {
                "id": "82f28a88-0199-1000-58b5-00001657cd41",
                "question": "6. What is the output of the following code?\n\nLocalDate date = LocalDate.parse(\"2025-04-30\",\nDateTimeFormatter.ISO_LOCAL_DATE_TIME);\nSystem.out.println(date.getYear() + \" \"\n+ date.getMonth() + \" \"+ date.getDayOfMonth());",
                "answer_options": [
                    "A. 2025 APRIL 2",
                    "B. 2025 APRIL 30",
                    "C. 2025 MAY 2",
                    "D. The code does not compile.",
                    "E. A runtime exception is thrown."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "6. E. A LocalDate does not have a time element. Therefore, a date/time\nformatter is not appropriate. The code compiles but throws an\nexception at runtime, making option E correct. If ISO_LOCAL_DATE\nwere used, the code would print 2025 APRIL 30."
            },
            {
                "id": "82f28a88-0199-1000-583d-0000c80cf073",
                "question": "7. What does the following method print?\n\n11: public void tryAgain(String s) {\n12: try (FileReader r = null, p = new FileReader(\"\")) {\n13: System.out.print(\"X\");\n14: throw new IllegalArgumentException();\n15: } catch (Exception s) {\n16: System.out.print(\"A\");\n17: throw new FileNotFoundException();\n18: } finally {\n19: System.out.print(\"O\");\n20: }\n21: }",
                "answer_options": [
                    "A. XAO",
                    "B. XOA",
                    "C. One line of this method contains a compiler error.",
                    "D. Two lines of this method contain compiler errors.",
                    "E. Three or more lines of this method contain compiler errors.",
                    "F. The code compiles, but a NullPointerException is thrown at",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "7. E. The first compiler error is on line 12 because each resource in a try-\nwith-resources statement must have its own data type and be separated\nby a semicolon (;). Line 15 does not compile because the variable s is\nalready declared in the method. Line 17 also does not compile. The\nFileNotFoundException, which inherits from IOException and\nException, is a checked exception, so it must be handled or declared\nby the method. Because these three lines of code do not compile,\noption E is the correct answer."
            },
            {
                "id": "82f28a88-0199-1000-2d1b-000018316090",
                "question": "8. Assume that all of the files mentioned in the answer choices exist and\ndefine the same keys. Which one will be used to find the key in line 8?\n\n6: Locale.setDefault(Locale.of(\"en\", \"US\"));\n7: var b = ResourceBundle.getBundle(\"Dolphins\");\n8: System.out.println(b.getString(\"name\"));",
                "answer_options": [
                    "A. Dolphins.properties",
                    "B. Dolphins_US.properties",
                    "C. Dolphins_en.properties",
                    "D. Whales.properties",
                    "E. Whales_en_US.properties",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "8. C. Java will first look for the most specific matches it can find, starting\nwith Dolphins_en_US.properties. Since that is not an answer choice,\nit drops the country and looks for Dolphins_en.properties, making\noption C correct. Option B is incorrect because a country without a\nlanguage is not a valid locale."
            },
            {
                "id": "82f28a88-0199-1000-c912-0000fd5750af",
                "question": "9. For what value of pattern will the following print <005.21>\n<008.49> <1,234.0>?\n\nString pattern = \"____________________\";\nvar message = DoubleStream.of(5.21, 8.49, 1234)\n.mapToObj(v -> new DecimalFormat(pattern).format(v))\n.collect(Collectors.joining(\"> <\"));\nSystem.out.println(\"<\"+message+\">\");",
                "answer_options": [
                    "A. ##.#",
                    "B. 0,000.0#",
                    "C. #,###.0",
                    "D. #,###,000.0#",
                    "E. The code does not compile regardless of what is placed in the",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "9. D. When working with a custom number formatter, the 0 symbol\ndisplays the digit as 0, even if it’s not present, while the # symbol\nomits the digit from the start or end of the String if it is not present.\nBased on the requested output, a format that displays at least three\ndigits before the decimal (including a comma) and at least one after the\ndecimal is required. It should display a second digit after the decimal if\none is available. For this reason, option D is the correct answer."
            },
            {
                "id": "82f28a88-0199-1000-9efb-0000549eadb7",
                "question": "10. Which scenario is the best use of an exception?",
                "answer_options": [
                    "A. An element is not found when searching a list.",
                    "B. An unexpected parameter is passed into a method.",
                    "C. The computer caught fire.",
                    "D. You want to loop through a list.",
                    "E. You don’t know how to code a method."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "10. B. An IllegalArgumentException is used when an unexpected\nparameter is passed into a method, making option B correct. Option A\nis incorrect because returning null or -1 is a common return value for\nsearching for data. Option D is incorrect because a for loop is\ntypically used for this scenario. Option E is incorrect because you\nshould find out how to code the method and not leave it for the\nunsuspecting programmer who calls your method. Option C is\nincorrect because you should run!"
            },
            {
                "id": "82f28a88-0199-1000-70bb-00000fbfd9af",
                "question": "11. Which of the following exceptions must be handled or declared in the\nmethod in which they are thrown? (Choose all that apply.)\n\nclass Apple extends RuntimeException {}\nclass Orange extends Exception {}\nclass Banana extends Error {}\nclass Pear extends Apple {}\nclass Tomato extends Orange {}\nclass Peach extends Throwable {}",
                "answer_options": [
                    "A. Apple",
                    "B. Orange",
                    "C. Banana",
                    "D. Pear",
                    "E. Tomato",
                    "F. Peach"
                ],
                "correct_answer_indexes": [
                    1,
                    4,
                    5
                ],
                "correct_answer_explanation": "11. B, E, F. An exception that must be handled or declared is a checked\nexception. A checked exception inherits Exception but not\nRuntimeException. The entire hierarchy counts, so options B and E\nare both correct. Option F is also correct, as a class that inherits\nThrowable but not RuntimeException or Error is also checked."
            },
            {
                "id": "82f28a88-0199-1000-1a35-0000491174ad",
                "question": "12. Which of the following changes, when made independently, would\nmake this code compile? (Choose all that apply.)\n\n1: import java.io.*;\n2: public class StuckTurkeyCage implements AutoCloseable {\n3: public void close() throws IOException {\n4: throw new FileNotFoundException(\"Cage not\nclosed\");\n5: }\n6: public static void main(String[] args) {\n7: try (StuckTurkeyCage t = new StuckTurkeyCage()) {\n8: System.out.println(\"put turkeys in\");\n9: }\n10: } }",
                "answer_options": [
                    "A. Remove throws IOException from the declaration on line 3.",
                    "B. Add throws Exception to the declaration on line 6.",
                    "C. Change line 9 to } catch (Exception e) {}.",
                    "D. Change line 9 to } finally {}.",
                    "E. The code compiles as is.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    1,
                    2
                ],
                "correct_answer_explanation": "12. B, C. The code does not compile as is because the exception declared\nby the close() method must be handled or declared. Option A is\nincorrect because removing the exception from the declaration causes\na compilation error on line 4, as FileNotFoundException is a checked\nexception that must be handled or declared. Option B is correct\nbecause the unhandled exception within the main() method becomes\ndeclared. Option C is also correct because the exception becomes\nhandled. Option D is incorrect because the exception remains\nunhandled."
            },
            {
                "id": "82f28a88-0199-1000-1d46-0000fa42455d",
                "question": "13. Which of the following are true statements about exception handling in\nJava? (Choose all that apply.)",
                "answer_options": [
                    "A. A traditional try statement without a catch block requires a",
                    "B. A traditional try statement without a finally block requires a",
                    "C. A traditional try statement with only one statement can omit the",
                    "D. A try-with-resources statement without a catch block requires a",
                    "E. A try-with-resources statement without a finally block requires",
                    "F. A try-with-resources statement with only one statement can omit"
                ],
                "correct_answer_indexes": [
                    0,
                    1
                ],
                "correct_answer_explanation": "13. A, B. A try-with-resources statement does not require a catch or\nfinally block. A traditional try statement requires at least one of the\ntwo. Neither statement can be written without a body encased in\nbraces, {}. For these reasons, options A and B are correct."
            },
            {
                "id": "82f28a88-0199-1000-d9bb-0000f878c6e8",
                "question": "14. Assuming -g:vars is used when the code is compiled to include debug\ninformation, what is the output of the following code snippet?\n\nvar huey = (String)null;\nInteger dewey = null;\nObject louie = null;\nif(louie == huey.substring(dewey.intValue())) {\nSystem.out.println(\"Quack!\");\n}",
                "answer_options": [
                    "A. A NullPointerException that does not include any variable",
                    "B. A NullPointerException naming huey in the stack trace",
                    "C. A NullPointerException naming dewey in the stack trace",
                    "D. A NullPointerException naming louie in the stack trace",
                    "E. A NullPointerException naming huey and louie in the stack",
                    "F. A NullPointerException naming huey and dewey in the stack",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "14. C. NullPointerException stack trac iesnclude the name of the\nvariable that is null by default, making option A incorrect. The first\nNullPointerException encountered at runtime is when\ndewey.intValue() is called, making option C correct. Options E and F\nare incorrect as only one NullPointerException exception can be\nthrown at a time."
            },
            {
                "id": "82f28a88-0199-1000-1303-0000e7970f80",
                "question": "15. Which of the following, when inserted independently in the blank, use\nlocale parameters that are properly formatted? (Choose all that apply.)\n\nimport java.util.Locale;\npublic class ReadMap implements AutoCloseable {\nprivate Locale locale;\nprivate boolean closed = false;\n@Override public void close() {\nSystem.out.println(\"Folding map\");\nlocale = null;\nclosed = true;\n}\npublic void open() {\nthis.locale = ____________;\n}\npublic void use() {\n// Implementation omitted\n}\n}",
                "answer_options": [
                    "A. Locale.of(\"xM\")",
                    "B. Locale.of(\"MQ\", \"ks\")",
                    "C. Locale.of(\"qw\")",
                    "D. Locale.of(\"wp\", \"VW\")",
                    "E. Locale.create(\"zp\")",
                    "F. new Locale.Builder().setLanguage(\"yw\").setRegion(\"PM\")",
                    "G. The code does not compile regardless of what is placed in the"
                ],
                "correct_answer_indexes": [
                    2,
                    3
                ],
                "correct_answer_explanation": "15. C, D. The code compiles with the appropriate locale, so option G is\nincorrect. A locale consists of a required lowercase language code and\noptional uppercase country code. In the Locale.of() method, the\nlanguage code is provided first. For these reasons, options C and D are\ncorrect. Option E is incorrect because a Locale is created using the\nLocale.of() method or Locale.Builder class. Option F is really\nclose but is missing build() at the end. Without that, option F does\nnot compile."
            },
            {
                "id": "82f28a89-0199-1000-0846-00005366784e",
                "question": "16. Which of the following can be inserted into the blank to allow the code\nto compile and run without throwing an exception?\n\nvar f = DateTimeFormatter.ofPattern(\"hh o'clock\");\nSystem.out.println(f.format(___________________.now()));",
                "answer_options": [
                    "A. ZonedTime",
                    "B. LocalDate",
                    "C. LocalTimestamp",
                    "D. LocalTime",
                    "E. The code does not compile regardless of what is placed in the",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "16. F. When creating a custom formatter, any nonsymbol code must be\nproperly escaped using pairs of single quotes (’). In this case, it fails\nbecause o is not a symbol. Even if you didn’t know o wasn’t a symbol,\nthe code contains an unmatched single quote. If the properly escaped\nvalue of \"hh’ o’’clock’\" were used, then the correct answer would\nbe option D, LocalTime. Without this change, though, the code throws\nan exception at runtime, making option F the correct answer. Option B\nwould not be correct because LocalDate values do not have an hour\npart. Options A and C are incorrect because ZonedTime and\nLocalTimestamp are not valid date/time classes."
            },
            {
                "id": "82f28a89-0199-1000-e483-000037b33148",
                "question": "17. Which of the following statements about resource bundles are correct?\n(Choose all that apply.)",
                "answer_options": [
                    "A. All keys must be in the same resource bundle to be used.",
                    "B. A resource bundle is loaded by calling the new",
                    "C. Resource bundle values are always read using the Properties",
                    "D. Changing the default locale lasts for only a single run of the",
                    "E. If a resource bundle for a specific locale is requested, then the",
                    "F. It is possible to use a resource bundle for a locale without"
                ],
                "correct_answer_indexes": [
                    3,
                    5
                ],
                "correct_answer_explanation": "17. D, F. Option A is incorrect because Java will look at parent bundles if\na key is not found in a specified resource bundle. Option B is incorrect\nbecause resource bundles are loaded from static factory methods.\nOption C is incorrect, as resource bundle values are read from the\nResourceBundle object directly. Option D is correct because the locale\nis changed only in memory. Option E is incorrect, as the resource\nbundle for the default locale may be used if there is no resource bundle\nfor the specified locale (or its locale without a country code). Finally,\noption F is correct. The JVM will set a default locale automatically."
            },
            {
                "id": "82f28a89-0199-1000-f062-0000339a1272",
                "question": "18. What is the output of the following code?\n\nimport java.io.*;\npublic class FamilyCar {\nstatic class Door implements AutoCloseable {\npublic void close() {\nSystem.out.print(\"D\");\n} }\nstatic class Window implements Closeable {\npublic void close() {\nSystem.out.print(\"W\");\nthrow new RuntimeException();\n} }\npublic static void main(String[] args) {\nvar d = new Door();\ntry (d; var w = new Window()) {\nSystem.out.print(\"T\");\n} catch (Exception e) {\nSystem.out.print(\"E\");\n} finally {\nSystem.out.print(\"F\");\n} } }",
                "answer_options": [
                    "A. TWF",
                    "B. TWDF",
                    "C. TWDEF",
                    "D. TWF followed by an exception",
                    "E. TWDF followed by an exception",
                    "F. TWEF followed by an exception",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "18. C. After both resources are declared and created in the try-with-\nresources statement, T is printed as part of the body. Then the try-with-\nresources completes and closes the resources in the reverse of the order\nin which they were declared. After W is printed, an exception is thrown.\nHowever, the remaining resource still needs to be closed, so D is\nprinted. Once all the resources are closed, the exception is thrown and\nswallowed in the catch block, causing E to be printed. Last, the\nfinally block is run, printing F. Therefore, the answer is TWDEF and\noption C is correct."
            },
            {
                "id": "82f28a89-0199-1000-c698-000073b345d3",
                "question": "19. Suppose that we have the following three properties files and code.\nWhich bundles are used on lines 8 and 9, respectively?\n\nDolphins.properties\nname=The Dolphin\nage=0\nDolphins_en.properties\nname=Dolly\nage=4\nDolphins_fr.properties\nname=Dolly\n\n5: var fr = Locale.of(\"fr\");\n6: Locale.setDefault(Locale.of(\"en\", \"US\"));\n7: var b = ResourceBundle.getBundle(\"Dolphins\", fr);\n8: b.getString(\"name\");\n9: b.getString(\"age\");",
                "answer_options": [
                    "A. Dolphins.properties and Dolphins.properties",
                    "B. Dolphins.properties and Dolphins_en.properties",
                    "C. Dolphins_en.properties and Dolphins_en.properties",
                    "D. Dolphins_fr.properties and Dolphins.properties",
                    "E. Dolphins_fr.properties and Dolphins_en.properties",
                    "F. The code does not compile.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "19. D. Java will use Dolphins_fr.properties as the matching resource\nbundle on line 7 because it is an exact match on the language of the\nrequested locale. Line 8 finds a matching key in this file. Line 9 does\nnot find a match in that file; therefore, it has to look higher up in the\nhierarchy. Once a bundle is chosen, only resources in that hierarchy are\nallowed. It cannot use the default locale anymore, but it can use the\ndefault resource bundle specified by Dolphins.properties. For these\nreasons, option D is correct."
            },
            {
                "id": "82f28a89-0199-1000-56dc-00009d5da0b9",
                "question": "20. What is printed by the following program?\n\n1: public class DriveBus {\n2: public void go() {\n3: System.out.print(\"A\");\n4: try {\n5: stop();\n6: } catch (ArithmeticException e) {\n7: System.out.print(\"B\");\n8: } finally {\n9: System.out.print(\"C\");\n10: }\n11: System.out.print(\"D\");\n12: }\n13: public void stop() {\n14: System.out.print(\"E\");\n15: Object x = null;\n16: x.toString();\n17: System.out.print(\"F\");\n18: }\n19: public static void main(String n[]) {\n20: new DriveBus().go();\n21: } }",
                "answer_options": [
                    "A. AE",
                    "B. AEBCD",
                    "C. AEC",
                    "D. AECD",
                    "E. AE followed by a stack trace",
                    "F. AEBCD followed by a stack trace",
                    "G. AEC followed by a stack trace",
                    "H. A stack trace with no other output"
                ],
                "correct_answer_indexes": [
                    6
                ],
                "correct_answer_explanation": "20. G. The main() method invokes go(), and A is printed on line 3. The\nstop() method is invoked, and E is printed on line 14. Line 16 throws\na NullPointerException, so stop() immediately ends, and line 17\ndoesn’t execute. The exception isn’t caught in go(), so the go()\nmethod ends as well, but not before its finally block executes and C\nis printed on line 9. Because main() doesn’t catch the exception, the\nstack trace displays, and no further output occurs. For these reasons,\nAEC is printed followed by a stack trace for a NullPointerException,\nmaking option G correct."
            },
            {
                "id": "82f28a89-0199-1000-8e10-00009e8eeda3",
                "question": "21. Which change allows the following program to compile?\n\n1: public class AhChoo {\n2: static class SneezeException extends Exception {}\n3: static class SniffleException extends SneezeException\n{}\n4: public static void main(String[] args) {\n5: try {\n6: throw new SneezeException();\n7: } catch (SneezeException | SniffleException e) {\n8: } finally {}\n9: } }",
                "answer_options": [
                    "A. Add throws SneezeException to the declaration on line 4.",
                    "B. Add throws Throwable to the declaration on line 4.",
                    "C. Change line 7 to } catch (SneezeException e) {.",
                    "D. Change line 7 to } catch (SniffleException e) {.",
                    "E. Remove line 7.",
                    "F. The code compiles correctly as is.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "21. C. The code does not compile because the multi-catch block on line 7\ncannot catch both a superclass and a related subclass. Options A and B\ndo not address this problem, so they are incorrect. Since the try body\nthrows SneezeException, it can be caught in a catch block, making\noption C correct. Option D allows the catch block to compile but\ncauses a compiler error on line 6. Both of the custom exceptions are\nchecked and must be handled or declared in the main() method. A\nSneezeException is not a SniffleException, so the exception is not\nhandled. Likewise, option E leads to an unhandled exception compiler\nerror on line 6."
            },
            {
                "id": "82f28a89-0199-1000-9d06-00003d61044d",
                "question": "22. What is the output of the following code?\n\ntry {\nLocalDateTime book = LocalDateTime.of(2025, 4, 5, 12,\n30, 20);\nSystem.out.print(book.format(DateTimeFormatter.ofPattern(\"m\n\")));\nSystem.out.print(book.format(DateTimeFormatter.ofPattern(\"z\n\")));\nSystem.out.print(DateTimeFormatter.ofPattern(\"y\").format(bo\nok));\n} catch (Throwable e) {}",
                "answer_options": [
                    "A. 4",
                    "B. 30",
                    "C. 402",
                    "D. 3002",
                    "E. 3002025",
                    "F. 402025",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "22. B. For this question, the date used is April 5, 2025, at 12:30:20 p.m.\nThe code compiles, and either form of the formatter is correct:\ndateTime.format(formatter) or formatter.format(dateTime). The\ncustom format m returns the minute, so 30 is output first. The next line\nthrows an exception as z relates to time zone, and date/time does not\nhave a zone component. This exception is then swallowed by the\ntry/catch block. Since this is the only value printed, option B is\ncorrect. If the code had not thrown an exception, the last line would\nhave printed 2025."
            },
            {
                "id": "82f28a89-0199-1000-21e6-00003bf326a1",
                "question": "23. Fill in the blank: A class that implements _________________ may be\nin a try-with-resources statement. (Choose all that apply.)",
                "answer_options": [
                    "A. AutoCloseable",
                    "B. Resource",
                    "C. Exception",
                    "D. AutomaticResource",
                    "E. Closeable",
                    "F. RuntimeException",
                    "G. Serializable"
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "23. A, E. Resources must inherit AutoCloseable to be used in a try-with-\nresources block. Since Closeable, which is used for I/O classes,\nextends AutoCloseable, both may be used, making options A and E\ncorrect."
            },
            {
                "id": "82f28a89-0199-1000-5403-00005e3686f2",
                "question": "24. What is the output of the following program?\n\npublic class SnowStorm {\nstatic class WalkToSchool implements AutoCloseable {\npublic void close() {\nthrow new RuntimeException(\"flurry\");\n} }\npublic static void main(String[] args) {\nWalkToSchool walk1 = new WalkToSchool();\ntry (walk1; WalkToSchool walk2 = new WalkToSchool())\n{\nthrow new RuntimeException(\"blizzard\");\n} catch(Exception e) {\nSystem.out.println(e.getMessage()\n+ \" \" + e.getSuppressed().length);\n}\nwalk1 = null;\n} }",
                "answer_options": [
                    "A. blizzard 0",
                    "B. blizzard 1",
                    "C. blizzard 2",
                    "D. flurry 0",
                    "E. flurry 1",
                    "F. flurry 2",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    6
                ],
                "correct_answer_explanation": "24. G. The code does not compile because the resource walk1 is not final\nor effectively final and cannot be used in the declaration of a try-with-\nresources statement. For this reason, option G is correct. If the line that\nset walk1 to null were removed, then the code would compile and\nprint blizzard 2 at runtime, with the exception inside the try block\nbeing the primary exception since it is thrown first. Then two\nsuppressed exceptions would be added to it when trying to close the\nAutoCloseable resources."
            },
            {
                "id": "82f28a89-0199-1000-f26e-00009347ce41",
                "question": "25. Assuming U.S. currency is in dollars ($) and German currency is in\neuros (€), what is the output of the following program?\n\nimport java.text.NumberFormat;\nimport java.util.Locale;\nimport java.util.Locale.Category;\npublic record Wallet(double money) {\nprivate String openWallet() {\nLocale.setDefault(Category.DISPLAY,\nnew Locale.Builder().setRegion(\"us\").build());\nLocale.setDefault(Category.FORMAT,\nnew Locale.Builder().setLanguage(\"en\").build());\nreturn\nNumberFormat.getCurrencyInstance(Locale.GERMANY)\n.format(money);\n}\npublic void printBalance() {\nSystem.out.println(openWallet());\n}\npublic static void main(String… unused) {\nnew Wallet(2.4).printBalance();\n} }",
                "answer_options": [
                    "A. 2,40 €",
                    "B. $2.40",
                    "C. 2.4",
                    "D. The code does not compile.",
                    "E. None of the above."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "25. A. The code compiles and prints the value for Germany, 2,40 €,\nmaking option A the correct answer. Note that the default locale\ncategory is ignored since an explicit currency locale is selected."
            },
            {
                "id": "82f28a89-0199-1000-7a06-0000956645ef",
                "question": "26. Which lines can fill in the blank to make the following code compile?\n(Choose all that apply.)\n\nvoid rollOut() throws ClassCastException {}\npublic void transform(String c) {\ntry {\nrollOut();\n} catch (IllegalArgumentException\n|________________________) {\n}\n}",
                "answer_options": [
                    "A. IOException a",
                    "B. Error b",
                    "C. NullPointerException c",
                    "D. RuntimeException d",
                    "E. NumberFormatException e",
                    "F. ClassCastException f",
                    "G. None of the above. The code contains a compiler error regardless"
                ],
                "correct_answer_indexes": [
                    1,
                    5
                ],
                "correct_answer_explanation": "26. B, F. The try block is not capable of throwing an IOException,\nmaking the catch block unreachable code and option A incorrect.\nOptions B and F are correct, as both are unchecked exceptions that do\nnot extend or inherit from IllegalArgumentException. Remember, it\nis not a good idea to catch Error in practice, although because it is\npossible, it may come up on the exam. Option C is incorrect because\nthe variable c is declared already in the method declaration. Option D\nis incorrect because the IllegalArgumentException inherits from\nRuntimeException, making the first declaration unnecessary.\nSimilarly, option E is incorrect because NumberFormatException\ninherits from IllegalArgumentException, making the second\ndeclaration unnecessary. Since options B and F are correct, option G is\nincorrect."
            },
            {
                "id": "82f28a89-0199-1000-ae7e-0000729c87b5",
                "question": "1. Which statement is true of the following module?\n\n|---zoo\n  |-- staff\n    |-- Vet.java",
                "answer_options": [
                    "A. The directory structure shown is a valid module.",
                    "B. The directory structure would be a valid module if module.java",
                    "C. The directory structure would be a valid module if module.java",
                    "D. The directory structure would be a valid module if module-",
                    "E. The directory structure would be a valid module if module-",
                    "F. None of these changes would make this directory structure a valid"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "1. E. Modules are required to have a module-info.java file at the root\ndirectory of the module. Option E matches this requirement."
            },
            {
                "id": "82f28a89-0199-1000-a943-0000448c2362",
                "question": "2. Suppose module puppy depends on module dog and module dog\ndepends on module animal. Fill in the blank so that code in module\ndog can access the animal.behavior package in module animal.\n\nmodule animal {\n_________ animal.behavior;\n}",
                "answer_options": [
                    "A. export",
                    "B. exports",
                    "C. require",
                    "D. requires",
                    "E. require transitive",
                    "F. requires transitive",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "2. B. Options A, C, and E are incorrect because they refer to directives\nthat don’t exist. The exports directive is used when allowing a\npackage to be called by code outside of the module, making option B\nthe correct answer. Notice that options D and F are incorrect because\nrequires is the wrong keyword to use."
            },
            {
                "id": "82f28a89-0199-1000-67e8-0000de8152f8",
                "question": "3. Fill in the blanks so this command to run the program is correct:\n\njava\n_________ modules\n_________ zoo.animal.talks/zoo/animal/talks/Peacocks",
                "answer_options": [
                    "A. -d and -m",
                    "B. -d and –p",
                    "C. -m and -d",
                    "D. -m and -p",
                    "E. -p and -d",
                    "F. -p and -m",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    6
                ],
                "correct_answer_explanation": "3. G. The -p or --module-path option is used to specify the location of\nthe modules. The -m or --module option is used to specify the module\nand class name. However, running a program requires the package\nname to be specified with periods (.) instead of slashes. Since the\ncommand is incorrect, option G is correct."
            },
            {
                "id": "82f28a89-0199-1000-8753-000076fd1c2d",
                "question": "4. Which of the following pairs make up a service?",
                "answer_options": [
                    "A. Consumer and service locator",
                    "B. Consumer and service provider interface",
                    "C. Service locator and service provider",
                    "D. Service locator and service provider interface",
                    "E. Service provider and service provider interface"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "4. D. A service consists of the service provider interface and logic to look\nup implementations using a service locator. This makes option D\ncorrect. Make sure you know that the service provider itself is the\nimplementation, which is not considered part of the service."
            },
            {
                "id": "82f28a89-0199-1000-35ab-000023ff4119",
                "question": "5. A(n) _____________ module is on the classpath while a(n)\n_____________ module is on the module path. (Choose all that apply.)",
                "answer_options": [
                    "A. automatic, named",
                    "B. automatic, unnamed",
                    "C. named, automatic",
                    "D. named, unnamed",
                    "E. unnamed, automatic",
                    "F. unnamed, named",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    4,
                    5
                ],
                "correct_answer_explanation": "5. E, F. Automatic modules are on the module path but do not have a\nmodule-info.java file. Named modules are on the module path and\ndo have a module-info.java. Unnamed modules are on the classpath.\nTherefore, options E and F are correct."
            },
            {
                "id": "82f28a89-0199-1000-acbf-000078c10a75",
                "question": "6. Which of the following statements are true in a module-info.java\nfile? (Choose all that apply.)",
                "answer_options": [
                    "A. The opens directive allows the use of reflection.",
                    "B. The opens directive declares that an API is called.",
                    "C. The use directive allows the use of reflection.",
                    "D. The use directive declares that an API is called.",
                    "E. The uses directive allows the use of reflection.",
                    "F. The uses directive declares that an API is called."
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "6. A, F. Options C and D are incorrect because there is no use directive.\nOptions A and F are correct because opens is for reflection and uses\ndeclares that an API consumes a service."
            },
            {
                "id": "82f28a89-0199-1000-c6f2-00001a243811",
                "question": "7. An automatic module name is generated if one is not supplied. Which\nof the following JAR filenames and generated automatic module name\npairs are correct? (Choose all that apply.)",
                "answer_options": [
                    "A. emily-1.0.0.jar and emily",
                    "B. emily-1.0.0-SNAPSHOT.jar and emily",
                    "C. emily_the_cat-1.0.0.jar and emily_the_cat",
                    "D. emily_the_cat-1.0.0.jar and emily-the-cat",
                    "E. emily.$.jar and emily",
                    "F. emily.$.jar and emily.",
                    "G. emily.$.jar and emily.."
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    4
                ],
                "correct_answer_explanation": "7. A, B, E. Any version information at the end of the JAR filename is\nremoved, making options A and B correct. Underscores (_) are turned\ninto dots (.), making options C and D incorrect. Other special\ncharacters like a dollar sign ($) are also turned into dots. However,\nadjacent dots are merged, and leading/trailing dots are removed.\nTherefore, option E is also correct."
            },
            {
                "id": "82f28a89-0199-1000-56c5-000044b5a352",
                "question": "8. Which of the following statements are true? (Choose all that apply.)",
                "answer_options": [
                    "A. Modules with cyclic dependencies will not compile.",
                    "B. Packages with a cyclic dependency will not compile.",
                    "C. A cyclic dependency always involves exactly two modules.",
                    "D. A cyclic dependency always involves at least two requires",
                    "E. An unnamed module can be involved in a cyclic dependency with"
                ],
                "correct_answer_indexes": [
                    0,
                    3
                ],
                "correct_answer_explanation": "8. A, D. A cyclic dependency is when a module graph forms a circle.\nOption A is correct because the Java Platform Module System does not\nallow cyclic dependencies between modules. No such restriction exists\nfor packages, making option B incorrect. A cyclic dependency can\ninvolve two or more modules that require each other, making option D\ncorrect, while option C is incorrect. Finally, option E is incorrect\nbecause unnamed modules cannot be referenced from an automatic\nmodule."
            },
            {
                "id": "82f28a89-0199-1000-c557-00009d78eb55",
                "question": "9. Suppose you are creating a service provider that contains the following\nclass. Which line of code needs to be in your module-info.java?\n\npackage dragon;\nimport magic.*;\npublic class Dragon implements Magic {\npublic String getPower() {\nreturn \"breathe fire\";\n}\n}",
                "answer_options": [
                    "A. provides dragon.Dragon by magic.Magic;",
                    "B. provides dragon.Dragon using magic.Magic;",
                    "C. provides dragon.Dragon with magic.Magic;",
                    "D. provides magic.Magic by dragon.Dragon;",
                    "E. provides magic.Magic using dragon.Dragon;",
                    "F. provides magic.Magic with dragon.Dragon;"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "9. F. The provides directive takes the interface name first and the\nimplementing class name second and also uses with. Only option F\nmeets these two criteria, making it the correct answer."
            },
            {
                "id": "82f28a89-0199-1000-262d-000084fbdcc9",
                "question": "10. What is true of a module containing a file named module-info.java\nwith the following contents? (Choose all that apply.)\n\nmodule com.food.supplier {}",
                "answer_options": [
                    "A. All packages inside the module are automatically exported.",
                    "B. No packages inside the module are automatically exported.",
                    "C. A main method inside the module can be run.",
                    "D. A main method inside the module cannot be run since the class is",
                    "E. The module-info.java file contains a compiler error.",
                    "F. The module-info.java filename is incorrect."
                ],
                "correct_answer_indexes": [
                    1,
                    2
                ],
                "correct_answer_explanation": "10. B, C. Packages inside a module are not exported by default, making\noption B correct and option A incorrect. Exporting is necessary for\nother code to use the packages; it is not necessary to call the main()\nmethod at the command line, making option C correct and option D\nincorrect. The module-info.java file has the correct name and\ncompiles, making options E and F incorrect."
            },
            {
                "id": "82f28a89-0199-1000-ef56-00004890e9e7",
                "question": "11. Suppose module puppy depends on module dog and module dog\ndepends on module animal. Which lines allow module puppy to access\nthe animal.behavior package in module animal? (Choose all that\napply.)\n\nmodule animal {\nexports animal.behavior;\n}\nmodule dog {\n_____________ animal; // line S\n}\nmodule puppy {\n_____________ dog; // line T\n}",
                "answer_options": [
                    "A. require on line S",
                    "B. require on line T",
                    "C. requires on line S",
                    "D. requires on line T",
                    "E. require transitive on line S",
                    "F. require transitive on line T",
                    "G. requires transitive on line S",
                    "H. requires transitive on line T"
                ],
                "correct_answer_indexes": [
                    3,
                    6,
                    7
                ],
                "correct_answer_explanation": "11. D, G, H. Options A, B, E, and F are incorrect because they refer to\ndirectives that don’t exist. The requires transitive directive is used\nwhen specifying a module to be used by the requesting module and\nany other modules that use the requesting module. Therefore, dog\nneeds to specify the transitive relationship, and option G is correct.\nThe module puppy just needs requires dog, and it gets the transitive\ndependencies, making option D correct. However, requires\ntransitive does everything requires does and more, which makes\noption H the final correct answer."
            },
            {
                "id": "82f28a8a-0199-1000-7f59-00007022d836",
                "question": "12. Which of the following modules are provided by the JDK? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. java.base",
                    "B. java.desktop",
                    "C. java.logging",
                    "D. java.util",
                    "E. jdk.base",
                    "F. jdk.compiler",
                    "G. jdk.xerces"
                ],
                "correct_answer_indexes": [
                    0,
                    1,
                    2,
                    5
                ],
                "correct_answer_explanation": "12. A, B, C, F. Option D is incorrect because it is a package name rather\nthan a module name. Option E is incorrect because java.base is the\nmodule name, not jdk.base. Option G is wrong because we made it\nup. Options A, B, C, and F are correct."
            },
            {
                "id": "82f28a8a-0199-1000-1e02-0000a12403f8",
                "question": "13. Which of the following compiles and is equivalent to this loop?\n\nList<Unicorn> all = new ArrayList<>();\nfor (Unicorn current : ServiceLoader.load(Unicorn.class))\nall.add(current);",
                "answer_options": [
                    "E. None of the above"
                ],
                "correct_answer_indexes": [],
                "correct_answer_explanation": "13. D. There is no getStream() method on a ServiceLoader, making\noptions A and C incorrect. Option B does not compile because the\nstream() method returns a list of Provider interfaces and needs to be\nconverted to the Unicorn interface we are interested in. Therefore,\noption D is correct."
            },
            {
                "id": "82f28a8a-0199-1000-310a-0000397a532c",
                "question": "14. Which of the following is a legal command to run a modular program\nwhere n is the module name and c is the fully qualified class name?",
                "answer_options": [
                    "A. java --module-path x -m n.c",
                    "B. java --module-path x -p n.c",
                    "C. java --module-path x-x -m n/c",
                    "D. java --module-path x -p n/c",
                    "E. java --module-path x-x -m n-c",
                    "F. java --module-path x -p n-c",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "14. C. The -p option is a shorter form of --module-path. Since the same\noption cannot be specified twice, options B, D, and F are incorrect.\nThe module name and class name are separated with a slash, making\noption C the answer. Note that x-x is legal because the module path is\na folder name, so dashes are allowed."
            },
            {
                "id": "82f28a8a-0199-1000-f7e3-000001b23982",
                "question": "15. For a top-down migration, all modules other than named modules are\n_____________ modules and are on the _____________.",
                "answer_options": [
                    "A. automatic, classpath",
                    "B. automatic, module path",
                    "C. unnamed, classpath",
                    "D. unnamed, module path",
                    "E. None of the above"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "15. B. A top-down migration strategy first places all JARs on the module\npath. Then it migrates the top-level module to be a named module,\nleaving the other modules as automatic modules. Option B is correct as\nit matches both of those characteristics."
            },
            {
                "id": "82f28a8a-0199-1000-a525-00000a622862",
                "question": "16. Suppose you have separate modules for a service provider interface,\nservice provider, service locator, and consumer. If you add a second\nservice provider module, how many of the existing modules do you\nneed to recompile?",
                "answer_options": [
                    "A. Zero",
                    "B. One",
                    "C. Two",
                    "D. Three",
                    "E. Four"
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "16. A. Since this is a new module, you need to compile it. However, none\nof the existing modules needs to be recompiled, making option A\ncorrect. The service locator will see the new service provider simply\nby having that new service provider on the module path."
            },
            {
                "id": "82f28a8a-0199-1000-738f-0000bdd5ab04",
                "question": "17. Suppose we have a JAR file named cat-1.2.3-RC1.jar, and\nAutomatic-Module-Name in the MANIFEST.MF is set to dog. What\nshould an unnamed module referencing this automatic module include\nin module-info.java?",
                "answer_options": [
                    "A. requires cat;",
                    "B. requires cat.RC;",
                    "C. requires cat-RC;",
                    "D. requires dog;",
                    "E. None of the above"
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "17. E. Trick question! An unnamed module doesn’t use a module-\ninfo.java file. Therefore, option E is correct. An unnamed module\ncan access an automatic module. The unnamed module would simply\ntreat the automatic module as a regular JAR without involving the\nmodule-info.java file."
            },
            {
                "id": "82f28a8a-0199-1000-62af-0000a6199756",
                "question": "18. Two commands create artifacts that include smaller versions of the\nJDK. Which are used to create an .exe file and a directory,\nrespectively?",
                "answer_options": [
                    "A. jimage and jlink",
                    "B. jimage and jpackage",
                    "C. jlink and jimage",
                    "D. jlink and jpackage",
                    "E. jpackage and jimage",
                    "F. jpackage and jlink"
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "18. F. The jpackage command creates self-contained application such as\nan .exe. The jlink command creates a directory with a smaller Java\nruntime containing just what is needed. The jimage command is used\nto inspect a Java image file. Therefore, option F is correct."
            },
            {
                "id": "82f28a8a-0199-1000-e4ef-000049c727ff",
                "question": "19. Which is a true statement about the following module?\n\nclass dragon {\nexports com.dragon.fire;\nexports com.dragon.scales to castle;\n}",
                "answer_options": [
                    "A. All modules can reference the com.dragon.fire package.",
                    "B. All modules can reference the com.dragon.scales package.",
                    "C. Only the castle module can reference the com.dragon.fire",
                    "D. Only the castle module can reference the com.dragon.scales",
                    "E. None of the above."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "19. E. There is a trick here. A module definition uses the keyword module\nrather than class. Since the code does not compile, option E is correct.\nIf the code did compile, options A and D would be correct."
            },
            {
                "id": "82f28a8a-0199-1000-3fe0-0000e9fdc3d7",
                "question": "20. Which would you expect to see when describing any module?",
                "answer_options": [
                    "A. requires java.base mandated",
                    "B. requires java.core mandated",
                    "C. requires java.lang mandated",
                    "D. requires mandated java.base",
                    "E. requires mandated java.core",
                    "F. requires mandated java.lang",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "20. A. When running java with the -d option, all the required modules are\nlisted. Additionally, the java.base module is listed since it is included\nautomatically. The line ends with mandated, making option A correct.\nThe java.lang is a trick since it is a package that is imported by\ndefault in a class rather than a module."
            },
            {
                "id": "82f28a8a-0199-1000-03e1-0000d2afeb92",
                "question": "21. Suppose you have separate modules for a service provider interface,\nservice provider, service locator, and consumer. Which module(s) need\nto specify a requires directive on the service provider?",
                "answer_options": [
                    "A. Service locator",
                    "B. Service provider interface",
                    "C. Consumer",
                    "D. Consumer and service locator",
                    "E. Consumer and service provider",
                    "F. Service locator and service provider interface",
                    "G. Consumer, service locator, and service provider interface",
                    "H. None of the above"
                ],
                "correct_answer_indexes": [
                    7
                ],
                "correct_answer_explanation": "21. H. This question is tricky. The service locator must have a uses\ndirective, but that is on the service provider interface. No modules\nneed to specify requires on the service provider since that is the\nimplementation. Since none of the options are correct, option H is the\nanswer."
            },
            {
                "id": "82f28a8a-0199-1000-1113-00009430cd2f",
                "question": "22. Which are true statements? (Choose all that apply.)",
                "answer_options": [
                    "A. An automatic module exports all packages to named modules.",
                    "B. An automatic module exports only the specified packages to",
                    "C. An automatic module exports no packages to named modules.",
                    "D. An unnamed module exports only the named packages to named",
                    "E. An unnamed module exports all packages to named modules.",
                    "F. An unnamed module exports no packages to named modules."
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "22. A, F. An automatic module exports all packages, making option A\ncorrect. An unnamed module is not available to any modules on the\nmodule path. Therefore, it doesn’t export any packages, and option F is\ncorrect."
            },
            {
                "id": "82f28a8a-0199-1000-5c86-0000f3340adf",
                "question": "23. Which is the first line to contain a compiler error?\n\n1: module snake {\n2: exports com.snake.tail;\n3: exports com.snake.fangs to bird;\n4: requires skin;\n5: requires transitive skin;\n6: }",
                "answer_options": [
                    "A. Line 1.",
                    "B. Line 2.",
                    "C. Line 3.",
                    "D. Line 4.",
                    "E. Line 5.",
                    "F. The code does not contain any compiler errors."
                ],
                "correct_answer_indexes": [
                    4
                ],
                "correct_answer_explanation": "23. E. The module name is valid, as are the exports statements. Lines 4\nand 5 are tricky because each is valid independently. However, the\nsame module name is not allowed to be used in two requires\nstatements. The second one fails to compile on line 5, making option E\nthe answer."
            },
            {
                "id": "82f28a8a-0199-1000-f177-0000cf25fcc1",
                "question": "24. Which is a true statement about a package in a JAR on the classpath\ncontaining a module-info.java file?",
                "answer_options": [
                    "A. It is possible to make the package available to all other modules",
                    "B. It is possible to make the package available to all other modules",
                    "C. It is possible to make the package available to exactly one other",
                    "D. It is possible to make the package available to exactly one other",
                    "E. It is possible to make sure the package is not available to any"
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "24. A. Since the JAR is on the classpath, it is treated as a regular unnamed\nmodule even though it has a module-info.java file inside. Remember\nfrom learning about top-down migration that modules on the module\npath are not allowed to refer to the classpath, making options B and D\nincorrect. The classpath does not have a facility to restrict packages,\nmaking option A correct and options C and E incorrect."
            },
            {
                "id": "82f28a8a-0199-1000-1f01-0000d124ef4c",
                "question": "25. Suppose you have separate modules for a service provider interface,\nservice provider, service locator, and consumer. Which statements are\ntrue about the directives you need to specify? (Choose all that apply.)",
                "answer_options": [
                    "A. The consumer must use the requires directive.",
                    "B. The consumer must use the uses directive.",
                    "C. The service locator must use the requires directive.",
                    "D. The service locator must use the uses directive.",
                    "E. None of the above."
                ],
                "correct_answer_indexes": [
                    0,
                    2,
                    3
                ],
                "correct_answer_explanation": "25. A, C, D. Options A and C are correct because both the consumer and\nthe service locator depend on the service provider interface.\nAdditionally, option D is correct because the service locator must\nspecify that it uses the service provider interface to look it up."
            },
            {
                "id": "82f28a8a-0199-1000-b7cd-0000a686401f",
                "question": "1. Given the following code snippet, which options correctly create a\nparallel stream? (Choose all that apply.)\n\nvar c = List.of(19, 66);\nvar s = ThreadLocalRandom.current().doubles();\nvar p = ________________;",
                "answer_options": [
                    "A. new ParallelStream(s)",
                    "B. c.parallel()",
                    "C. s.parallelStream()",
                    "D. c.parallelStream()",
                    "E. new ParallelStream(c)",
                    "F. s.parallel()"
                ],
                "correct_answer_indexes": [
                    3,
                    5
                ],
                "correct_answer_explanation": "1. D, F. There is no such class within the Java API called\nParallelStream, so options A and E are incorrect. The method\ndefined in the Stream class to create a parallel stream from an existing\nstream is parallel(); therefore, option F is correct, and option C is\nincorrect. The method defined in the Collection class to create a\nparallel stream from a collection is parallelStream(); therefore,\noption D is correct, and option B is incorrect."
            },
            {
                "id": "82f28a8a-0199-1000-4969-000058d18ac3",
                "question": "2. Given that the sum of the numbers from 1 (inclusive) to 10 (exclusive)\nis 45, what are the possible results of executing the following\nprogram? (Choose all that apply.)\n\n1: import java.util.concurrent.locks.*;\n2: import java.util.stream.*;\n3: public class Bank {\n4: private Lock vault = new ReentrantLock();\n5: private int total = 0;\n6: public void deposit(int value) {\n7: try {\n8: vault.tryLock();\n9: total += value;\n10: } finally { vault.unlock(); }\n11: }\n12: public static void main(String[] unused) {\n13: var bank = new Bank();\n14: IntStream.range(1, 10).parallel()\n15: .forEach(s -> bank.deposit(s));\n16: System.out.println(bank.total);\n17: } }",
                "answer_options": [
                    "A. 45 is printed.",
                    "B. A number less than 45 is printed.",
                    "C. A number greater than 45 is printed.",
                    "D. An exception is thrown.",
                    "E. None of the above, as the code does not compile."
                ],
                "correct_answer_indexes": [
                    0,
                    3
                ],
                "correct_answer_explanation": "2. A, D. The tryLock() method returns immediately with a value of\nfalse if the lock cannot be acquired. Unlike lock(), it does not wait\nfor a lock to become available. This code fails to check the return\nvalue on line 8, resulting in the protected code being entered regardless\nof whether the lock is obtained. In some executions (when tryLock()\nreturns true on every call), the code will complete successfully and\nprint 45 at runtime, making option A correct. On other executions\n(when tryLock() returns false at least once), the unlock() method\non line 10 will throw an IllegalMonitorStateException at runtime,\nmaking option D correct. Option B would be possible if line 10 did not\nthrow an exception."
            },
            {
                "id": "82f28a8a-0199-1000-36b3-00001c188949",
                "question": "3. Which of the following statements about the Callable call() and\nRunnable run() methods are correct? (Choose all that apply.)",
                "answer_options": [
                    "A. Both methods return void.",
                    "B. Both can throw unchecked exceptions.",
                    "C. Both can be implemented with lambda expressions.",
                    "D. Runnable returns a generic type.",
                    "E. Both can throw checked exceptions.",
                    "F. Callable returns a generic type."
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    5
                ],
                "correct_answer_explanation": "3. B, C, F. Runnable returns void and Callable returns a generic type,\nmaking options A and D incorrect and option F correct. All methods\nare capable of throwing unchecked exceptions, so option B is correct.\nOnly Callable is capable of throwing checked exceptions, so option E\nis incorrect. Both Runnable and Callable are functional interfaces that\ncan be implemented with a lambda expression, so option C is also\ncorrect."
            },
            {
                "id": "82f28a8a-0199-1000-a26d-00000fbffb8b",
                "question": "4. Which lines need to be changed to make the code compile?\n\ntry (ExecutorService service = // w1\n  Executors.newSingleThreadScheduledExecutor()) {\nservice.scheduleWithFixedDelay(() -> {\n  System.out.println(\"Open Zoo\");\n  return null; // w2\n}, 0, 1, TimeUnit.MINUTES);\nvar result = service.submit(() -> // w3\nSystem.out.println(\"Wake Staff\"));\nSystem.out.println(result.get());\n}",
                "answer_options": [
                    "A. Only line w1.",
                    "B. Only line w2.",
                    "C. Only line w3.",
                    "D. Line w1 and w2.",
                    "E. Line w1 and w2.",
                    "F. Line w1 and w3.",
                    "G. None of the above; the code compiles."
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "4. D. The first problem is that although a ScheduledExecutorService is\ncreated, it is assigned to an ExecutorService. The type of the variable\non line w1 would have to be updated to ScheduledExecutorService\nfor the code to compile. The second problem is that\nscheduleWithFixedDelay() supports only Runnable, not Callable,\nand any attempt to return a value is invalid in a Runnable lambda\nexpression; therefore, line w2 will also not compile, and option D is\ncorrect."
            },
            {
                "id": "82f28a8a-0199-1000-6960-000072164d4e",
                "question": "5. What statement about the following code is true?\n\nvar value1 = new AtomicLong(0);\nfinal long[] value2 = {0};\nIntStream.iterate(1, i -> 1).limit(100).parallel()\n.forEach(i -> value1.incrementAndGet());\nIntStream.iterate(1, i -> 1).limit(100).parallel()\n.forEach(i -> ++value2[0]);\nSystem.out.println(value1 + \" \" + value2[0]);",
                "answer_options": [
                    "A. It outputs 100 100.",
                    "B. It outputs 100 99.",
                    "C. The output cannot be determined ahead of time.",
                    "D. The code does not compile.",
                    "E. It compiles but throws an exception at runtime.",
                    "F. It compiles but enters an infinite loop at runtime.",
                    "G. None of the above."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "5. C. The code compiles and runs without throwing an exception or\nentering an infinite loop, so options D, E, and F are incorrect. The key\nhere is that the increment operator ++ is not atomic. While the first part\nof the output will always be 100, the second part is nondeterministic. It\nmay output any value from 1 to 100, because the threads can overwrite\neach other’s work. Therefore, option C is the correct answer, and\noptions A and B are incorrect."
            },
            {
                "id": "82f28a8a-0199-1000-2359-0000ce2c1ada",
                "question": "6. Which statements about the following code are correct? (Choose all\nthat apply.)\n\nvar data = List.of(2, 5, 1, 9, 8);\ndata.stream().parallel()\n.mapToInt(s -> s)\n.peek(System.out::print)\n.forEachOrdered(System.out::print);",
                "answer_options": [
                    "A. The peek() method will print the entries in the sorted order:",
                    "B. The peek() method will print the entries in the original order:",
                    "C. The peek() method will print the entries in an order that cannot",
                    "D. The forEachOrdered() method will print the entries in the sorted",
                    "E. The forEachOrdered() method will print the entries in the",
                    "F. The forEachOrdered() method will print the entries in an order",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    2,
                    4
                ],
                "correct_answer_explanation": "6. C, E. The code compiles, so option G is incorrect. The peek() method\non a parallel stream will process the elements concurrently, so the\norder cannot be determined ahead of time, and option C is correct. The\nforEachOrdered() method will process the elements in the order in\nwhich they are stored in the stream, making option E correct. None of\nthe methods sort the elements, so options A and D are incorrect."
            },
            {
                "id": "82f28a8a-0199-1000-8c69-00008ac6dc78",
                "question": "7. Fill in the blanks: __________ occur(s) when two or more threads are\nblocked forever but both appear active. _______ occur(s) when two or\nmore threads try to complete a related task at the same time, resulting\nin invalid or unexpected data.",
                "answer_options": [
                    "A. Livelock, Deadlock",
                    "B. Deadlock, Starvation",
                    "C. Race conditions, Deadlock",
                    "D. Livelock, Race conditions",
                    "E. Starvation, Race conditions",
                    "F. Deadlock, Livelock"
                ],
                "correct_answer_indexes": [
                    3
                ],
                "correct_answer_explanation": "7. D. Livelock occurs when two or more threads are conceptually\nblocked forever, although they are each still active and trying to\ncomplete their task. A race condition is an undesirable result that\noccurs when two tasks that should have been completed sequentially\nare completed at the same time. For these reasons, option D is correct."
            },
            {
                "id": "82f28a8a-0199-1000-0809-000096f5c605",
                "question": "8. Assuming this class is accessed by only a single thread at a time, what\nis the result of calling the countIceCreamFlavors() method?\n\nimport java.util.stream.LongStream;\npublic class Flavors {\nprivate static int counter;\npublic static void countIceCreamFlavors() {\ncounter = 0;\nRunnable task = () -> counter++;\nLongStream.range(0, 500)\n.forEach(m -> Thread.ofPlatform()\n.priority(1)\n.unstarted(task)\n.run());\nSystem.out.println(counter);\n} }",
                "answer_options": [
                    "A. The method consistently prints a number less than 500.",
                    "B. The method consistently prints 500.",
                    "C. The method compiles and prints a value, but that value cannot be",
                    "D. The method does not compile.",
                    "E. The method compiles but throws an exception at runtime.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "8. B. Be wary of run() vs. start() on the exam! The method looks like\nit executes a task concurrently, but it runs synchronously. In each\niteration of the forEach() loop, the process waits for the run()\nmethod to complete before moving on. For this reason, the code is\nthread-safe. Since the program consistently prints 500 at runtime,\noption B is correct. Note that if start() had been used instead of\nrun() (or the stream was parallel), then the output would be\nindeterminate, and option C would have been correct."
            },
            {
                "id": "82f28a8a-0199-1000-e769-00002a5666f8",
                "question": "9. Which are true of ExecutorService? (Choose all that apply.)",
                "answer_options": [
                    "A. If a task is submitted when no threads are available, the executor",
                    "B. If a task is submitted when no threads are available, the executor",
                    "C. If a task is submitted when no threads are available, the thread",
                    "D. Platform threads can be pooled using ExecutorService, but not",
                    "E. Virtual threads can be pooled using ExecutorService, but not",
                    "F. Both platform threads and virtual threads can be pooled using"
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "9. B, D. If a task is submitted to a thread executor and the thread executor\ndoes not have any available threads, the call to the task will return\nimmediately with the task being queued internally by the thread\nexecutor. For this reason, option B is correct. Additionally, only\nplatform threads can be pooled, making option D correct as well.\nVirtual threads are lightweight so they don’t benefit from pooling."
            },
            {
                "id": "82f28a8a-0199-1000-c7b2-0000e7fdc782",
                "question": "10. What is the result of executing the following code snippet?\n\nSequencedCollection<Integer> lions = new ArrayList<>\n(List.of(1, 2, 3));\nSequencedCollection<Integer> tigers = new\nCopyOnWriteArrayList<>(lions);\nSet<Integer> bears = new ConcurrentSkipListSet<>();\nbears.addAll(lions);\nfor (Integer item: tigers) tigers.add(4); // x1\nfor (Integer item: bears) bears.add(5); // x2\nSystem.out.println(lions.size() + \" \" + tigers.size()\n+ \" \" + bears.size());",
                "answer_options": [
                    "A. It outputs 3 6 4.",
                    "B. It outputs 6 6 6.",
                    "C. It outputs 6 3 4.",
                    "D. The code does not compile.",
                    "E. It compiles but throws an exception at runtime on line x1.",
                    "F. It compiles but throws an exception at runtime on line x2.",
                    "G. It compiles but enters an infinite loop at runtime."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "10. A. The code compiles without issue, so option D is incorrect. The\nCopyOnWriteArrayList class is designed to preserve the original list\non iteration, so the first loop will be executed exactly three times and,\nin the process, will increase the size of tigers to six elements. The\nConcurrentSkipListSet class allows modifications, and since it\nenforces the uniqueness of its elements, the value 5 is added only once,\nleading to a total of four elements in bears. Finally, despite using the\nelements of lions to populate the collections, tigers and bears are\nnot backed by the original list, so the size of lions is 3 throughout this\nprogram. For these reasons, the program prints 3 6 4, and option A is\ncorrect."
            },
            {
                "id": "82f28a8b-0199-1000-a017-0000c4945232",
                "question": "11. What statement about the following code is true?\n\nInteger i1 = List.of(1, 2, 3, 4,\n5).stream().findAny().get();\nsynchronized(i1) { // y1\nInteger i2 = List.of(6, 7, 8, 9, 10)\n.parallelStream()\n.sorted()\n.findAny().get(); // y2\nSystem.out.println(i1 + \" \" + i2);\n}",
                "answer_options": [
                    "A. The first value printed is always 1.",
                    "B. The second value printed is always 6.",
                    "C. The code will not compile because of line y1.",
                    "D. The code will not compile because of line y2.",
                    "E. The code compiles but throws an exception at runtime.",
                    "F. The output cannot be determined ahead of time.",
                    "G. It compiles but waits forever at runtime."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "11. F. The code compiles and runs without issue, so options C, D, E, and G\nare incorrect. There are two important things to notice. First,\nsynchronizing on the first variable doesn’t impact the results of the\ncode. Second, sorting on a parallel stream does not mean that\nfindAny() will return the first record. The findAny() method will\nreturn the value from the first thread that retrieves a record. Therefore,\nthe output is not guaranteed, and option F is correct. Option A looks\ncorrect, but even on serial streams, findAny() is free to select any\nelement."
            },
            {
                "id": "82f28a8b-0199-1000-43c1-00006f99035f",
                "question": "12. Assuming each call to takeNap() takes five seconds to execute\nwithout throwing an exception, what is the expected result of\nexecuting the following code snippet? (Choose all that apply.)\n\npublic void shutdown() throws InterruptedException {\nvar service = Executors.newFixedThreadPool(4);\ntry {\nservice.execute(() -> takeNap());\nservice.execute(() -> takeNap());\nservice.execute(() -> takeNap());\n} finally {\nservice.shutdown();\n}\nservice.awaitTermination(2, TimeUnit.SECONDS);\nSystem.out.println(\"DONE!\");\n}\npublic void refactored() {\ntry (var service = Executors.newFixedThreadPool(4)) {\nservice.execute(() -> takeNap());\nservice.execute(() -> takeNap());\nservice.execute(() -> takeNap());\n}\nSystem.out.println(\"DONE!\");\n}",
                "answer_options": [
                    "A. shutdown() will pause for approximately 2 seconds and then",
                    "B. shutdown() will pause for approximately 5 seconds and then",
                    "C. shutdown() will pause for approximately 15 seconds and then",
                    "D. refactored() will pause for approximately 2 seconds and then",
                    "E. refactored() will pause for approximately 5 seconds and then",
                    "F. refactored() will pause for approximately 15 seconds and then",
                    "G. One of the methods returns the result immediately.",
                    "H. One of the methods throws an exception."
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "12. A, E. The shutdown() method submits three tasks to an\nExecutorService, shuts it down, and then waits for the results. The\nawaitTermination() method waits a specified amount of time for all\ntasks to complete and the service to finish shutting down. Since each\nfive-second task is still executing, the awaitTermination() method\nwill return with a value of false after two seconds but not throw an\nexception making option A correct. The refactored() method uses a\ntry-with-resources, which allows the tasks to gracefully finish and\noption E to be the other answer."
            },
            {
                "id": "82f28a8b-0199-1000-3789-0000bba3c202",
                "question": "13. What statement about the following code is true?\n\nSystem.out.print(List.of(\"duck\",\"flamingo\",\"pelican\")\n.parallelStream().parallel() // q1\n.reduce(0,\n(c1, c2) -> c1.length() + c2.length(), // q2\n(s1, s2) -> s1 + s2)); // q3",
                "answer_options": [
                    "A. It compiles and runs without issue, outputting the total length of",
                    "B. The code will not compile because of line q1.",
                    "C. The code will not compile because of line q2.",
                    "D. The code will not compile because of line q3.",
                    "E. It compiles but throws an exception at runtime.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "13. C. The code does not compile, so options A and E are incorrect. The\nproblem here is that c1 is an Integer and c2 is a String, so the code\nfails to combine on line q2, since calling length() on an Integer is\nnot allowed, and option C is correct. The rest of the lines compile\nwithout issue. Note that calling parallel() on an already parallel\nstream is allowed, and it may return the same object."
            },
            {
                "id": "82f28a8b-0199-1000-85e2-0000553aeb82",
                "question": "14. What statements about the following code snippet are true? (Choose\nall that apply.)\n\nObject o1 = new Object();\nObject o2 = new Object();\ntry (var service = Executors.newFixedThreadPool(2)) {\nvar f1 = service.submit(() -> {\nsynchronized (o1) {\nsynchronized (o2) { System.out.print(\"Tortoise\");\n}\n}\n});\nvar f2 = service.submit(() -> {\nsynchronized (o2) {\nsynchronized (o1) { System.out.print(\"Hare\"); }\n}\n});\nf1.get();\nf2.get();\n}",
                "answer_options": [
                    "A. The code will always output Tortoise followed by Hare.",
                    "B. The code will always output Hare followed by Tortoise.",
                    "C. If the code does output anything, the order cannot be determined.",
                    "D. The code does not compile.",
                    "E. The code compiles but may produce a deadlock at runtime.",
                    "F. The code compiles but may produce a livelock at runtime.",
                    "G. It compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    2,
                    4
                ],
                "correct_answer_explanation": "14. C, E. The code compiles without issue, so option D is incorrect. Since\nboth tasks are submitted to the same thread executor pool, the order\ncannot be determined, so options A and B are incorrect, and option C\nis correct. The key here is that the order in which the resources o1 and\no2 are synchronized could result in a deadlock. For example, if the first\nthread gets a lock on o1 and the second thread gets a lock on o2 before\neither thread can get their second lock, the code will hang at runtime,\nmaking option E correct. The code cannot produce a livelock, since\nboth threads are waiting, so option F is incorrect. Finally, if a deadlock\ndoes occur, an exception will not be thrown, so option G is incorrect."
            },
            {
                "id": "82f28a8b-0199-1000-47e8-000077211b7f",
                "question": "15. Which statement about the following code snippet is correct?\n\n2: var cats = Stream.of(\"leopard\", \"lynx\", \"ocelot\",\n\"puma\")\n3: .parallel();\n4: var bears =\nStream.of(\"panda\",\"grizzly\",\"polar\").parallel();\n5: var data = Stream.of(cats,bears).flatMap(s -> s)\n6: .collect(Collectors.groupingByConcurrent(\n7: s -> !s.startsWith(\"p\")));\n8: System.out.println(data.get(false).size()\n9: + \" \" + data.get(true).size());",
                "answer_options": [
                    "A. It outputs 3 4.",
                    "B. It outputs 4 3.",
                    "C. The code will not compile because of line 6.",
                    "D. The code will not compile because of line 7.",
                    "E. The code will not compile because of line 8.",
                    "F. It compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    0
                ],
                "correct_answer_explanation": "15. A. The code compiles and runs without issue, so options C, D, E, and\nF are incorrect. The collect() operation groups the animals into those\nthat do and do not start with the letter p. Note that there are four\nanimals that do not start with the letter p and three animals that do.\nTherefore, the output is 3 4, and option A is correct, making option B\nincorrect."
            },
            {
                "id": "82f28a8b-0199-1000-aef8-0000948ba117",
                "question": "16. Which APIs exist for creating or working with platform threads?\n(Choose all that apply.)",
                "answer_options": [
                    "A. Executors.newCachedThreadPool()",
                    "B. Executors.newPlatformThreadPool()",
                    "C. Executors.newPlatformThreadPerTaskExecutor()",
                    "D. new Thread()",
                    "E. Thread.ofPlatform()",
                    "F. Thread.ofPlatformThread()"
                ],
                "correct_answer_indexes": [
                    0,
                    3,
                    4
                ],
                "correct_answer_explanation": "16. A, D, E. All the factory methods on Executors work with platform\nthreads except newVirtualThreadPerTaskExecutor(), making option\nA correct. You can also create a platform thread using the constructor\nor factory method Thread.ofPlatform(), making options D and E the\nother answers."
            },
            {
                "id": "82f28a8b-0199-1000-11f4-0000036e2b8b",
                "question": "17. Which statement about methods in ReentrantLock is correct?",
                "answer_options": [
                    "A. The lock() method will attempt to acquire a lock without waiting",
                    "B. The testLock() method will attempt to acquire a lock without",
                    "C. The attemptLock() method will attempt to acquire a lock",
                    "D. By default, a ReentrantLock fairly releases to each thread in the",
                    "E. Calling the unlock() method once will release a resource so that",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "17. F. The lock() method will wait indefinitely for a lock, so option A is\nincorrect. Options B and C are also incorrect, as the correct method\nname to attempt to acquire a lock is tryLock(). Option D is incorrect,\nas fairness is set to false by default and must be enabled by using an\noverloaded constructor. Finally, option E is incorrect because a thread\nthat holds the lock may have called lock() or tryLock() multiple\ntimes. A thread needs to call unlock() once for each call to lock()\nand successful tryLock(). Option F is the correct answer since none\nof the other options is a valid statement."
            },
            {
                "id": "82f28a8b-0199-1000-747a-000013ca2a27",
                "question": "18. Which of the following lambda expressions are valid Callable\nexpressions? (Choose all that apply.)",
                "answer_options": [
                    "A. a -> {return 10;}",
                    "B. () -> {String s = \"\";}",
                    "C. () -> 5",
                    "D. () -> {return null}",
                    "E. () -> \"The\" + \"Zoo\"",
                    "F. (int count) -> count+1",
                    "G. () -> {System.out.print(\"Giraffe\"); return 10;}"
                ],
                "correct_answer_indexes": [
                    2,
                    4,
                    6
                ],
                "correct_answer_explanation": "18. C, E, G. A Callable lambda expression takes no values and returns a\ngeneric type; therefore, options C, E, and G are correct. Options A and\nF are incorrect because they both take an input parameter. Option B is\nincorrect because it does not return a value. Option D is not a valid\nlambda expression, because it is missing a semicolon at the end of the\nreturn statement, which is required when inside braces, {}."
            },
            {
                "id": "82f28a8b-0199-1000-a1a9-000035baf514",
                "question": "19. What is the result of executing the following application? (Choose all\nthat apply.)\n\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class PrintConstants {\npublic static void main(String[] args) {\nvar s = Executors.newVirtualThreadPerTaskExecutor();\nDoubleStream.of(3.14159, 2.71828) // b1\n.forEach(c -> s.submit( // b2\n() -> System.out.println(10 * c))); // b3\ns.execute(() -> System.out.println(\"Printed\"));\n} }",
                "answer_options": [
                    "A. It compiles and outputs the two numbers followed by Printed.",
                    "B. The code will not compile because of line b1.",
                    "C. The code will not compile because of line b2.",
                    "D. The code will not compile because of line b3.",
                    "E. It compiles, but the output cannot be determined ahead of time.",
                    "F. It compiles but throws an exception at runtime.",
                    "G. It compiles but waits forever at runtime."
                ],
                "correct_answer_indexes": [
                    4,
                    6
                ],
                "correct_answer_explanation": "19. E, G. The application compiles and does not throw an exception. Even\nthough the stream is processed in sequential order, the tasks are\nsubmitted to a thread executor, which may complete the tasks in any\norder. Therefore, the output cannot be determined ahead of time, and\noption E is correct. Finally, the thread executor is never shut down;\ntherefore, the code will run but never terminate, making option G also\ncorrect."
            },
            {
                "id": "82f28a8b-0199-1000-7e8d-0000a822659b",
                "question": "20. What is the result of executing the following program?\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class PrintCounter {\nstatic int count = 0;\npublic static void main(String[] args) throws\nInterruptedException,\nExecutionException {\ntry (var service =\nExecutors.newSingleThreadExecutor()) {\nvar r = new ArrayList<Future<?>>();\nIntStream.iterate(0,i -> i + 1).limit(5).forEach(\ni -> r.add(service.execute(() -> {count++;})) // n1\n);\nfor (Future<?> result : r) {\nSystem.out.print(result.get() + \" \"); // n2\n}\n}\n} }",
                "answer_options": [
                    "A. It prints 0 1 2 3 4",
                    "B. It prints 1 2 3 4 5",
                    "C. It prints null null null null null",
                    "D. It hangs indefinitely at runtime.",
                    "E. The output cannot be determined.",
                    "F. The code will not compile because of line n1.",
                    "G. The code will not compile because of line n2."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "20. F. The key to solving this question is to remember that the execute()\nmethod returns void, not a Future object. Therefore, line n1 does not\ncompile, and option F is the correct answer. If the submit() method\nhad been used instead of execute(), option C would have been the\ncorrect answer, as the output of the submit(Runnable) task is a\nFuture<?> object that can only return null on its get() method."
            },
            {
                "id": "82f28a8b-0199-1000-449a-0000bf35697a",
                "question": "21. Given the following code snippet and blank lines on p1 and p2, which\nvalues guarantee that 1 is printed at runtime? (Choose all that apply.)\n\nvar data = List.of(List.of(1, 2),\nList.of(3, 4),\nList.of(5, 6));\ndata._______________ // p1\n.flatMap(s -> s.stream())\n.________________ // p2\n.ifPresent(System.out::print);",
                "answer_options": [
                    "A. stream() on line p1, findFirst() on line p2.",
                    "B. stream() on line p1, findAny() on line p2.",
                    "C. parallelStream() on line p1, findAny() on line p2.",
                    "D. parallelStream() on line p1, findFirst() on line p2.",
                    "E. The code does not compile regardless of what is inserted into the",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    0,
                    3
                ],
                "correct_answer_explanation": "21. A, D. The findFirst() method guarantees the first element in the\nstream will be returned, whether it is serial or parallel, making options\nA and D correct. While option B may consistently print 1 at runtime,\nthe behavior of findAny() on a serial stream is not guaranteed, so\noption B is incorrect. Option C is likewise incorrect, with the output\nbeing random at runtime."
            },
            {
                "id": "82f28a8b-0199-1000-9dca-0000906f0994",
                "question": "22. Assuming one minute is enough time for the tasks submitted to the\nservice executor to complete, what is the result of executing\ncountSheep()?\n\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\npublic class BedTime {\nprivate AtomicInteger s1 = new AtomicInteger(0); // w1\nprivate int s2 = 0;\nprivate void countSheep() throws InterruptedException {\ntry (var service =\nExecutors.newSingleThreadExecutor()) { // w2\nfor (int i = 0; i < 100; i++)\nservice.execute(() -> {\ns1.getAndIncrement(); s2++; }); // w3\nThread.sleep(60_000);\nSystem.out.println(s1 + \" \" + s2);\n}\n}\npublic static void main(String… nap)\nthrows InterruptedException {\nnew BedTime().countSheep();\n} }",
                "answer_options": [
                    "A. The method consistently prints 100 99.",
                    "B. The method consistently prints 100 100.",
                    "C. The output cannot be determined ahead of time.",
                    "D. The code will not compile because of line w1.",
                    "E. The code will not compile because of line w2.",
                    "F. The code will not compile because of line w3.",
                    "G. It compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "22. B. The code compiles and runs without issue. The key aspect to notice\nin the code is that a single-thread executor is used, meaning that no\ntask will be executed concurrently. Therefore, the results are valid and\npredictable, with 100 100 being the output, and option B is the correct\nanswer. If a thread executor with more threads was used, then the s2++\noperations could overwrite each other, making the second value\nindeterminate at the end of the program. In this case, option C would\nbe the correct answer."
            },
            {
                "id": "82f28a8b-0199-1000-84ca-000037e5ba70",
                "question": "23. What is the result of executing the following application?\n\nimport java.util.concurrent.*;\nimport java.util.stream.*;\npublic class StockRoomTracker {\npublic static void await(CyclicBarrier cb) { // j1\ntry { cb.await(); } catch (Exception e) {}\n}\npublic static void main(String[] args) {\nvar cb = new CyclicBarrier(10,\n() -> System.out.println(\"Stock Room Full!\")); // j2\nIntStream.iterate(1, i -> 1).limit(9).parallel()\n.forEach(i -> await(cb)); // j3\n} }",
                "answer_options": [
                    "A. It outputs Stock Room Full!",
                    "B. The code will not compile because of line j1.",
                    "C. The code will not compile because of line j2.",
                    "D. The code will not compile because of line j3.",
                    "E. It compiles but throws an exception at runtime.",
                    "F. It compiles but waits forever at runtime."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "23. F. The code compiles without issue, so options B, C, and D are\nincorrect. The limit on the cyclic barrier is 10, but the stream can\ngenerate only up to 9 threads that reach the barrier; therefore, the limit\ncan never be reached, and option F is the correct answer, making\noptions A and E incorrect. Even if the limit(9) statement was\nchanged to limit(10), the program could still hang since the JVM\nmight not allocate 10 threads to the parallel stream."
            },
            {
                "id": "82f28a8b-0199-1000-2f42-000069c75577",
                "question": "24. What statements about the following class definition are true? (Choose all that apply.)\n\npublic final class TicketManager {\nprivate int tickets;\nprivate static TicketManager instance;\nprivate TicketManager() {}\nstatic synchronized TicketManager getInstance() {\n// k1\nif (instance==null) instance = new TicketManager();\n// k2\nreturn instance;\n}\npublic int getTicketCount() { return tickets; }\npublic void addTickets(int value) {tickets += value;}\n// k3\npublic void sellTickets(int value) {\nsynchronized (this) {\n// k4\ntickets -= value;\n} } }",
                "answer_options": [
                    "A. It compiles without issue.",
                    "B. The code will not compile because of line k2.",
                    "C. The code will not compile because of line k3.",
                    "D. The locks acquired on k1 and k4 are on the same object.",
                    "E. The class correctly protects the tickets data from race",
                    "F. At most one instance of TicketManager will be created in an"
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "24. A, F. The class compiles without issue, so option A is correct. Since\ngetInstance() is a static method and sellTickets() is an instance\nmethod, lines k1 and k4 synchronize on different objects, making\noption D incorrect. The class is not thread-safe because the\naddTickets() method is not synchronized, and option E is incorrect.\nOne thread could call sellTickets() while another thread calls\naddTickets(), possibly resulting in bad data. Finally, option F is\ncorrect because the getInstance() method is synchronized. Since the\nconstructor is private, this method is the only way to create an\ninstance of TicketManager outside the class. The first thread to enter\nthe method will set the instance variable, and all other threads will\nuse the existing value. This is a singleton pattern."
            },
            {
                "id": "82f28a8b-0199-1000-af28-000017901f0b",
                "question": "25. Assuming an implementation of the performCount() method is\nprovided prior to runtime, which of the following are possible results\nof executing the following application? (Choose all that apply.)\n\nimport java.util.*;\nimport java.util.concurrent.*;\npublic class CountZooAnimals {\npublic static void performCount(int animal) {\n// IMPLEMENTATION OMITTED\n}\npublic static void printResults(Future<?> f) {\ntry {\nSystem.out.println(f.get(1, TimeUnit.DAYS)); // o1\n} catch (Exception e) {\nSystem.out.println(\"Exception!\");\n}\n}\npublic static void main(String[] args) throws Exception\n{\nfinal var r = new ArrayList<Future<?>>();\ntry (var s = Executors.newSingleThreadExecutor()) {\nfor (int i = 0; i < 10; i++) {\nfinal int animal = i;\nr.add(s.submit(() -> performCount(animal))); // o2\n}\nr.forEach(f -> printResults(f));\n}\n} }",
                "answer_options": [
                    "A. It outputs a number 10 times.",
                    "B. It outputs a Boolean value 10 times.",
                    "C. It outputs a null value 10 times.",
                    "D. It outputs Exception! 10 times.",
                    "E. The code will not compile because of line o1.",
                    "F. The code will not compile because of line o2."
                ],
                "correct_answer_indexes": [
                    2,
                    3
                ],
                "correct_answer_explanation": "25. C, D. The code compiles and runs without issue, so options F and G\nare incorrect. The return type of performCount() is void, so submit()\nis interpreted as being applied to a Runnable expression. While\nsubmit(Runnable) does return a Future<?>, calling get() on it\nalways returns null. For this reason, options A and B are incorrect,\nand option C is correct. The performCount() method can also throw a\nruntime exception, which will then be thrown by the get() call as an\nExecutionException; therefore, option D is also a correct answer."
            },
            {
                "id": "82f28a8b-0199-1000-4813-0000f5b63120",
                "question": "1. Which class would be best to use to read a binary file into a Java\nobject?",
                "answer_options": [
                    "A. BufferedStream",
                    "B. FileReader",
                    "C. ObjectInputStream",
                    "D. ObjectReader",
                    "E. ObjectOutputStream",
                    "F. ObjectWriter",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "1. C. Since the question asks about putting data into a structured object,\nthe best class would be one that deserializes the data. Therefore,\nObjectInputStream is the best choice, which is option C.\nObjectWriter, BufferedStream, and ObjectReader are not I/O stream\nclasses. ObjectOutputStream is an I/O class but is used to serialize\ndata, not deserialize it. FileReader can be used to read text file data\nand construct an object, but the question asks what would be the best\nclass to use for binary data."
            },
            {
                "id": "82f28a8b-0199-1000-4d6c-0000047b8eb3",
                "question": "2. Assuming that / is the root directory within the file system, which of\nthe following are true statements? (Choose all that apply.)",
                "answer_options": [
                    "A. /home/parrot is an absolute path.",
                    "B. /home/parrot is a directory.",
                    "C. /home/parrot is a relative path.",
                    "D. new File(\"/home\") will throw an exception if /home does not",
                    "E. new File(\"/home\").delete() will throw an exception if /home",
                    "F. A Reader offers character encoding, making it more useful when",
                    "G. A Reader offers multithreading support, making it more useful"
                ],
                "correct_answer_indexes": [
                    0,
                    5
                ],
                "correct_answer_explanation": "2. A, F. Paths that begin with the root directory are absolute paths, so\noption A is correct, and option C is incorrect. Option B is incorrect\nbecause the path could be a file or directory within the file system.\nThere is no rule that files have to end with a file extension. Option D is\nincorrect, as it is possible to create a File reference to files and\ndirectories that do not exist. Option E is also incorrect. The delete()\nmethod returns false if the file or directory cannot be deleted.\nCharacter stream classes often include built-in convenience methods\nfor working with String data, so option F is correct. There is no such\noptimization for multithreading, making option G incorrect."
            },
            {
                "id": "82f28a8b-0199-1000-48ca-0000ee700354",
                "question": "3. What are possible results of executing the following code? (Choose all\nthat apply.)\n\npublic static void main(String[] args) throws IOException {\nString line;\nvar c = System.console();\nWriter w = c.writer();\ntry (w) {\nif ((line = c.readLine(\"Enter your name: \")) != null)\nw.append(line);\nw.flush();\n}\n}",
                "answer_options": [
                    "A. The code runs, but nothing is printed.",
                    "B. The code prints what was entered by the user.",
                    "C. The code behaves the same if throws IOException is removed.",
                    "D. A NullPointerException may be thrown.",
                    "E. A NullPointerException will always be thrown.",
                    "F. A NullPointerException will never be thrown.",
                    "G. The code does not compile."
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "3. B, D. If the console is unavailable, System.console() will return\nnull, making option D correct and options E and F incorrect. The\nwriter methods throw a checked IOException, making option C\nincorrect. The code works correctly, prompting for input and printing\nit. Therefore, option A is incorrect and option B is correct."
            },
            {
                "id": "82f28a8b-0199-1000-0d8b-0000d61d1c78",
                "question": "4. For which value of path sent to this method would it be guaranteed for\nthe following code to output Success?\n\npublic void removeBadFile(Path path) {\nif(Files.isDirectory(path))\nSystem.out.println(Files.deleteIfExists(path)\n  ? \"Success\": \"Try Again\");\n}",
                "answer_options": [
                    "A. path refers to a regular file in the file system.",
                    "B. path refers to a symbolic link in the file system.",
                    "C. path refers to an empty directory in the file system.",
                    "D. path refers to a directory with content in the file system.",
                    "E. path does not refer to a record that exists within the file system.",
                    "F. The code does not compile."
                ],
                "correct_answer_indexes": [
                    5
                ],
                "correct_answer_explanation": "4. F. The code does not compile, as Files.deleteIfExists() declares\nthe checked IOException that must be handled or declared.\nRemember, most Files methods declare IOException, especially the\nones that modify a file or directory. For this reason, option F is correct."
            },
            {
                "id": "82f28a8b-0199-1000-5f9e-0000e0f60657",
                "question": "5. Assume that the directory /animals exists and is empty. What is the\nresult of executing the following code?\n\nPath path = Path.of(\"/animals\");\ntry (var z = Files.walk(path)) {\nboolean b = z\n.filter((p,a) -> a.isDirectory() && !path.equals(p)) // x\n.findFirst().isPresent(); // y\nSystem.out.print(b ? \"No Sub\": \"Has Sub\");\n}",
                "answer_options": [
                    "A. It prints No Sub.",
                    "B. It prints Has Sub.",
                    "C. The code will not compile because of line x.",
                    "D. The code will not compile because of line y.",
                    "E. The output cannot be determined.",
                    "F. It produces an infinite loop at runtime."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "5. C. The filter() operation applied to a Stream<Path> takes only one\nparameter, not two, so the code does not compile, and option C is\ncorrect. If the code were rewritten to use the Files.find() method\nwith the BiPredicate as input (along with a maxDepth value), the\noutput would be option B, Has Sub, since the directory is given to be\nempty. For fun, we reversed the expected output of the ternary\noperation."
            },
            {
                "id": "82f28a8c-0199-1000-5c38-0000ec8a547b",
                "question": "6. What would be the value of name if the instance of Eagle created in the\nmain() method were serialized and then deserialized?\n\nimport java.io.Serializable;\nclass Bird {\nprotected transient String name;\npublic void setName(String name) { this.name = name; }\npublic String getName() { return name; }\npublic Bird() {\nthis.name = \"Matt\";\n}\n}\npublic class Eagle extends Bird implements Serializable {\n{ this.name = \"Olivia\"; }\npublic Eagle() {\nthis.name = \"Bridget\";\n}\npublic static void main(String[] args) {\nvar e = new Eagle();\ne.name = \"Adeline\";\n}\n}",
                "answer_options": [
                    "A. Adeline",
                    "B. Bridget",
                    "C. Matt",
                    "D. Olivia",
                    "E. null",
                    "F. The code does not compile.",
                    "G. The code compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "6. C. The code compiles and runs without issue, so options F and G are\nincorrect. The key here is that while Eagle is serializable, its parent\nclass, Bird, is not. Therefore, none of the members of Bird will be\nserialized. Even if you didn’t know that, you should know what\nhappens on deserialization. During deserialization, Java calls the\nconstructor of the first nonserializable parent. In this case, the Bird\nconstructor is called, with name being set to Matt, making option C\ncorrect. Note that none of the constructors or instance initializers in\nEagle is executed as part of deserialization."
            },
            {
                "id": "82f28a8c-0199-1000-25b6-0000c5eab09f",
                "question": "7. Assume that /kang exists as a symbolic link to the directory\n/mammal/kangaroo within the file system. Which of the following\nstatements are correct about this code snippet? (Choose all that apply.)\n\nvar path = Path.of(\"/kang\");\nif(Files.isDirectory(path) && Files.isSymbolicLink(path))\nFiles.createDirectory(path.resolve(\"joey\"));",
                "answer_options": [
                    "A. A new directory will always be created.",
                    "B. A new directory may be created.",
                    "C. If the code creates a directory, it will be reachable at /kang/joey.",
                    "D. If the code creates a directory, it will be reachable at",
                    "E. The code does not compile.",
                    "F. The code will compile but will always throw an exception at"
                ],
                "correct_answer_indexes": [
                    1,
                    2
                ],
                "correct_answer_explanation": "7. B, C. The code snippet will attempt to create a directory if the target of\nthe symbolic link exists and is a directory. If the directory already\nexists, though, it will throw an exception. For this reason, option A is\nincorrect, and option B is correct. It will be created in\n/mammal/kangaroo/joey and also reachable at /kang/joey because of\nthe symbolic link, making option C correct."
            },
            {
                "id": "82f28a8c-0199-1000-bce9-0000aec80a4c",
                "question": "8. Assuming that the /fox/food-schedule.csv file exists with the\nspecified contents, what is the expected output of calling printData()\non it?\n\n/fox/food-schedule.csv\n6am,Breakfast\n9am,SecondBreakfast\n12pm,Lunch\n6pm,Dinner\nvoid printData(Path path) throws IOException {\nFiles.readAllLines(path) // r1\n.flatMap(p -> Stream.of(p.split(\",\"))) // r2\n.map(q -> q.toUpperCase()) // r3\n.forEach(System.out::println);\n}",
                "answer_options": [
                    "A. The code will not compile because of line r1.",
                    "B. The code will not compile because of line r2.",
                    "C. The code will not compile because of line r3.",
                    "D. It throws an exception at runtime.",
                    "E. It does not print anything at runtime.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "8. B. The readAllLines() method returns a List, not a Stream.\nTherefore, the call to flatMap() is invalid, and option B is correct. If\nthe Files.lines() method were used instead, it would print the\ncontents of the file one capitalized word at a time with the commas\nremoved."
            },
            {
                "id": "82f28a8c-0199-1000-fe62-000069c5a84a",
                "question": "9. Given the following method and file1 data, which statements are\ncorrect? (Choose all that apply.)\n\n// file1 data\nABCDEF\npublic void copyFile(File file1, File file2) throws\nException {\nvar reader = new InputStreamReader(new\nFileInputStream(file1));\ntry (var writer = new FileWriter(file2)) {\nchar[] buffer = new char[5];\nwhile(reader.read(buffer) != -1) {\nwriter.write(buffer); // n1\n}\n}\n}",
                "answer_options": [
                    "A. The code does not compile because reader is not a buffered",
                    "B. The code does not compile because writer is not a buffered",
                    "C. The contents of the copied file are: ABCDEF",
                    "D. The contents of the copied file are: ABCDEFBCDE",
                    "E. The contents of the copied file cannot be determined.",
                    "F. If we check file2 on line n1 within the file system after five",
                    "G. If we check file2 on line n1 within the file system after five",
                    "H. This method contains a resource leak."
                ],
                "correct_answer_indexes": [
                    3,
                    5,
                    7
                ],
                "correct_answer_explanation": "9. D, F, H. First, the method does compile, so options A and B are\nincorrect. Methods to read/write byte[] values exist in the abstract\nparent of all I/O stream classes. This implementation is not correct,\nthough, as the return value of read(buffer) is not used properly. It\nwill only correctly copy files whose character count is a multiple of 5,\nmaking option D correct and options C and E incorrect. Option F is\nalso correct as the data may not have made it to disk yet. Option G\nwould be correct if the flush() method were called after every write.\nFinally, option H is correct as the reader stream is never closed."
            },
            {
                "id": "82f28a8c-0199-1000-fc3f-0000cffb28ec",
                "question": "10. Which of the following correctly create Path instances? (Choose all\nthat apply.)",
                "answer_options": [
                    "A. new Path(\"jaguar.txt\")",
                    "B. Path.get(\"cats\",\"lynx.txt\")",
                    "C. new java.io.File(\"tiger.txt\").toPath()",
                    "D. Paths.get(\"ocelot.txt\")",
                    "E. Path.of(\".\")"
                ],
                "correct_answer_indexes": [
                    2,
                    3,
                    4
                ],
                "correct_answer_explanation": "10. C, D, E. Option A is incorrect because Path is an abstract type so there\nis no constructor. Option B is incorrect because the static method in\nthe Path interface is of(), not get(). Options C, D, and E are correct\nways to obtain a Path instance."
            },
            {
                "id": "82f28a8c-0199-1000-5ef9-0000cc3bd49f",
                "question": "11. Which classes will allow the following to compile? (Choose all that\napply.)\n\nvar is = new BufferedInputStream(new\nFileInputStream(\"z.txt\"));\nInputStream wrapper = new\n____________________________________________ (is);\ntry (wrapper) {}",
                "answer_options": [
                    "A. BufferedInputStream",
                    "B. BufferedReader",
                    "C. BufferedWriter",
                    "D. FileInputStream",
                    "E. ObjectInputStream",
                    "F. ObjectOutputStream",
                    "G. None of the above, as the first line does not compile"
                ],
                "correct_answer_indexes": [
                    0,
                    4
                ],
                "correct_answer_explanation": "11. A, E. The code will compile if the correct classes are used, so option G\nis incorrect. Remember, a try-with-resources statement can use\nresources declared before the start of the statement. The reference type\nof wrapper is InputStream, so we need a class that inherits\nInputStream. We can eliminate BufferedWriter,\nObjectOutputStream, and BufferedReader since their names do not\nend in InputStream. Next, we see the class must take another stream\nas input, so we need to choose the remaining streams that are high-\nlevel streams. BufferedInputStream is a high-level stream, so option\nA is correct. Even though the instance is already a\nBufferedInputStream, there’s no rule that it can’t be wrapped\nmultiple times by a high-level stream. Option D is incorrect, as\nFileInputStream operates on a file, not another stream. Finally,\noption E is correct—an ObjectInputStream is a high-level stream that\noperates on other streams."
            },
            {
                "id": "82f28a8c-0199-1000-5f64-00007c1b800b",
                "question": "12. What is the result of executing the following code? (Choose all that\napply.)\n\n4: var p = Path.of(\"sloth.schedule\");\n5: var a = Files.readAttributes(p,\nBasicFileAttributes.class);\n6: Files.mkdir(p.resolve(\".backup\"));\n7: if(a.size()>0 && a.isDirectory()) {\n8: a.setTimes(null,null,null);\n9: }",
                "answer_options": [
                    "A. It compiles and runs without issue.",
                    "B. The code will not compile because of line 5.",
                    "C. The code will not compile because of line 6.",
                    "D. The code will not compile because of line 7.",
                    "E. The code will not compile because of line 8.",
                    "F. None of the above."
                ],
                "correct_answer_indexes": [
                    2,
                    4
                ],
                "correct_answer_explanation": "12. C, E. The method to create a directory in the Files class is\ncreateDirectory(), not mkdir(). For this reason, line 6 does not\ncompile, and option C is correct. In addition, the setTimes() method\nis available only on BasicFileAttributeView, not the read-only\nBasicFileAttributes, so line 8 will also not compile, making option\nE correct."
            },
            {
                "id": "82f28a8c-0199-1000-12db-0000e91ea4e8",
                "question": "13. Which of the following are true statements about serialization in Java?\n(Choose all that apply.)",
                "answer_options": [
                    "A. All non-null instance members of the class must be serializable",
                    "B. Records are automatically serializable.",
                    "C. Serialization involves converting data into Java objects.",
                    "D. Serializable is a functional interface.",
                    "E. The class must declare a static serialVersionUID variable.",
                    "F. The class must extend the Serializable class.",
                    "G. The class must implement the Serializable interface."
                ],
                "correct_answer_indexes": [
                    0,
                    6
                ],
                "correct_answer_explanation": "13. A, G. For a class to be serialized, it must implement the Serializable\ninterface and contain instance members that are serializable or marked\ntransient. For these reasons, options A and G are correct, and option\nF is incorrect. Option B is incorrect because even records are required\nto implement Serializable to be serialized. Option C is incorrect\nbecause it describes deserialization. The Serializable interface is a\nmarker interface that does not contain any abstract methods, making\noption D incorrect. While it is a good practice for a serializable class to\ninclude a static serialVersionUID variable, it is not required.\nTherefore, option E is incorrect as well."
            },
            {
                "id": "82f28a8c-0199-1000-9bc9-00001c7789dd",
                "question": "14. What is the output of the following code? (Choose three.)\n\n22: var p1 = Path.of(\"/zoo/./bear\",\"../food.txt\");\n23: p1.normalize().relativize(Path.of(\"/lion\"));\n24: System.out.println(p1);\n25:\n26: var p2 = Path.of(\"/zoo/animals/bear/koala/food.txt\");\n27: System.out.println(p2.subpath(1,3).getName(1));\n28:\n29: var p3 = Path.of(\"/pets/../cat.txt\");\n30: var p4 = Path.of(\"./dog.txt\");\n31: System.out.println(p4.resolve(p3));",
                "answer_options": [
                    "A. ../../lion",
                    "B. /zoo/./bear/../food.txt",
                    "C. animal",
                    "D. bear",
                    "E. /pets/../cat.txt",
                    "F. /pets/../cat.txt/./dog.txt"
                ],
                "correct_answer_indexes": [
                    1,
                    3,
                    4
                ],
                "correct_answer_explanation": "14. B, D, E. Path is immutable, so line 23 is ignored. If it were assigned to\np1, option A would be correct. Since it is not assigned, the original\nvalue is still present, which is option B. Moving on to the second\nsection, the subpath() method on line 27 is applied to the absolute\npath, which returns the relative path animals/bear. Next, the\ngetName() method is applied to the relative path, and since this is\nindexed from 0, it returns the relative path bear. Therefore, option D is\ncorrect. Finally, remember calling resolve() with an absolute path as\na parameter returns the absolute path, so option E is correct."
            },
            {
                "id": "82f28a8c-0199-1000-fe38-0000cb1e3165",
                "question": "15. Suppose that the working directory is /weather and the absolute path\n/weather/winter/snow.dat represents a file that exists within the file\nsystem. Which of the following lines of code create an object that\nrepresents the file? (Choose all that apply.)",
                "answer_options": [
                    "A. new File(\"/weather\", \"winter\", \"snow.dat\")",
                    "B. new File(\"/weather/winter/snow.dat\")",
                    "C. new File(\"/weather/winter\", new File(\"snow.dat\"))",
                    "D. new File(\"weather\", \"/winter/snow.dat\")",
                    "E. new File(new File(\"/weather/winter\"), \"snow.dat\")",
                    "F. Path.of(\"/weather/winter/snow.dat\").toFile()",
                    "G. None of the above"
                ],
                "correct_answer_indexes": [
                    1,
                    4,
                    5
                ],
                "correct_answer_explanation": "15. B, E, F. Option A does not compile, as there is no File constructor that\ntakes three parameters. Option B is correct and is the proper way to\ncreate a File instance with a single String parameter. Option C is\nincorrect, as there is no constructor that takes a String followed by a\nFile. There is a constructor that takes a File followed by a String,\nmaking option E correct. Option D is incorrect because the first\nparameter is missing a slash (/) to indicate it is an absolute path. Since\nit’s a relative path, it is correct only when the user’s current directory is\nthe root directory. Finally, option F is correct as it creates a File from\na Path."
            },
            {
                "id": "82f28a8c-0199-1000-64f0-00005be67ac0",
                "question": "16. Assuming zoo-data.txt exists and is not empty, what statements\nabout the following method are correct? (Choose all that apply.)\n\nprivate void echo() throws IOException {\nvar o = new FileWriter(\"new-zoo.txt\");\ntry (var f = new FileReader(\"zoo-data.txt\");\nvar b = new BufferedReader(f); o) {\no.write(b.readLine());\n}\no.write(\"\");\n}",
                "answer_options": [
                    "A. When run, the method creates a new file with one line of text in",
                    "B. When run, the method creates a new file with two lines of text in",
                    "C. When run, the method creates a new file with the same number of",
                    "D. The method compiles but will produce an exception at runtime.",
                    "E. The method does not compile.",
                    "F. The method uses byte stream classes."
                ],
                "correct_answer_indexes": [
                    0,
                    3
                ],
                "correct_answer_explanation": "16. A, D. The method compiles, so option E is incorrect. The method\ncreates a new-zoo.txt file and copies the first line from zoo-data.txt\ninto it, making option A correct. The try-with-resources statement\ncloses all of the declared resources, including the FileWriter o. For\nthis reason, the Writer is closed when the last o.write() is called,\nresulting in an IOException at runtime and making option D correct.\nOption F is incorrect because this implementation uses the character\nstream classes, which inherit from Reader or Writer."
            },
            {
                "id": "82f28a8c-0199-1000-4e8d-0000e59285be",
                "question": "17. Which are true statements? (Choose all that apply.)",
                "answer_options": [
                    "A. NIO.2 includes a method to delete an entire directory tree.",
                    "B. NIO.2 includes a method to traverse a directory tree.",
                    "C. NIO.2 includes methods that are aware of symbolic links.",
                    "D. Files.readAttributes() cannot access file system dependent",
                    "E. Files.readAttributes() is often more performant since it reads",
                    "F. Files.readAttributes() works with the File object."
                ],
                "correct_answer_indexes": [
                    1,
                    2,
                    4
                ],
                "correct_answer_explanation": "17. B, C, E. Options B and C are properties of NIO.2 and are good reasons\nto use it over the java.io.File class. Option A is incorrect as both\nAPIs can delete only empty directories, not a directory tree. Using a\nview to read multiple attributes leads to fewer round-trips between the\nprocess and the file system and better performance, making option E\ncorrect. Views can be used to access file system–specific attributes that\nare not available in Files methods; therefore, option D is incorrect.\nFiles is part of NIO.2, whereas File is part of java.io, which means\noption F is incorrect."
            },
            {
                "id": "82f28a8c-0199-1000-6d7b-000067280dbe",
                "question": "18. Assume that reader is a valid stream whose next characters are\nPEACOCKS. Which is true about the output of the following code\nsnippet?\n\nvar sb = new StringBuilder();\nsb.append((char)reader.read());\nreader.mark(10);\nfor(int i=0; i<2; i++) {\nsb.append((char)reader.read());\nreader.skip(2);\n}\nreader.reset();\nreader.skip(0);\nsb.append((char)reader.read());\nSystem.out.println(sb.toString());",
                "answer_options": [
                    "A. The code may print PEAE.",
                    "B. The code may print PEOA.",
                    "C. The code may print PEOE.",
                    "D. The code may print PEOS.",
                    "E. The code will always print PEAE.",
                    "F. The code will always print PEOA.",
                    "G. The code will always print PEOE.",
                    "H. The code will always print PEOS."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "18. C. To begin with, P is added to the StringBuilder first. Next,\nassuming mark() is supported, the position in the stream is marked\nbefore E. The E is added to the StringBuilder, with AC being skipped,\nand then the O is added to the StringBuilder, with CK being skipped.\nThe stream is then reset() to the position before the E. The call to\nskip(0) doesn’t do anything since there are no characters to skip, so E\nis added onto the StringBuilder in the next read() call. The value\nPEOE is printed, and option C is correct. Option G is incorrect because\nmark() may not be supported."
            },
            {
                "id": "82f28a8c-0199-1000-f755-000086973c63",
                "question": "19. Assuming that the directories and files referenced exist and are not\nsymbolic links, what is the result of executing the following code?\n\nvar p1 =\nPath.of(\"/lizard\",\".\").resolve(Path.of(\"walking.txt\"));\nvar p2 = new\nFile(\"/lizard/././actions/../walking.txt\").toPath();\nSystem.out.print(Files.isSameFile(p1,p2));\nSystem.out.print(\" \");\nSystem.out.print(p1.equals(p2));\nSystem.out.print(\" \");\nSystem.out.print(Files.mismatch(p1,p2));",
                "answer_options": [
                    "A. true true -1",
                    "B. true true 0",
                    "C. true false -1",
                    "D. true false 0",
                    "E. false true -1",
                    "F. false true 0",
                    "G. The code does not compile.",
                    "H. The result cannot be determined."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "19. C. The code compiles and runs without issue, so option G is incorrect.\nIf you simplify the redundant path symbols, p1 and p2 represent the\nsame path, /lizard/walking.txt. Therefore, isSameFile() returns\ntrue. The second output is false, because equals() checks only if the\npath values are the same, without reducing the path symbols. Finally,\nmismatch() sees that the contents are the same and returns -1. For\nthese reasons, option C is correct."
            },
            {
                "id": "82f28a8c-0199-1000-a973-0000e3450da5",
                "question": "20. Assume that monkey.txt is a file that exists in the current working\ndirectory. Which statement about the following code snippet is\ncorrect?\n\nFiles.move(Path.of(\"monkey.txt\"), Path.of(\"/animals\"),\nStandardCopyOption.ATOMIC_MOVE);",
                "answer_options": [
                    "A. If /animals/monkey.txt exists, it will be overwritten at runtime.",
                    "B. If /animals exists as an empty directory, /animals/monkey.txt",
                    "C. If the move is successful and another process is monitoring the",
                    "D. None of the above."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "20. C. The target path of the file after the move() operation is /animals,\nnot /animals/monkey.txt, so options A and B are both incorrect.\nBoth will throw an exception at runtime since /animals already exists\nand is a directory. The option ATOMIC_MOVE means that any process\nmonitoring the file system will not see an incomplete file during the\nmove, so option C is correct."
            },
            {
                "id": "82f28a8c-0199-1000-8f38-00007464dbeb",
                "question": "21. Assume that /monkeys exists as a directory containing multiple files,\nsymbolic links, and subdirectories. Which statement about the\nfollowing code is correct?\n\nvar f = Path.of(\"/monkeys\");\ntry (var m =\nFiles.find(f, 0, (p,a) -> a.isSymbolicLink())) { // y1\nm.map(s -> s.toString())\n.collect(Collectors.toList())\n.stream()\n.filter(s -> s.toString().endsWith(\".txt\")) // y2\n.forEach(System.out::println);\n}",
                "answer_options": [
                    "A. It will print all symbolic links in the directory tree ending in .txt.",
                    "B. It will print the target of all symbolic links in the directory ending",
                    "C. It will print nothing.",
                    "D. It does not compile because of line y1.",
                    "E. It does not compile because of line y2.",
                    "F. It compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    2
                ],
                "correct_answer_explanation": "21. C. The code compiles and runs without issue, so options D, E, and F\nare incorrect. The most important thing to notice is that the depth\nparameter specified as the second argument to find() is 0, meaning\nthe only record that will be searched is the top-level directory. Since\nwe know that the top directory is a directory and not a symbolic link,\nno other paths will be visited, and nothing will be printed. For these\nreasons, option C is the correct answer."
            },
            {
                "id": "82f28a8c-0199-1000-f993-0000ed920b87",
                "question": "22. Which of the following fields will be null after an instance of the\nclass created on line 17 is serialized and then deserialized using\nObjectOutputStream and ObjectInputStream?\n\n1: import java.io.Serializable;\n2: import java.util.List;\n3: public class Zebra implements Serializable {\n4: private transient String name = \"George\";\n5: private static String birthPlace = \"Africa\";\n6: private transient Integer age;\n7: List<Zebra> friends = new java.util.ArrayList<>();\n8: private Object stripes = new Object();\n9: { age = 10;}\n10: public Zebra() {\n11: this.name = \"Sophia\";\n12: }\n13: static Zebra writeAndRead(Zebra z) {\n14: // Implementation omitted\n15: }\n16: public static void main(String[] args) {\n17: var zebra = new Zebra();\n18: zebra = writeAndRead(zebra);\n19: } }",
                "answer_options": [
                    "A. age",
                    "B. birthplace",
                    "C. friends",
                    "D. name",
                    "E. stripes",
                    "F. The code does not compile.",
                    "G. The code compiles but throws an exception at runtime."
                ],
                "correct_answer_indexes": [
                    6
                ],
                "correct_answer_explanation": "22. G. The code compiles, so option F is incorrect. To be serializable, a\nclass must implement the Serializable interface, which Zebra does.\nIt must also contain instance members that either are marked\ntransient or are serializable. The instance member stripes is of type\nObject, which is not serializable. If Object implemented\nSerializable, all objects would be serializable by default, defeating\nthe purpose of having the Serializable interface. Therefore, the\nZebra class is not serializable, with the program throwing an exception\nat runtime if serialized and making option G correct. If stripes were\nremoved from the class, options A and D would be the correct\nanswers, as name and age are both marked transient."
            },
            {
                "id": "82f28a8c-0199-1000-f4f8-0000b8d1ffae",
                "question": "23. What are some possible results of executing the following code?\n(Choose all that apply.)\n\nvar x = Path.of(\"/animals/fluffy/..\");\nFiles.walk(x.toRealPath().getParent()) // u1\n.map(p -> p.toAbsolutePath().toString()) // u2\n.filter(s -> s.endsWith(\".java\"))\n.forEach(System.out::println);",
                "answer_options": [
                    "A. It prints some files in the root directory.",
                    "B. It prints all files in the root directory.",
                    "C. FileSystemLoopException is thrown at runtime.",
                    "D. Another exception is thrown at runtime.",
                    "E. The code will not compile because of line u1.",
                    "F. The code will not compile because of line u2."
                ],
                "correct_answer_indexes": [
                    0,
                    3
                ],
                "correct_answer_explanation": "23. A, D. The code compiles without issue, so options E and F are\nincorrect. The toRealPath() method will simplify the path to\n/animals and throw an exception if it does not exist, making option D\ncorrect. If the path does exist, calling getParent() on it returns the\nroot directory. Walking the root directory with the filter expression will\nprint all .java files in the root directory (along with all .java files in\nthe directory tree), making option A correct. Option B is incorrect\nbecause it will skip files and directories that do not end in the .java\nextension. Option C is also incorrect as Files.walk() does not follow\nsymbolic links by default. Only if the FOLLOW_LINKS option is provided\nand a cycle is encountered will the exception be thrown."
            },
            {
                "id": "82f28a8c-0199-1000-ec5c-00002c0a1ced",
                "question": "24. Assume that the source instance passed to the following method\nrepresents a file that exists. Also assume that /flip/sounds.txt exists\nas a file prior to executing this method. When this method is executed,\nwhich statement correctly copies the file to the path specified by\n/flip/sounds.txt?\n\nvoid copyIntoFlipDirectory(Path source) throws IOException\n{\nvar dolphinDir = Path.of(\"/flip\");\ndolphinDir = Files.createDirectories(dolphinDir);\nvar n = Path.of(\"sounds.txt\");\nFiles.copy(source,_________________________________________\n___);\n}",
                "answer_options": [
                    "A. dolphinDir",
                    "B. dolphinDir.resolve(n),",
                    "C. dolphinDir, StandardCopyOption.REPLACE_EXISTING",
                    "D. dolphinDir.resolve(n)",
                    "E. The method does not compile, regardless of what is placed in the",
                    "F. The method compiles but throws an exception at runtime,"
                ],
                "correct_answer_indexes": [
                    1
                ],
                "correct_answer_explanation": "24. B. The method compiles without issue, so option E is incorrect. Option\nF is also incorrect. Even though /flip exists, createDirectories()\ndoes not throw an exception if the path already exists. If\ncreateDirectory() were used instead, option F would be correct.\nNext, the copy() command takes a target that is the path to the new\nfile location, not the directory to be copied into. Therefore, the target\npath should be /flip/sounds.txt, not /flip. For this reason, options\nA and C are incorrect. Since the question says the file already exists,\nthe REPLACE_EXISTING option must be specified or an exception will\nbe thrown at runtime, making option B the correct answer."
            },
            {
                "id": "82f28a8c-0199-1000-2c4e-000087a71977",
                "question": "25. Suppose that you need to read text data from a file and want the data to\nbe performant on large files. Which two java.io stream classes can be\nchained together to best achieve this result? (Choose two.)",
                "answer_options": [
                    "A. BufferedInputStream",
                    "B. BufferedReader",
                    "C. FileInputStream",
                    "D. FileReader",
                    "E. PrintInputStream",
                    "F. ObjectInputStream",
                    "G. PrintReader"
                ],
                "correct_answer_indexes": [
                    1,
                    3
                ],
                "correct_answer_explanation": "25. B, D. Since you need to read characters, the Reader classes are\nappropriate. Therefore, you can eliminate options A, C, and F.\nAdditionally, options E and G are incorrect, as they reference classes\nthat do not exist. Options B and D are correct since they read from a\nfile and buffer for performance."
            }
        ]
    }
]